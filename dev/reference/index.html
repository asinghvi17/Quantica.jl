<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Quantica.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://pablosanjose.github.io/Quantica.jl/reference/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Quantica.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Quantica.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Quantica.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pablosanjose/Quantica.jl/blob/master/docs/src/reference.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><ul><li><a href="#Quantica.Quantica"><code>Quantica.Quantica</code></a></li><li><a href="#Quantica.BoxIterator"><code>Quantica.BoxIterator</code></a></li><li><a href="#Quantica.EffectiveMatrix"><code>Quantica.EffectiveMatrix</code></a></li><li><a href="#Quantica.Schur1D"><code>Quantica.Schur1D</code></a></li><li><a href="#Base.:&amp;-Tuple{Quantica.Hamiltonian{#s41,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s41&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s40,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s40&lt;:Quantica.Superlattice}"><code>Base.:&amp;</code></a></li><li><a href="#Base.:|-Tuple{Quantica.Hamiltonian{#s41,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s41&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s40,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s40&lt;:Quantica.Superlattice}"><code>Base.:|</code></a></li><li><a href="#Base.xor-Tuple{Quantica.Hamiltonian{#s41,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s41&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s40,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s40&lt;:Quantica.Superlattice}"><code>Base.xor</code></a></li><li><a href="#Quantica.DACPdiagonaliser-Tuple{Any,Any,Any}"><code>Quantica.DACPdiagonaliser</code></a></li><li><a href="#Quantica.DACPdiagonaliser-Tuple{Quantica.Hamiltonian,Any}"><code>Quantica.DACPdiagonaliser</code></a></li><li><a href="#Quantica._chebyshev_loop!-NTuple{5,Any}"><code>Quantica._chebyshev_loop!</code></a></li><li><a href="#Quantica.averageKPM-Tuple{Any,Any}"><code>Quantica.averageKPM</code></a></li><li><a href="#Quantica.bands-Tuple{Quantica.Bandstructure}"><code>Quantica.bands</code></a></li><li><a href="#Quantica.bandstructure-Tuple"><code>Quantica.bandstructure</code></a></li><li><a href="#Quantica.basiskets"><code>Quantica.basiskets</code></a></li><li><a href="#Quantica.bloch"><code>Quantica.bloch</code></a></li><li><a href="#Quantica.bloch!"><code>Quantica.bloch!</code></a></li><li><a href="#Quantica.bravais-Tuple{Quantica.AbstractLattice}"><code>Quantica.bravais</code></a></li><li><a href="#Quantica.chebyshev_filter"><code>Quantica.chebyshev_filter</code></a></li><li><a href="#Quantica.combine-Tuple{Vararg{Quantica.Lattice,N} where N}"><code>Quantica.combine</code></a></li><li><a href="#Quantica.combine-Tuple{Vararg{Quantica.Hamiltonian,N} where N}"><code>Quantica.combine</code></a></li><li><a href="#Quantica.cuboid-Union{Tuple{Vararg{Tuple,L}}, Tuple{L}} where L"><code>Quantica.cuboid</code></a></li><li><a href="#Quantica.deflate-Tuple{Any,Any,Any}"><code>Quantica.deflate</code></a></li><li><a href="#Quantica.degeneracy-Tuple{Quantica.Subspace}"><code>Quantica.degeneracy</code></a></li><li><a href="#Quantica.densityKPM-Tuple{Any,Any}"><code>Quantica.densityKPM</code></a></li><li><a href="#Quantica.diagonalizer-Tuple{Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian}}"><code>Quantica.diagonalizer</code></a></li><li><a href="#Quantica.dims-Union{Tuple{Quantica.AbstractLattice{E,L,T} where T}, Tuple{L}, Tuple{E}} where L where E"><code>Quantica.dims</code></a></li><li><a href="#Quantica.dosKPM-Tuple{Any}"><code>Quantica.dosKPM</code></a></li><li><a href="#Quantica.flatten-Tuple{}"><code>Quantica.flatten</code></a></li><li><a href="#Quantica.gap-Tuple{Quantica.Bandstructure{1,C,T,B,M} where M&lt;:Quantica.Diagonalizer where B&lt;:(Quantica.Band{1,C,T,S,S´,D´} where D´ where S´&lt;:(AbstractArray{T,2} where T) where S&lt;:AbstractArray{C,2}) where T where C,Any}"><code>Quantica.gap</code></a></li><li><a href="#Quantica.gapedge-Tuple{Quantica.Bandstructure{1,C,T,B,M} where M&lt;:Quantica.Diagonalizer where B&lt;:(Quantica.Band{1,C,T,S,S´,D´} where D´ where S´&lt;:(AbstractArray{T,2} where T) where S&lt;:AbstractArray{C,2}) where T where C,Any}"><code>Quantica.gapedge</code></a></li><li><a href="#Quantica.greens-Union{Tuple{L}, Tuple{Quantica.Hamiltonian{#s39,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where #s39,Any}} where L"><code>Quantica.greens</code></a></li><li><a href="#Quantica.hamiltonian-Tuple{Quantica.AbstractLattice,Vararg{Any,N} where N}"><code>Quantica.hamiltonian</code></a></li><li><a href="#Quantica.hopping-Tuple{Any}"><code>Quantica.hopping</code></a></li><li><a href="#Quantica.hopselector-Tuple{}"><code>Quantica.hopselector</code></a></li><li><a href="#Quantica.ijselector-NTuple{4,Any}"><code>Quantica.ijselector</code></a></li><li><a href="#Quantica.isinband-Tuple{Quantica.Bandstructure,Any}"><code>Quantica.isinband</code></a></li><li><a href="#Quantica.iterateDACP_f!-NTuple{4,Any}"><code>Quantica.iterateDACP_f!</code></a></li><li><a href="#Quantica.iterateDACP_g!-NTuple{4,Any}"><code>Quantica.iterateDACP_g!</code></a></li><li><a href="#Quantica.iterate_chebyshev-Tuple{Any,Array{Array{Complex{Float64},2},1},Any,Any,Any}"><code>Quantica.iterate_chebyshev</code></a></li><li><a href="#Quantica.ket-Tuple{AbstractArray{T,1} where T,Quantica.OrbitalStructure}"><code>Quantica.ket</code></a></li><li><a href="#Quantica.ketmodel-Tuple{Any}"><code>Quantica.ketmodel</code></a></li><li><a href="#Quantica.lattice-Tuple{Quantica.Sublat,Vararg{Quantica.Sublat,N} where N}"><code>Quantica.lattice</code></a></li><li><a href="#Quantica.maxima-Union{Tuple{Quantica.Bandstructure{1,#s35,T,B,M} where M&lt;:Quantica.Diagonalizer where B&lt;:(Quantica.Band{1,#s35,T,S,S´,D´} where D´ where S´&lt;:(AbstractArray{T,2} where T) where S&lt;:AbstractArray{#s35,2}) where #s35}, Tuple{T}} where T"><code>Quantica.maxima</code></a></li><li><a href="#Quantica.minima-Union{Tuple{Quantica.Bandstructure{1,#s35,T,B,M} where M&lt;:Quantica.Diagonalizer where B&lt;:(Quantica.Band{1,#s35,T,S,S´,D´} where D´ where S´&lt;:(AbstractArray{T,2} where T) where S&lt;:AbstractArray{#s35,2}) where #s35}, Tuple{T}} where T"><code>Quantica.minima</code></a></li><li><a href="#Quantica.momentaKPM"><code>Quantica.momentaKPM</code></a></li><li><a href="#Quantica.mul_f!-NTuple{4,Any}"><code>Quantica.mul_f!</code></a></li><li><a href="#Quantica.mul_g!-NTuple{4,Any}"><code>Quantica.mul_g!</code></a></li><li><a href="#Quantica.not-Tuple{Any}"><code>Quantica.not</code></a></li><li><a href="#Quantica.nrange-Tuple{Int64}"><code>Quantica.nrange</code></a></li><li><a href="#Quantica.offdiagonal-Tuple{Quantica.TightbindingModel,Any,Any}"><code>Quantica.offdiagonal</code></a></li><li><a href="#Quantica.onsite-Tuple{Any}"><code>Quantica.onsite</code></a></li><li><a href="#Quantica.orbitalstructure-Tuple{Quantica.Hamiltonian}"><code>Quantica.orbitalstructure</code></a></li><li><a href="#Quantica.parameters-Tuple{Quantica.ParametricHamiltonian}"><code>Quantica.parameters</code></a></li><li><a href="#Quantica.parameters-Tuple{Vararg{Quantica.AbstractModifier,N} where N}"><code>Quantica.parameters</code></a></li><li><a href="#Quantica.parametric-Tuple{Quantica.Hamiltonian,Vararg{Quantica.AbstractModifier,N} where N}"><code>Quantica.parametric</code></a></li><li><a href="#Quantica.proj_DACP-Tuple{Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian},Any}"><code>Quantica.proj_DACP</code></a></li><li><a href="#Quantica.proj_h_s-Tuple{Quantica.DACPsubspace,Any,Missing,Any}"><code>Quantica.proj_h_s</code></a></li><li><a href="#Quantica.qz_diag-Tuple{Any,Any}"><code>Quantica.qz_diag</code></a></li><li><a href="#Quantica.randomkets"><code>Quantica.randomkets</code></a></li><li><a href="#Quantica.rank"><code>Quantica.rank</code></a></li><li><a href="#Quantica.semicircle_filter-Tuple{Quantica.ParametricHamiltonian,Any}"><code>Quantica.semicircle_filter</code></a></li><li><a href="#Quantica.similarmatrix"><code>Quantica.similarmatrix</code></a></li><li><a href="#Quantica.siteindices-Tuple{Quantica.AbstractLattice}"><code>Quantica.siteindices</code></a></li><li><a href="#Quantica.sitepositions-Tuple{Quantica.AbstractLattice}"><code>Quantica.sitepositions</code></a></li><li><a href="#Quantica.siteselector-Tuple{}"><code>Quantica.siteselector</code></a></li><li><a href="#Quantica.splitbands-Tuple{Quantica.Bandstructure}"><code>Quantica.splitbands</code></a></li><li><a href="#Quantica.sublat-Tuple{AbstractArray{#s39,1} where #s39&lt;:(StaticArrays.SArray{Tuple{S},T,1,S} where T where S)}"><code>Quantica.sublat</code></a></li><li><a href="#Quantica.subspace_dimension-Tuple{Any,Any}"><code>Quantica.subspace_dimension</code></a></li><li><a href="#Quantica.supercell-Tuple"><code>Quantica.supercell</code></a></li><li><a href="#Quantica.transform!-Tuple{Function}"><code>Quantica.transform!</code></a></li><li><a href="#Quantica.transform!-Tuple{Any,Quantica.Spectrum}"><code>Quantica.transform!</code></a></li><li><a href="#Quantica.transform!-Tuple{Any,Quantica.Bandstructure}"><code>Quantica.transform!</code></a></li><li><a href="#Quantica.transform!-Tuple{Any,Quantica.Hamiltonian}"><code>Quantica.transform!</code></a></li><li><a href="#Quantica.twoqr_diag-Tuple{Array{Complex{Float64},2},Array{Complex{Float64},2}}"><code>Quantica.twoqr_diag</code></a></li><li><a href="#Quantica.unflatten-Tuple{Quantica.OrbitalStructure}"><code>Quantica.unflatten</code></a></li><li><a href="#Quantica.unitcell-Tuple{Vararg{Union{Integer, Tuple, StaticArrays.SArray{Tuple{S},T,1,S} where T where S, StaticArrays.SArray{Tuple{S1,S2},T,2,L} where L where T where S2 where S1},N} where N}"><code>Quantica.unitcell</code></a></li><li><a href="#Quantica.vertices-Tuple{Quantica.Bandstructure,Any}"><code>Quantica.vertices</code></a></li><li><a href="#Quantica.wrap-Tuple{Quantica.Hamiltonian,Int64}"><code>Quantica.wrap</code></a></li><li><a href="#Quantica.@block!-Tuple{Any,Any,Any,Vararg{Any,N} where N}"><code>Quantica.@block!</code></a></li><li><a href="#Quantica.@hopping!-Tuple{Any,Any}"><code>Quantica.@hopping!</code></a></li><li><a href="#Quantica.@onsite!-Tuple{Any,Any}"><code>Quantica.@onsite!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Quantica.Quantica" href="#Quantica.Quantica"><code>Quantica.Quantica</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>Quantica.jl</strong></p><p><a href="https://pablosanjose.github.io/Quantica.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt="Stable"/></a> <a href="https://pablosanjose.github.io/Quantica.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt="Dev"/></a> <a href="https://doi.org/10.5281/zenodo.4762964"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.4762964.svg" alt="DOI"/></a> <a href="https://github.com/pablosanjose/Quantica.jl/actions"><img src="https://github.com/pablosanjose/Quantica.jl/workflows/CI/badge.svg" alt="Build Status"/></a> <a href="https://codecov.io/gh/pablosanjose/Quantica.jl"><img src="https://codecov.io/gh/pablosanjose/Quantica.jl/branch/master/graph/badge.svg" alt="Coverage"/></a> <a href="https://github.com/pablosanjose/Quantica.jl"><img src="https://img.shields.io/github/commits-since/pablosanjose/Quantica.jl/latest?include_prereleases&amp;sort=semver&amp;style=social" alt="GitHub commits since last release"/></a></p><p>The Quantica.jl package provides an expressive API to build arbitrary quantum systems on a discrete lattice, and to compute a number of their properties.</p><p><strong>Some current features</strong></p><ul><li>Build Hamiltonians on discrete lattices of arbitrary dimensions, using tight-binding models with arbitrary number of orbitals</li><li>Compute band structures of periodic systems and extract individual bands by interpolation</li><li>Compute electronic structures and expectation values using Kernel Polynomial methods</li></ul><p><strong>Exported API</strong></p><ul><li><code>lattice</code>, <code>sublat</code>: build lattices</li><li><code>hopping</code>, <code>onsite</code>, <code>siteselector</code>, <code>hopselector</code>, <code>nrange</code>, <code>not</code>: build tightbinding models</li><li><code>hamiltonian</code>: build a Hamiltonian from tightbinding model and a lattice</li><li><code>bloch</code>, <code>bloch!</code>, <code>similarmatrix</code>: build the Bloch matrix of a Hamiltonian</li><li><code>parametric</code>, <code>@onsite!</code>, <code>@hopping!</code>, <code>parameters</code>: build a parametric Hamiltonian</li><li><code>dims</code>, <code>sitepositions</code>, <code>siteindices</code>, <code>bravais</code>: inspect lattices and Hamiltonians</li><li><code>supercell</code>, <code>unitcell</code>, <code>wrap</code>, <code>transform!</code>, <code>combine</code>: build derived lattices or Hamiltonians</li><li><code>ket</code>, <code>ketmodel</code>, <code>randomkets</code>, <code>basiskets</code>: define kets and ket models for use in e.g. KPM routines</li><li><code>flatten</code>, <code>unflatten</code>, <code>orbitalstructure</code>: operate with multiorbital Hamiltonian, Kets or Subspaces</li><li><code>cuboid</code>: build a bandstructure discretization mesh</li><li><code>bandstructure</code>, <code>spectrum</code>, <code>diagonalizer</code>: compute the generalized bandstructure of a Hamiltonian or a ParametricHamiltonian</li><li><code>bands</code>, <code>energies</code>, <code>states</code>, <code>minima</code>, <code>maxima</code>, <code>gapedge</code>, <code>gap</code>, <code>isinband</code>: inspect spectrum and bandstructure objects</li><li><code>momentaKPM</code>, <code>dosKPM</code>, <code>averageKPM</code>, <code>densityKPM</code>, <code>bandrangeKPM</code>: Kernel Polynomial Method (KPM)</li><li><code>greens</code>, <code>greensolver</code>: build Green&#39;s functions of a Hamiltonian</li></ul><p>Some of this functionality require loading one or more third-party packages, which include the following:</p><ul><li>KPM: <code>FFTW</code>, <code>ArnoldiMethod</code></li><li>Bandstructures: <code>Arpack</code>, <code>ArnoldiMethod</code>, <code>KrylovKit</code></li></ul><p>The user is told when this is needed. We do this to reduce dependencies and launch time with packages whose functionality is not essential for the use of Quantica.jl</p><p>Other functions become available after loading specific third-party packages:</p><ul><li>Makie: enables <code>plot(::Hamiltonian)</code> and <code>plot(::Bandstructure)</code> (for 1D and 2D bandstructures)</li><li>VegaLite: enables <code>vlplot(::Hamiltonian)</code> and <code>vlplot(::Bandstructure)</code> (for 1D bandstructures)</li></ul><p><strong>Funding</strong></p><pre><code class="nohighlight hljs">This work has been partly funded by the Spanish Ministry of Economy and Competitiveness under Grant Nos. FIS2015-65706-P, PCI2018-093026, and the CSIC Intramural Project 201760I086.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/Quantica.jl#LL5-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.BoxIterator" href="#Quantica.BoxIterator"><code>Quantica.BoxIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxIterator(seed::SVector{N,Int}; maxiterations = missing)</code></pre><p>Cartesian iterator <code>iter</code> over <code>SVector{N,Int}</code>s (<code>cell</code>s) that starts at <code>seed</code> and grows outwards in the form of a box of increasing sides (not necesarily equal) until it encompasses a certain N-dimensional region. To signal that a cell is in the desired region the user calls <code>acceptcell!(iter, cell)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/iterators.jl#LL5-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.EffectiveMatrix" href="#Quantica.EffectiveMatrix"><code>Quantica.EffectiveMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EffectiveMatrix</code></pre><p>A dense matrix of the form <code>matrix = [ZaL(ω) L&#39; 0; L*ZaR(ω) I*ω-H R*ZrL(ω); 0 R&#39; ZrR(ω)]</code>, where H, L and R are given at construction, while ω, and the Z&#39;s are given at runtime.</p><p>This is equivalent, integrating out the Z blocks, to dressing I*ω-H with self energies     Σ₊ = h₋g₀h₊ = h₋ Φr Λr Φr⁻¹ = R ZrL ZrR⁻¹ R&#39;     Σ₋ = h₊g₀h₋ = h₋ Φa Λa Φa⁻¹ = L ZaR ZaL⁻¹ L&#39; where     h₊ = L&#39;R     h₋ = R&#39;L     ΦrL = L&#39; Φr Λr = ZrL * R11r     ΦrR = R&#39; Φr = ZrR * R11r     ΦaL = L&#39; Φa Λa = ZaL * R11a     ΦaR = R&#39; Φa = ZaR * R11a and Z = [ZrL ZaL; ZrR ZaR] is obtained from the QZ decomposition A - λB= Q(SA-λSB)Z&#39; of the deflated_pencil!(A, B), with eigenvalues ordered according to their modulus.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/effective.jl#LL4-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.Schur1D" href="#Quantica.Schur1D"><code>Quantica.Schur1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Schur1D()</code></pre><p>Return a Greens function solver using the generalized eigenvalue approach, whereby given the energy <code>ω</code>, the eigenmodes of the infinite 1D Hamiltonian, and the corresponding infinite and semi-infinite Greens function can be computed by solving the generalized eigenvalue equation</p><pre><code class="nohighlight hljs">A⋅φχ = λ B⋅φχ
A = [0 I; -h₊ ω-h₀]
B = [I 0; 0 h₋]</code></pre><p>This is the matrix form of the problem <code>λ(ω-h₀)φ - h₊φ - λ²h₋φ = 0</code>, where <code>φχ = [φ; λφ]</code>, and <code>φ</code> are <code>ω</code>-energy eigenmodes, with (possibly complex) momentum <code>q</code>, and eigenvalues are <code>λ = exp(-iqa₀)</code>. The algorithm assumes the Hamiltonian has only <code>dn = (0,)</code> and <code>dn = (±1, )</code> Bloch harmonics (<code>h₀</code>, <code>h₊</code> and <code>h₋</code>), and will error otherwise instructing the user to grow the unit cell. Bound states in the spectrum will yield delta functions in the density of states that can be resolved by adding a broadening in the form of a small positive imaginary part to <code>ω</code>. If <code>ω::Real</code>, a small imaginary part will be added automatically.</p><p>For performace, the eigenvalue equation may be <code>deflated&#39; and</code>stabilized&#39;, i.e. singular solutions <code>λ=0,∞</code> will be removed, and an inverse-free algorithm is used to preserve precision even in the presence of singularities.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra

julia&gt; h = LP.honeycomb() |&gt; hamiltonian(hopping(1)) |&gt; unitcell((1,-1), (10,10)) |&gt; wrap(2);

julia&gt; g = greens(h, Schur1D(), boundaries = (0,))
GreensFunction{Schur1DGreensSolver}: Green&#39;s function using the Schur1D method
  Flat matrix size      : 40 × 40
  Flat deflated size    : 20 × 20
  Original element type : scalar (ComplexF64)
  Boundaries            : (0,)

julia&gt; tr(g(0.3, 1=&gt;1))
-32.193416071797216 - 3.4400038418349084im</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`greens`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/greens.jl#LL81-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&amp;-Tuple{Quantica.Hamiltonian{#s41,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s41&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s40,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s40&lt;:Quantica.Superlattice}" href="#Base.:&amp;-Tuple{Quantica.Hamiltonian{#s41,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s41&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s40,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s40&lt;:Quantica.Superlattice}"><code>Base.:&amp;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">&amp;(h1::Hamiltonian{&lt;:Superlattice}, h2::Hamiltonian{&lt;:Superlattice})</code></pre><p>Construct a new <code>Hamiltonian{&lt;:Superlattice}</code> using an <code>and</code> boolean mask, i.e. with a supercell that contains cells that are both in the supercell of <code>h1</code> and <code>h2</code></p><pre><code class="nohighlight hljs">&amp;(s1::Superlattice, s2::Superlattice}</code></pre><p>Equivalent of the above for <code>Superlattice</code>s</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`|`, `xor`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/hamiltonian.jl#LL1117-L1129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:|-Tuple{Quantica.Hamiltonian{#s41,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s41&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s40,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s40&lt;:Quantica.Superlattice}" href="#Base.:|-Tuple{Quantica.Hamiltonian{#s41,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s41&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s40,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s40&lt;:Quantica.Superlattice}"><code>Base.:|</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">|(h1::Hamiltonian{&lt;:Superlattice}, h2::Hamiltonian{&lt;:Superlattice})</code></pre><p>Construct a new <code>Hamiltonian{&lt;:Superlattice}</code> using an <code>or</code> boolean mask, i.e. with a supercell that contains cells that are either in the supercell of <code>h1</code> or <code>h2</code></p><pre><code class="nohighlight hljs">|(s1::Superlattice, s2::Superlattice}</code></pre><p>Equivalent of the above for <code>Superlattice</code>s</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`&amp;`, `xor`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/hamiltonian.jl#LL1133-L1145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.xor-Tuple{Quantica.Hamiltonian{#s41,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s41&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s40,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s40&lt;:Quantica.Superlattice}" href="#Base.xor-Tuple{Quantica.Hamiltonian{#s41,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s41&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s40,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s40&lt;:Quantica.Superlattice}"><code>Base.xor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">xor(h1::Hamiltonian{&lt;:Superlattice}, h2::Hamiltonian{&lt;:Superlattice})</code></pre><p>Construct a new <code>Hamiltonian{&lt;:Superlattice}</code> using a <code>xor</code> boolean mask, i.e. with a supercell that contains cells that are either in the supercell of <code>h1</code> or <code>h2</code> but not in both</p><pre><code class="nohighlight hljs">xor(s1::Superlattice, s2::Superlattice}</code></pre><p>Equivalent of the above for <code>Superlattice</code>s</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`&amp;`, `|`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/hamiltonian.jl#LL1149-L1162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.DACPdiagonaliser-Tuple{Any,Any,Any}" href="#Quantica.DACPdiagonaliser-Tuple{Any,Any,Any}"><code>Quantica.DACPdiagonaliser</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`DACPdiagonaliser(h::AbstractMatrix{T}, s::AbstractMatrix{T}; threshold = 1e-12)`
solves the GEP problem defined by the hamiltonian matrix `h` and the overlap matrix `s`</code></pre><p>which are built using an overcomplete basis corresponding to a number <code>numkets</code> of Chebyshev evolutions.      It returns the eigendescomposition (eigenvalues and eigenvectors) of the target subspace of a hamiltonian, <code>h</code>. Note that we throw all linear dependencies by means of a rank revealing factorization of the overlap matrices. We select the subspace corresponding to all singular  values up to <code>tolerance = 1e-12</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/DACP.jl#LL383-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.DACPdiagonaliser-Tuple{Quantica.Hamiltonian,Any}" href="#Quantica.DACPdiagonaliser-Tuple{Quantica.Hamiltonian,Any}"><code>Quantica.DACPdiagonaliser</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Diagonaliser, uses the selected codepath method to solve the General Eigenvalue Problem so we are taking care of possible degeneracies.     method = :QZ, performs a Generalized Schur Decomposition (QZ)     method = :default performs ref method SVD     method = :deflatedQZ, performs a QZ with a previous deflation of the subspace (testing...)     method = :twoQR, method with two QR with complete pivoting factorizations (testing...)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/DACP.jl#LL369-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica._chebyshev_loop!-NTuple{5,Any}" href="#Quantica._chebyshev_loop!-NTuple{5,Any}"><code>Quantica._chebyshev_loop!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Chebyshev evolution loop</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/DACP.jl#LL309-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.averageKPM-Tuple{Any,Any}" href="#Quantica.averageKPM-Tuple{Any,Any}"><code>Quantica.averageKPM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">averageKPM(h::Hamiltonian, A; kBT = 0, Ef = 0, kw...)</code></pre><p>Compute, using the Kernel Polynomial Method (KPM), the thermal expectation value <code>⟨A⟩ = Σ_k f(E_k) ⟨k|A|k⟩ = ∫dE f(E) Tr [A δ(E-H)]/N₀ = Tr [A f(H)]/N₀</code> for a given hermitian operator <code>A</code> and a zero-dimensional hamiltonian <code>h</code> with a total of <code>N₀</code> orbitals (see <code>momentaKPM</code> and its options <code>kw</code> for further details). <code>f(E)</code> is the Fermi-Dirac distribution function, <code>|k⟩</code> are <code>h</code> eigenstates with energy <code>E_k</code>, kBT<code>is the temperature in energy units and</code>Ef` the Fermi energy.</p><pre><code class="nohighlight hljs">averageKPM(μ::MomentaKPM, A; kBT = 0, Ef = 0)</code></pre><p>Same as above with the KPM momenta as input (see <code>momentaKPM</code>).</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`dosKPM`, `momentaKPM`, `averageKPM`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/KPM.jl#LL360-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.bands-Tuple{Quantica.Bandstructure}" href="#Quantica.bands-Tuple{Quantica.Bandstructure}"><code>Quantica.bands</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bands(bs::Bandstructure[, i])</code></pre><p>Return a <code>bands::Vector{Band}</code> of all the bands in <code>bs</code>, or <code>bands[i]</code> if <code>i</code> is given.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`bandstructure`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/bandstructure.jl#LL255-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.bandstructure-Tuple" href="#Quantica.bandstructure-Tuple"><code>Quantica.bandstructure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bandstructure(h::Hamiltonian; subticks = 13, kw...)</code></pre><p>Compute <code>bandstructure(h, cuboid((-π,π)...; subticks = subticks); kw...)</code> using a base mesh (of type <code>CuboidMesh</code>) over <code>h</code>&#39;s full Brillouin zone with the specified <code>subticks</code> along each [-π,π] reciprocal axis.</p><pre><code class="nohighlight hljs">bandstructure(h::Hamiltonian, nodes...; subticks = 13, kw...)</code></pre><p>Create a linecut of a bandstructure of <code>h</code> along a polygonal line connecting two or more <code>nodes</code>. Each node is either a <code>Tuple</code> or <code>SVector</code> of Bloch phases, or a symbolic name for a Brillouin zone point (<code>:Γ</code>,<code>:K</code>, <code>:K´</code>, <code>:M</code>, <code>:X</code>, <code>:Y</code> or <code>:Z</code>). Each segment in the polygon has the specified number of <code>subticks</code>. Different <code>subticks</code> per segments can be specified with <code>subticks = (p1, p2...)</code>.</p><pre><code class="nohighlight hljs">bandstructure(h::Hamiltonian, mesh::CuboidMesh; mapping = missing, kw...)</code></pre><p>Compute the bandstructure <code>bandstructure(h, mesh; kw...)</code> of Bloch Hamiltonian <code>bloch(h, ϕ)</code>, with <code>ϕ = v</code> taken on each vertex <code>v</code> of the base <code>mesh</code> (or <code>ϕ = mapping(v...)</code> if a <code>mapping</code> function is provided).</p><pre><code class="nohighlight hljs">bandstructure(ph::ParametricHamiltonian, ...; kw...)</code></pre><p>Compute the bandstructure of a <code>ph</code>. Unless all parameters have default values, a <code>mapping</code> is required between mesh vertices and Bloch/parameters for <code>ph</code>, see details on <code>mapping</code> below.</p><pre><code class="nohighlight hljs">bandstructure(matrixf::Function, mesh::CuboidMesh; kw...)</code></pre><p>Compute the bandstructure of the Hamiltonian matrix <code>m = matrixf(ϕ)</code>, with <code>ϕ</code> evaluated on the vertices <code>v</code> of the <code>mesh</code>. Note that <code>ϕ</code> in <code>matrixf(ϕ)</code> is an unsplatted container. Hence, i.e. <code>matrixf(x) = ...</code> or <code>matrixf(x, y) = ...</code> will not work. Use <code>matrixf((x,)) = ...</code>, <code>matrixf((x, y)) = ...</code> or matrixf(s::SVector) = ...` instead.</p><pre><code class="nohighlight hljs">h |&gt; bandstructure([mesh,]; kw...)</code></pre><p>Curried form of the above equivalent to <code>bandstructure(h[, mesh]; kw...)</code>.</p><p><strong>Options</strong></p><p>The default options are</p><pre><code class="nohighlight hljs">(mapping = missing, method = LinearAlgebraPackage(), transform = missing, splitbands = true, showprogress = true)</code></pre><p><code>mapping</code>: when not <code>missing</code>, <code>mapping = v -&gt; p</code> is a function that map base mesh vertices <code>v</code> to Bloch phases and/or parameters <code>p</code>. The structure of <code>p</code> is whatever is accepted by <code>bloch(h, p, ...)</code> (see <code>bloch</code>). For <code>h::Hamiltonian</code>, <code>p = ϕs::Union{Tuple,SVector}</code> are Bloch phases. For <code>h::ParametricHamiltonian</code>, <code>p = (ϕs..., (; ps))</code> or <code>p = (ϕs, (; ps))</code> combine Bloch phases <code>ϕs</code> and keyword parameters <code>ps</code> of <code>ph</code>. This allows to compute a bandstructure along a cut in the Brillouin zone/parameter space of <code>ph</code>, see examples below.</p><p><code>method</code>: it is chosen automatically if unspecified, and can be one of the following</p><pre><code class="nohighlight hljs">method                     diagonalization function
--------------------------------------------------------------
LinearAlgebraPackage()     LinearAlgebra.eigen!
ArpackPackage()            Arpack.eigs (must be `using Arpack`)</code></pre><p>Options passed to the <code>method</code> will be forwarded to the diagonalization function. For example, <code>method = ArpackPackage(nev = 8, sigma = 1im)</code> will use <code>Arpack.eigs(matrix; nev = 8, sigma = 1im)</code> to compute the bandstructure.</p><p><code>transform</code>: the option <code>transform = ε -&gt; fε(ε)</code> allows to transform eigenvalues by <code>fε</code> in the returned bandstructure (useful for performing shifts or other postprocessing). We can also do <code>transform -&gt; (fφ, fε)</code> to transform also mesh vertices with fφ. Additionally, <code>transform -&gt; isometric</code> or <code>transform -&gt; (isometric, fε)</code> will transform mesh vertices into momenta, assuming they represent Bloch phases. This works both in full bandstructures and linecuts.</p><p><code>splitbands</code>: split all bands into disconnected subbands. See also <code>splitbands!</code></p><p><code>showprogress</code>: indicate whether progress bars are displayed during the calculation</p><p><strong>Indexing</strong></p><p>The bands in a <code>bs::Bandstructure</code> object can be accessed with <code>bands</code>, while the indexing syntax <code>bs[(φs...)]</code> gives access to one or more <code>sub::Subspace</code> objects, contructed by linear interpolation of each band at base-mesh coordinates <code>φs</code>.</p><pre><code class="nohighlight hljs">bs[(φs...), 1]                  : first interpolated subspaces at base mesh coordinates `φs`, ordered by energy
bs[(φs...), 1:3]                : interpolated subspaces 1 to 3 at base mesh coordinates `φs`, ordered by energy
bs[(φs...)]                     : interpolated subspaces at base mesh coordinates `φs` in any band
bs[(φs...), around = 0.2]       : the single interpolated subspaces at `φs` with energies closest to 0.2
bs[(φs...), around = (0.2, 10)] : the ten interpolated subspaces at `φs` with energies closest to 0.2</code></pre><p>The eigenenergy <code>ε</code> and subspace basis <code>ψs</code> of a <code>sub::Subspace</code> can themselves be obtained via destructuring, <code>ε, ψs = sub</code>, or <code>ε = first(sub), ψs = last(sub)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = LatticePresets.honeycomb() |&gt; hamiltonian(hopping(-1)) |&gt; unitcell(3);

julia&gt; bandstructure(h; subticks = 25, method = LinearAlgebraPackage())
Bandstructure{2}: bands of a 2D Hamiltonian
  Bands         : 1
  Vertices      : 9917
  Edges         : 31044
  Simplices     : 20724

julia&gt; bandstructure(h, :Γ, :X, :Y, :Γ; subticks = (10,15,10))
Bandstructure{1}: bands of a 1D Hamiltonian
  Bands         : 1
  Vertices      : 442
  Edges         : 468
  Simplices     : 468

julia&gt; bandstructure(h, cuboid((0, 2π); subticks = 13); mapping = φ -&gt; (φ, 0))
Bandstructure{1}: bands of a 1D Hamiltonian
  Bands         : 1
  Vertices      : 136
  Edges         : 144
  Simplices     : 144

julia&gt; ph = parametric(h, @hopping!((t; α) -&gt; t * α));

julia&gt; bandstructure(ph, cuboid((0, 2π); subticks = 13); mapping = φ -&gt; (φ, 0, (; α = 2φ)))
Bandstructure{1}: bands of a 1D Hamiltonian
  Bands         : 1
  Vertices      : 132
  Edges         : 144
  Simplices     : 144</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`cuboid`, `diagonalizer`, `bloch`, `parametric`, `splitbands!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/bandstructure.jl#LL357-L482">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.basiskets" href="#Quantica.basiskets"><code>Quantica.basiskets</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basiskets(a = I; kw...)</code></pre><p>Create a multicolumn ket model that represents a basis for sites selected by <code>siteselctor(kw...)</code>, with amplitude <code>a</code> on each site. For hamiltonians with <code>N</code> orbitals per site, <code>a</code> will need to be either <code>I</code> or a matrix with <code>N</code> columns. </p><p><code>basiskets(a; kw...)</code> is equivalent to <code>ketmodel(a; singlesitekets = true, kw...)</code>.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`ket`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/KPM.jl#LL33-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.bloch" href="#Quantica.bloch"><code>Quantica.bloch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bloch(h::Hamiltonian{&lt;:Lattice}, ϕs)</code></pre><p>Build the Bloch Hamiltonian matrix of <code>h</code>, for Bloch phases <code>ϕs = (ϕ₁, ϕ₂,...)</code> (or an <code>SVector(ϕs...)</code>). In terms of Bloch wavevector <code>k</code>, <code>ϕs = k * bravais(h)</code>, it is defined as <code>H(ϕs) = ∑exp(-im * ϕs&#39; * dn) h_dn</code> where <code>h_dn</code> are Bloch harmonics connecting unit cells at a distance <code>dR = bravais(h) * dn</code>.</p><pre><code class="nohighlight hljs">bloch(h::Hamiltonian{&lt;:Lattice})</code></pre><p>Build the intra-cell Hamiltonian matrix of <code>h</code>, without adding any Bloch harmonics.</p><pre><code class="nohighlight hljs">bloch(h::Hamiltonian{&lt;:Lattice}, ϕs, axis::Int)</code></pre><p>A nonzero <code>axis</code> produces the derivative of the Bloch matrix respect to <code>ϕs[axis]</code> (i.e. the velocity operator along this axis), <code>∂H(ϕs) = ∑ -im * dn[axis] * exp(-im * ϕs&#39; * dn) h_dn</code></p><pre><code class="nohighlight hljs">bloch(h::Hamiltonian{&lt;:Lattice}, ϕs::NTuple{L,Real}, dnfunc::Function)</code></pre><p>Generalization that applies a prefactor <code>dnfunc(dn) * exp(im * ϕs&#39; * dn)</code> to the <code>dn</code> harmonic.</p><pre><code class="nohighlight hljs">bloch(ph::ParametricHamiltonian, [pϕs, [axis]])</code></pre><p>Build the Bloch matrix for <code>ph</code>. <code>pϕs = (ϕs, (;kw...))</code> or <code>pϕs = (ϕs..., (;kw...))</code> specifies both Bloch phases <code>ϕs</code> and the parameters <code>kw</code> passed to <code>ph(; kw...)</code>. If there are no <code>ϕs</code>, the syntax <code>pϕs = (;kw...)</code> is also allowed, which is in that case equivalent to <code>bloch(ph(; kw...))</code>. Similarly, <code>bloch(ph)</code> is equivalent to <code>bloch(ph())</code>.</p><pre><code class="nohighlight hljs">h |&gt; bloch(ϕs, ...)
ph |&gt; bloch(pϕs, ...)</code></pre><p>Curried forms of <code>bloch</code>, equivalent to <code>bloch(h, ϕs, ...)</code> and <code>bloch(ph, pϕs, ...)</code></p><p><strong>Notes</strong></p><p><code>bloch</code> allocates a new matrix on each call. For a non-allocating version of <code>bloch</code>, see <code>bloch!</code>.</p><p><code>bloch</code> also supports slices of <code>Hamiltonians</code> and <code>ParametricHamiltonians</code>, produced with <code>h[rows, cols]</code>, see the indexing section of <code>hamiltonian</code> and  <code>parametric</code> for details.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = LatticePresets.honeycomb() |&gt; hamiltonian(onsite(1) + hopping(2)) |&gt; bloch((0, 0))
2×2 SparseMatrixCSC{Complex{Float64},Int64} with 4 stored entries:
  [1, 1]  =  1.0+0.0im
  [2, 1]  =  6.0+0.0im
  [1, 2]  =  6.0+0.0im
  [2, 2]  =  1.0+0.0im</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`bloch!`, `similarmatrix`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/hamiltonian.jl#LL1682-L1737">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.bloch!" href="#Quantica.bloch!"><code>Quantica.bloch!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bloch!(matrix, h::Hamiltonian, [ϕs, [axis]])</code></pre><p>In-place version of <code>bloch</code>. Overwrite <code>matrix</code> with the Bloch Hamiltonian matrix of <code>h</code> for the specified Bloch phases <code>ϕs = (ϕ₁,ϕ₂,...)</code> (see <code>bloch</code> for definition and API). A conventient way to obtain a <code>matrix</code> is to use <code>similarmatrix(h,matrix_type)</code>, which will return an <code>AbstractMatrix</code> of the same type as the Hamiltonian&#39;s. Note, however, that matrix need not be of the same type (e.g. it can be dense with <code>Number</code> eltype for a sparse <code>h</code> with <code>SMatrix</code> block eltype).</p><pre><code class="nohighlight hljs">bloch!(matrix, ph::ParametricHamiltonian, [pϕs, [axis]])</code></pre><p>Same as above but with <code>pϕs = (ϕs, (;kw...))</code>, <code>pϕs = (ϕs..., (;kw...))</code> or <code>pϕs = (;kw...)</code> (see <code>bloch</code> for details).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = LatticePresets.honeycomb() |&gt; hamiltonian(hopping(2I), orbitals = (Val(2), Val(1)));

julia&gt; bloch!(similarmatrix(h), h, (0, 0))
2×2 SparseMatrixCSC{SMatrix{2, 2, ComplexF64, 4}, Int64} with 2 stored entries:
                     ⋅                       [6.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]
 [6.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]                      ⋅                     

julia&gt; bloch!(similarmatrix(h, flatten), h, (0, 0))
3×3 SparseMatrixCSC{ComplexF64, Int64} with 9 stored entries:
 0.0+0.0im  0.0+0.0im  6.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 6.0+0.0im  0.0+0.0im  0.0+0.0im

julia&gt; ph = parametric(h, @hopping!((t; α, β = 0) -&gt; α * t .+ β));

julia&gt; bloch!(similarmatrix(ph, flatten), ph, (0, 0, (; α = 2)))
3×3 SparseMatrixCSC{ComplexF64, Int64} with 9 stored entries:
  0.0+0.0im  0.0+0.0im  12.0+0.0im
  0.0+0.0im  0.0+0.0im   0.0+0.0im
 12.0+0.0im  0.0+0.0im   0.0+0.0im</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`bloch`, `similarmatrix`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/hamiltonian.jl#LL1741-L1783">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.bravais-Tuple{Quantica.AbstractLattice}" href="#Quantica.bravais-Tuple{Quantica.AbstractLattice}"><code>Quantica.bravais</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bravais(lat::Lattice)
bravais(h::Hamiltonian)</code></pre><p>Obtain the Bravais matrix of lattice <code>lat</code> or Hamiltonian <code>h</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; lat = lattice(sublat((0,0)), bravais = ((1.0, 2), (3, 4)));

julia&gt; bravais(lat)
2×2 SMatrix{2, 2, Float64, 4} with indices SOneTo(2)×SOneTo(2):
 1.0  3.0
 2.0  4.0</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`lattice`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/lattice.jl#LL153-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.chebyshev_filter" href="#Quantica.chebyshev_filter"><code>Quantica.chebyshev_filter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">`chebyshev!(b::DACPbuilder)`</code></pre><p>computes the action of a <code>K</code>&#39;th order Chebyshev polynomial T<em>nk(𝔽) on a random ket <code>b.ψ0</code>.  𝔽 = (ℍ^2 - Ec)/E0 is the operator that maps the spectral window (<code>a</code>², <code>Emax</code>²) of ℍ^2 into the interval x ∈ (-1, 1) where the T</em>nk(x) is cosine like. As a result of this  transformation, the ket components in the (0, <code>a</code>²) interval of ℍ² will be exponentially amplified.      -&gt; Iterate over kets to increase performance eps != 0 adds performs the exponential filtering in a slighlty larger interval (this is to avoid subsampling at the edges of the spectrum) - desabled</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/DACP.jl#LL110-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.combine-Tuple{Vararg{Quantica.Hamiltonian,N} where N}" href="#Quantica.combine-Tuple{Vararg{Quantica.Hamiltonian,N} where N}"><code>Quantica.combine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">combine(hams::Hamiltonian...; coupling = missing)</code></pre><p>Build a new Hamiltonian <code>h</code> that combines all <code>hams</code> as diagonal blocks, and applies <code>coupling::Model</code>, if provided, to build the off-diagonal couplings. Note that the diagonal blocks are not modified by the coupling model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/hamiltonian.jl#LL1658-L1664">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.combine-Tuple{Vararg{Quantica.Lattice,N} where N}" href="#Quantica.combine-Tuple{Vararg{Quantica.Lattice,N} where N}"><code>Quantica.combine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">combine(lats::Lattice...)</code></pre><p>If all <code>lats</code> have compatible Bravais vectors, combine them into a single lattice. Sublattice names are renamed to be unique if necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/lattice.jl#LL504-L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.cuboid-Union{Tuple{Vararg{Tuple,L}}, Tuple{L}} where L" href="#Quantica.cuboid-Union{Tuple{Vararg{Tuple,L}}, Tuple{L}} where L"><code>Quantica.cuboid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cuboid(ticks...; subticks = 13)</code></pre><p>Create a <code>CuboidMesh</code> of L-dimensional marching-tetrahedra over a cuboid aligned with the Cartesian axes. The dimension <code>L</code> is given by the number of <code>ticks</code>, each of the form <code>(x₁, x₂,...)</code>. The interval between <code>xⱼ</code> and <code>xⱼ₊₁</code> ticks in axis <code>i</code> are further subdivided to have a number of subticks including endpoints. The number is <code>subticks</code> if <code>subticks</code> is an <code>Integer</code>, <code>subticks[i]</code> if <code>subticks = (s₁, s₂,...)</code> or <code>subticks[i][j]</code> if <code>subticks = ((s₁₁, s₁₂,...), (s₂₁, s₂₂,...), ...)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cuboid((-π, π), (0, 2π); subticks = 25)
CuboidMesh{2}: a mesh of a 2D parameter cuboid
  Ranges     : ((-3.141592653589793, 3.141592653589793), (0.0, 6.283185307179586))
  Axes ticks : (25, 25)
  Simplices  : (24, 24, 2) -&gt; 1152

julia&gt; cuboid((-π, π), (0, 2π); subticks = (10, 10))
CuboidMesh{2}: a mesh of a 2D parameter cuboid
  Ranges     : ((-3.141592653589793, 3.141592653589793), (0.0, 6.283185307179586))
  Axes ticks : (10, 10)
  Simplices  : (9, 9, 2) -&gt; 162</code></pre><p><strong>External links</strong></p><ul><li>Marching tetrahedra (https://en.wikipedia.org/wiki/Marching_tetrahedra) in Wikipedia</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/mesh.jl#LL18-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.deflate-Tuple{Any,Any,Any}" href="#Quantica.deflate-Tuple{Any,Any,Any}"><code>Quantica.deflate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>deflation procedure using two (Householder) QR factorisations with complete pivoting</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/DACP.jl#LL455-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.degeneracy-Tuple{Quantica.Subspace}" href="#Quantica.degeneracy-Tuple{Quantica.Subspace}"><code>Quantica.degeneracy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">degeneracy(s::Subspace)</code></pre><p>Return the degeneracy of a given energy subspace. It is equal to <code>size(s.basis, 2)</code>.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`spectrum`, `bandstructure`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/bandstructure.jl#LL28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.densityKPM-Tuple{Any,Any}" href="#Quantica.densityKPM-Tuple{Any,Any}"><code>Quantica.densityKPM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">densityKPM(h::Hamiltonian, A; resolution = 2, ket = randomkets(1), kw...)</code></pre><p>Compute, using the Kernel Polynomial Method (KPM), the spectral density of <code>A</code>, <code>ρᴬₖ(ϵ) = ⟨k|A δ(ϵ-h)|k⟩</code> for a ket <code>|k⟩ = ket(ket::KetModel, h)</code> or <code>|k⟩ = ket::Ket</code> (depending on the type of <code>ket</code>). The result is a tuple of energy points <code>ϵᵢ::Vector</code> spanning the band range, and real <code>ρᴬₖ(ϵᵢ)::Vector</code> values. The number of energy points <code>ϵᵢ</code> is <code>order * resolution</code>, rounded to the closest integer.</p><p>If <code>ket</code> is a collection of <code>KetModel</code>s, the sum <code>∑ₖρᴬₖ(ε)</code> over all models will be computed. In the case of the default <code>ket = randomkets(n)</code>, this results in an estimate of the average spectral density per orbital, computed through an stochastic trace, <code>ρᴬ(ϵ) = ∑ₖ⟨k|δ(ϵ-h)A|k⟩/n ≈ Tr[δ(ϵ-h)A]/N₀</code>, where <code>N₀</code> is the total number of orbitals in the unit cell.</p><pre><code class="nohighlight hljs">densityKPM(μ::MomentaKPM; resolution = 2)</code></pre><p>Same as above with KPM momenta <code>μ</code> as input.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`dosKPM`, `momentaKPM`, `averageKPM`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/KPM.jl#LL322-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.diagonalizer-Tuple{Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian}}" href="#Quantica.diagonalizer-Tuple{Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian}}"><code>Quantica.diagonalizer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diagonalizer(h::Union{Hamiltonian,ParametricHamiltonian}; method = LinearAlgebraPackage(), mapping = missing)</code></pre><p>Build a <code>d::Diagonalizer</code> object that, when called as <code>d(φs)</code> , uses the specified diagonalization <code>method</code> to produce the sorted eigenpairs <code>(εs, ψs)</code> of <code>h</code> at Bloch phases/parameters given by <code>mapping</code>. See <code>bandstructure</code> for further details.</p><p>A 0D Hamiltonian <code>h</code> also supports <code>d = diagonalizer(h)</code>. In this case <code>d</code> can be called with no arguments and gives the same information as <code>spectrum</code>, <code>d() ≈ Tuple(spectrum(h))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = LatticePresets.honeycomb() |&gt; hamiltonian(hopping(1));

julia&gt; d = diagonalizer(h)
Diagonalizer with method : LinearAlgebraPackage{NamedTuple{(), Tuple{}}}

julia&gt; d((0, 0)) |&gt; first
2-element Vector{Float64}:
 -3.0
  3.0

julia&gt; h = wrap(h); d = diagonalizer(h);

julia&gt; d() .≈ Tuple(spectrum(h))
(true, true)</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`bandstructure`, `spectrum`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/diagonalizer.jl#LL25-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.dims-Union{Tuple{Quantica.AbstractLattice{E,L,T} where T}, Tuple{L}, Tuple{E}} where L where E" href="#Quantica.dims-Union{Tuple{Quantica.AbstractLattice{E,L,T} where T}, Tuple{L}, Tuple{E}} where L where E"><code>Quantica.dims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dims(lh::Union{Hamiltonian,AbstractLattice}) -&gt; (E, L)</code></pre><p>Return a tuple <code>(E, L)</code> of the embedding <code>E</code> and lattice dimensions <code>L</code> of <code>AbstractLattice</code> or <code>Hamiltonian</code> <code>lh</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/hamiltonian.jl#LL824-L829">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.dosKPM-Tuple{Any}" href="#Quantica.dosKPM-Tuple{Any}"><code>Quantica.dosKPM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dosKPM(h::Hamiltonian; resolution = 2, ket = randomkets(1), kw...)</code></pre><p>Compute, using the Kernel Polynomial Method (KPM), the local density of states <code>ρₖ(ϵ) = ⟨k|δ(ϵ-h)|k⟩</code> for a ket <code>|k⟩ = ket(ket::KetModel, h)</code> or <code>|k⟩ = ket::Ket</code> (depending on the type of <code>ket</code>). The result is a tuple of energy points <code>ϵᵢ::Vector</code> spanning the band range, and real <code>ρₖ(ϵᵢ)::Vector</code> values (any residual imaginary part in <code>ρₖ</code> is dropped). The number of energy points <code>ϵᵢ</code> is <code>order * resolution</code>, rounded to the closest integer.</p><p>If <code>ket</code> is a collection of <code>KetModel</code>s, the sum <code>∑ₖρₖ(ε)</code> over all models will be computed. In the case of the default <code>ket = randomkets(n)</code>, this results in an estimate of the total density of states per orbital, computed through an stochastic trace, <code>ρ(ϵ) = ∑ₖ⟨k|δ(ϵ-h)|k⟩/n ≈ Tr[δ(ϵ-h)]/N₀</code>, where <code>N₀</code> is the total number of orbitals in the unit cell.</p><p><code>dosKPM</code> is a particular case of <code>densityKPM</code> for an operator <code>A = I</code> and with any residual imaginary parts dropped</p><pre><code class="nohighlight hljs">dosKPM(μ::MomentaKPM; resolution = 2)</code></pre><p>Same as above with KPM momenta <code>μ</code> as input.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`momentaKPM`, `densityKPM`, `averageKPM`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/KPM.jl#LL292-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.flatten-Tuple{}" href="#Quantica.flatten-Tuple{}"><code>Quantica.flatten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flatten(h::Hamiltonian)</code></pre><p>Flatten a multiorbital Hamiltonian <code>h</code> into one with a single orbital per site. The associated lattice is flattened also, so that there is one site per orbital for each initial site (all at the same position). Note that in the case of sparse Hamiltonians, zeros in hopping/onsite matrices are preserved as structural zeros upon flattening.</p><pre><code class="nohighlight hljs">flatten(k::Ket)</code></pre><p>Flattens a multiorbital <code>Ket</code> to have a scalar <code>eltype</code>, instead of <code>SVector</code>.</p><pre><code class="nohighlight hljs">flatten(s::Subspace)</code></pre><p>Rebuild <code>s</code> by flattening its basis to have a scalar eltype.</p><pre><code class="nohighlight hljs">x |&gt; flatten()</code></pre><p>Curried form equivalent to <code>flatten(x)</code> or <code>x |&gt; flatten</code> (included for consistency with the rest of the API).</p><pre><code class="nohighlight hljs">flatten(x, o::OrbitalStructure)</code></pre><p>Flatten object x, if applicable, using the orbital structure <code>o</code>, as obtained from a Hamiltonian <code>h</code> with <code>orbitalstructure(h)</code>. <code>x</code> here is typically an <code>AbstractArray</code> of non-scalar <code>eltype</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = LatticePresets.honeycomb() |&gt;
           hamiltonian(hopping(@SMatrix[1; 2], range = 1/√3, sublats = :A =&gt;:B),
           orbitals = (Val(1), Val(2)))
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)
  Harmonic size    : 2 × 2
  Orbitals         : ((:a,), (:a, :a))
  Element type     : 2 × 2 blocks (Complex{Float64})
  Onsites          : 0
  Hoppings         : 3
  Coordination     : 1.5

julia&gt; flatten(h)
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)
  Harmonic size    : 3 × 3
  Orbitals         : ((:flat,), (:flat,))
  Element type     : scalar (Complex{Float64})
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 2.0</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`unflatten`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/hamiltonian.jl#LL153-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.gap-Tuple{Quantica.Bandstructure{1,C,T,B,M} where M&lt;:Quantica.Diagonalizer where B&lt;:(Quantica.Band{1,C,T,S,S´,D´} where D´ where S´&lt;:(AbstractArray{T,2} where T) where S&lt;:AbstractArray{C,2}) where T where C,Any}" href="#Quantica.gap-Tuple{Quantica.Bandstructure{1,C,T,B,M} where M&lt;:Quantica.Diagonalizer where B&lt;:(Quantica.Band{1,C,T,S,S´,D´} where D´ where S´&lt;:(AbstractArray{T,2} where T) where S&lt;:AbstractArray{C,2}) where T where C,Any}"><code>Quantica.gap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gap(b::Bandstructure{1}, ε₀; refinesteps = 0)</code></pre><p>Compute the gap if a 1D bandstructure <code>b</code> around ε₀, if any.</p><p><strong>See also:</strong></p><pre><code class="nohighlight hljs">`gapedge`, `minima`, `maxima`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/bandstructure.jl#LL1085-L1092">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.gapedge-Tuple{Quantica.Bandstructure{1,C,T,B,M} where M&lt;:Quantica.Diagonalizer where B&lt;:(Quantica.Band{1,C,T,S,S´,D´} where D´ where S´&lt;:(AbstractArray{T,2} where T) where S&lt;:AbstractArray{C,2}) where T where C,Any}" href="#Quantica.gapedge-Tuple{Quantica.Bandstructure{1,C,T,B,M} where M&lt;:Quantica.Diagonalizer where B&lt;:(Quantica.Band{1,C,T,S,S´,D´} where D´ where S´&lt;:(AbstractArray{T,2} where T) where S&lt;:AbstractArray{C,2}) where T where C,Any}"><code>Quantica.gapedge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gapedge(b::Bandstructure{1}, ε₀; refinesteps = 0)</code></pre><p>For a 1D bandstructure <code>b</code>, compute two tuples, <code>(φ₊, ε₊)</code> and <code>(φ₋, ε₋)</code>, of band points closest in energy to <code>ε₀</code>, from above and below, respectively. If ε₀ is inside a band or outside the global bandwidth, <code>φ₊</code> and <code>φ₋</code> will be <code>missing</code>. See <code>minima</code> or <code>maxima</code> for details about <code>refinesteps</code>.</p><pre><code class="nohighlight hljs">gapedge(b::Bandstructure{1}, ε₀, +; kw...)
gapedge(b::Bandstructure{1}, ε₀, -; kw...)</code></pre><p>Compute only <code>(φ₊, ε₊)</code> or <code>(φ₋, ε₋)</code>, respectively.</p><p><strong>See also:</strong></p><pre><code class="nohighlight hljs">`gap`, `minima`, `maxima`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/bandstructure.jl#LL1039-L1054">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.greens-Union{Tuple{L}, Tuple{Quantica.Hamiltonian{#s39,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where #s39,Any}} where L" href="#Quantica.greens-Union{Tuple{L}, Tuple{Quantica.Hamiltonian{#s39,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where #s39,Any}} where L"><code>Quantica.greens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">greens(h::Hamiltonian, solveobject; boundaries::NTuple{L,Integer} = missing)</code></pre><p>Construct the Green&#39;s function <code>g::GreensFunction</code> of <code>L</code>-dimensional Hamiltonian <code>h</code> using the provided <code>solveobject</code>. Currently valid <code>solveobject</code>s are</p><ul><li><code>Schur1D()</code> (single-shot generalized eigenvalue approach for 1D Hamiltonians)</li></ul><p>If a <code>boundaries = (n₁, n₂, ...)</code> is provided, a reflecting boundary is assumed for each non-missing <code>nᵢ</code> perpendicular to Bravais vector <code>i</code> at a cell distance <code>nᵢ</code> from the origin.</p><pre><code class="nohighlight hljs">h |&gt; greens(h -&gt; solveobject(h), args...)</code></pre><p>Curried form equivalent to the above, giving <code>greens(h, solveobject(h), args...)</code>.</p><pre><code class="nohighlight hljs">g(ω, cells::Pair)
g(ω)[cells::Pair]</code></pre><p>From a constructed <code>g::GreensFunction</code>, obtain the retarded Green&#39;s function matrix at frequency <code>ω</code> between unit cells <code>src</code> and <code>dst</code>, where <code>src, dst</code> are <code>::NTuple{L,Int}</code> or <code>SVector{L,Int}</code>. If allowed by the used <code>solveobject</code>, <code>g0=g(ω)</code> builds an solution object that can efficiently produce the Greens function between different cells at fixed <code>ω</code> with <code>g0[cells]</code> without repeating cell-independent parts of the computation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = LatticePresets.square() |&gt; hamiltonian(hopping(-1)) |&gt; unitcell((1,0), region = r-&gt;0&lt;r[2]&lt;3) |&gt; greens(Schur1D())
GreensFunction{Schur1DGreensSolver}: Green&#39;s function using the Schur1D method
  Flat matrix size      : 2 × 2
  Flat deflated size    : 2 × 2
  Original element type : scalar (ComplexF64)
  Boundaries            : (missing,)

julia&gt; g(0.2, 3=&gt;2) ≈ g(0.2)[3=&gt;2]
true</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`Schur1D`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/greens.jl#LL12-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.hamiltonian-Tuple{Quantica.AbstractLattice,Vararg{Any,N} where N}" href="#Quantica.hamiltonian-Tuple{Quantica.AbstractLattice,Vararg{Any,N} where N}"><code>Quantica.hamiltonian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hamiltonian(lat, model; orbitals, orbtype)</code></pre><p>Create a <code>Hamiltonian</code> by applying <code>model::TighbindingModel</code> to the lattice <code>lat</code> (see <code>hopping</code> and <code>onsite</code> for details on building tightbinding models).</p><pre><code class="nohighlight hljs">lat |&gt; hamiltonian(model; kw...)</code></pre><p>Curried form of <code>hamiltonian</code> equivalent to <code>hamiltonian(lat, model; kw...)</code>.</p><p><strong>Keywords</strong></p><p>The number of orbitals on each sublattice can be specified by the keyword <code>orbitals</code> (otherwise all sublattices have one orbital by default). The following, and obvious combinations, are possible formats for the <code>orbitals</code> keyword:</p><pre><code class="nohighlight hljs">orbitals = :a                # all sublattices have 1 orbital named :a
orbitals = (:a,)             # same as above
orbitals = (:a, :b, 3)       # all sublattices have 3 orbitals named :a and :b and :3
orbitals = ((:a, :b), (:c,)) # first sublattice has 2 orbitals, second has one
orbitals = ((:a, :b), :c)    # same as above
orbitals = (Val(2), Val(1))  # same as above, with automatic names
orbitals = (:A =&gt; (:a, :b), :D =&gt; :c) # sublattice :A has two orbitals, :D and rest have one
orbitals = :D =&gt; Val(4)      # sublattice :D has four orbitals, rest have one</code></pre><p>The matrix sizes of tightbinding <code>model</code> must match the orbitals specified. Internally, we define a block size <code>N = max(num_orbitals)</code>. If <code>N = 1</code> (all sublattices with one orbital) the Hamiltonian element type is <code>orbtype</code>. Otherwise it is <code>SMatrix{N,N,orbtype}</code> blocks, padded with the necessary zeros as required. Keyword <code>orbtype</code> is <code>Complex{T}</code> by default, where <code>T</code> is the number type of <code>lat</code>.</p><p><strong>Indexing</strong></p><p>Indexing into a Hamiltonian <code>h</code> works as follows. Access the <code>HamiltonianHarmonic</code> matrix at a given <code>dn::NTuple{L,Int}</code> with <code>h[dn]</code>. The special <code>h[]</code> syntax stands for <code>h[(0...)]</code> for the zero-harmonic. Assign <code>v</code> into element <code>(i,j)</code> of said matrix with <code>h[dn][i,j] = v</code>. Broadcasting with vectors of indices <code>is</code> and <code>js</code> is supported, <code>h[dn][is, js] = v_matrix</code>.</p><p>A slicing syntax <code>h[rows, cols]</code> (without specifying <code>dn</code>) is also available, that creates a special <code>hs::Slice{&lt;:Hamiltonian}</code> object that represents a slice of the Hamiltonian matrix restricted to <code>rows</code> and <code>cols</code>. Here, <code>rows</code> and <code>cols</code> are collections of site indices, or alternatively <code>SiteSelector</code>s (see <code>siteselector</code>s for details). If <code>rows::Integer</code> or <code>cols::Integer</code>, they will be converted to a single-element range (to preserve always a matrix-like slice, unlike for <code>AbstractArray</code> indexing). Slices support <code>bloch</code> and <code>bloch!</code> to produce the corresponding matrices, and can also be indexed as <code>hs[dn::Tuple]</code> that produces the equivalent to <code>h[dn][rows, cols]</code>.</p><p>To add an empty harmonic with a given <code>dn::NTuple{L,Int}</code>, do <code>push!(h, dn)</code>. To delete it, do <code>deleteat!(h, dn)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = hamiltonian(LatticePresets.honeycomb(), hopping(@SMatrix[1 2; 3 4], range = 1/√3), orbitals = Val(2))
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)
  Harmonic size    : 2 × 2
  Orbitals         : ((:a, :a), (:a, :a))
  Element type     : 2 × 2 blocks (ComplexF64)
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 3.0

julia&gt; push!(h, (3,3)) # Adding a new Hamiltonian harmonic (if not already present)
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 6 (SparseMatrixCSC, sparse)
  Harmonic size    : 2 × 2
  Orbitals         : ((:a, :a), (:a, :a))
  Element type     : 2 × 2 blocks (ComplexF64)
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 3.0

julia&gt; h[(3,3)][1,1] = @SMatrix[1 2; 2 1]; h[(3,3)] # element assignment
2×2 SparseMatrixCSC{SMatrix{2, 2, ComplexF64, 4}, Int64} with 1 stored entry:
 [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]                      ⋅                     
                     ⋅                                           ⋅                     

julia&gt; h[(3,3)][[1,2],[1,2]] .= Ref(@SMatrix[1 2; 2 1])
2×2 SparseMatrixCSC{SMatrix{2, 2, ComplexF64, 4}, Int64} with 4 stored entries:
 [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]
 [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]

 julia&gt; h = unitcell(h); h[]
2×2 SparseMatrixCSC{SMatrix{2, 2, ComplexF64, 4}, Int64} with 2 stored entries:
                     ⋅                       [1.0+0.0im 2.0+0.0im; 3.0+0.0im 4.0+0.0im]
 [1.0+0.0im 2.0+0.0im; 3.0+0.0im 4.0+0.0im]                      ⋅                     
</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`onsite`, `hopping`, `bloch`, `bloch!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/hamiltonian.jl#LL679-L771">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.hopping-Tuple{Any}" href="#Quantica.hopping-Tuple{Any}"><code>Quantica.hopping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hopping(t; range = nrange(1), dn = missing, sublats = missing, indices = missing, region = missing, plusadjoint = false)</code></pre><p>Create an <code>TightbindingModel</code> with a single <code>HoppingTerm</code> that applies a hopping <code>t</code> to a <code>Lattice</code> when creating a <code>Hamiltonian</code> with <code>hamiltonian</code>.</p><p>The hopping amplitude <code>t</code> can be a number, an <code>SMatrix</code>, a <code>UniformScaling</code> (e.g. <code>3*I</code>) or a function of the form <code>(r, dr) -&gt; ...</code> for a position-dependent hopping (<code>r</code> is the bond center, and <code>dr</code> the bond vector). If <code>sublats</code> is specified as a sublattice name pair, or tuple thereof, <code>hopping</code> is only applied between sublattices with said names.</p><p>The dimension of <code>t::AbstractMatrix</code> must match the orbital dimension of applicable sublattices (see also <code>orbitals</code> option for <code>hamiltonian</code>). If <code>t::UniformScaling</code> it will be converted to a (possibly rectangular) identity matrix of the appropriate size when applied to multiorbital sublattices. Similarly, if <code>t::SMatrix</code> it will be truncated or padded to the appropriate size.</p><p><code>OnsiteTerm</code>s and <code>HoppingTerm</code>s created with <code>onsite</code> or <code>hopping</code> can be added or substracted together to build more complicated <code>TightbindingModel</code>s.</p><pre><code class="nohighlight hljs">hopping(model::TightbindingModel; kw...)</code></pre><p>Return a <code>TightbindingModel</code> with only the hopping terms of <code>model</code>. Any non-missing <code>kw</code> is applied to all such terms.</p><p><strong>Keyword arguments</strong></p><p>Most keywords are the same as for <code>hopselector</code>. Only hoppings between two sites at positions <code>r₁ = r - dr/2</code> and <code>r₂ = r + dr</code>, belonging to unit cells at integer distance <code>dn´</code> and to sublattices <code>s₁</code> and <code>s₂</code> will be selected if: <code>region(r, dr) &amp;&amp; s in sublats &amp;&amp; dn´ in dn &amp;&amp; norm(dr) &lt;= range</code>. If any of these is <code>missing</code> it will not be used to constraint the selection.</p><p>The keyword <code>range</code> admits the following possibilities</p><pre><code class="nohighlight hljs">max_range                   # i.e. `norm(dr) &lt;= max_range`
(min_range, max_range)      # i.e. `min_range &lt;= norm(dr) &lt;= max_range`</code></pre><p>Both <code>max_range</code> and <code>min_range</code> can be a <code>Real</code> or a <code>NeighborRange</code> created with <code>nrange(n)</code>. The latter represents the distance of <code>n</code>-th nearest neighbors. Note that the <code>range</code> default for <code>hopping</code> (unlike for the more general <code>hopselector</code>) is <code>nrange(1)</code>, i.e. first-nearest-neighbors.</p><p>The keyword <code>dn</code> can be a <code>Tuple</code>/<code>Vector</code>/<code>SVector</code> of <code>Int</code>s, or a tuple thereof. The keyword <code>sublats</code> allows the following formats:</p><pre><code class="nohighlight hljs">sublats = :A =&gt; :B                 # Hopping from :A to :B sublattices
sublats = (:A =&gt; :B,)              # Same as above
sublats = (:A =&gt; :B, :C =&gt; :D)     # Hopping from :A to :B or :C to :D
sublats = (:A, :C) .=&gt; (:B, :D)    # Broadcasted pairs, same as above
sublats = (:A, :C) =&gt; (:B, :D)     # Direct product, (:A=&gt;:B, :A=:D, :C=&gt;:B, :C=&gt;D)</code></pre><p>The keyword <code>plusadjoint</code> produces a model with the input hopping term plus its adjoint. Note that this substitution is made before multiplying by any coefficient, so that <code>im*hopping(..., plusadjoint = true) == im*(hopping(...) + hopping(...)&#39;)</code>.</p><p><strong>Combining models</strong></p><p><code>OnsiteTerm</code>s and <code>HoppingTerm</code>s created with <code>onsite</code> or <code>hopping</code> can added or substracted together or be multiplied by scalars to build more complicated <code>TightbindingModel</code>s, e.g. <code>onsite(1) - 3 * hopping(2)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = 3 * onsite(1) - hopping(2, dn = ((1,2), (0,0)), sublats = :A=&gt;:B)
TightbindingModel{2}: model with 2 terms
  OnsiteTerm{Int64}:
    Sublattices      : any
    Coefficient      : 3
  HoppingTerm{Int64}:
    Sublattice pairs : :A =&gt; :B
    dn cell distance : ([1, 2], [0, 0])
    Hopping range    : NeighborRange(1)
    Coefficient      : -1

julia&gt; newmodel = onsite(model) + hopping(model, range = 2)
TightbindingModel{2}: model with 2 terms
  OnsiteTerm{Int64}:
    Sublattices      : any
    Coefficient      : 3
  HoppingTerm{Int64}:
    Sublattice pairs : :A =&gt; :B
    dn cell distance : ([1, 2], [0, 0])
    Hopping range    : 2.0
    Coefficient      : -1

julia&gt; LatticePresets.honeycomb() |&gt; hamiltonian(hopping((r,dr) -&gt; cos(r[1]), sublats = (:A,:B) =&gt; (:A,:B)))
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)
  Harmonic size    : 2 × 2
  Orbitals         : ((:a,), (:a,))
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 3.0</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`onsite`, `nrange`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/model.jl#LL641-L741">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.hopselector-Tuple{}" href="#Quantica.hopselector-Tuple{}"><code>Quantica.hopselector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hopselector(; range = missing, dn = missing, sublats = missing, indices = missing, region = missing)</code></pre><p>Return a <code>HopSelector</code> object that can be used to select hops between two sites in a lattice. Only hops between two sites, with indices <code>ipair = src =&gt; dst</code>, at positions <code>r₁ = r - dr/2</code> and <code>r₂ = r + dr</code>, belonging to unit cells at integer distance <code>dn´</code> and to sublattices <code>s₁</code> and <code>s₂</code> will be selected if:</p><pre><code class="nohighlight hljs">`region(r, dr) &amp;&amp; s in sublats &amp;&amp; dn´ in dn &amp;&amp; norm(dr) &lt;= range &amp;&amp; ipair in indices`</code></pre><p>If any of these is <code>missing</code> it will not be used to constraint the selection.</p><p>The keyword <code>range</code> admits the following possibilities</p><pre><code class="nohighlight hljs">max_range                   # i.e. `norm(dr) &lt;= max_range`
(min_range, max_range)      # i.e. `min_range &lt;= norm(dr) &lt;= max_range`</code></pre><p>Both <code>max_range</code> and <code>min_range</code> can be a <code>Real</code> or a <code>NeighborRange</code> created with <code>nrange(n)</code>. The latter represents the distance of <code>n</code>-th nearest neighbors.</p><p>The keyword <code>dn</code> can be a <code>Tuple</code>/<code>Vector</code>/<code>SVector</code> of <code>Int</code>s, or a tuple thereof.</p><p>The keyword <code>sublats</code> allows the following formats:</p><pre><code class="nohighlight hljs">sublats = :A =&gt; :B                  # Hopping from :A to :B sublattices, but not from :B to :A
sublats = (:A =&gt; :B,)               # Same as above
sublats = (:A =&gt; :B, :C =&gt; :D)      # Hopping from :A to :B or :C to :D
sublats = (:A, :C) .=&gt; (:B, :D)     # Broadcasted pairs, same as above
sublats = (:A, :C) =&gt; (:B, :D)      # Direct product, (:A=&gt;:B, :A=:D, :C=&gt;:B, :C=&gt;D)</code></pre><p>The keyword <code>indices</code> accepts a single <code>src =&gt; dest</code> pair or a collection thereof. Any <code>src == dest</code> will be neglected. Possible combinations:</p><pre><code class="nohighlight hljs">indices = 1 =&gt; 2                    # Hopping from site 1 to 2, but not from 2 to 1
indices = (1 =&gt; 2, 2 =&gt; 1)          # Hoppings from 1 to 2 or from 2 to 1
indices = [1 =&gt; 2, 2 =&gt; 1]          # Same as above
indices = [(1, 2) .=&gt; (2, 1)]       # Broadcasted pairs, same as above
indices = [1:10 =&gt; 20:25, 3 =&gt; 30]  # Direct product, any hopping from sites 1:10 to sites 20:25, or from 3 to 30</code></pre><p>Additionally, indices or sublattices can be wrapped in <code>not</code> to exclude them (see <code>not</code>):</p><pre><code class="nohighlight hljs">sublats = not(:A =&gt; :B, :B =&gt; :A)   # Any sublat pairs different from :A =&gt; :B or :B =&gt; :A
sublats = not(:A) =&gt; :B             # Any sublat pair s1 =&gt; s2 with s1 different from :A and s2 equal to :B
indices = not(8 =&gt; 9)               # Any site indices different from 8 =&gt; 9
indices = 1 =&gt; not(3:4)             # Any site pair 1 =&gt; s with s different from 3, 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/model.jl#LL161-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.ijselector-NTuple{4,Any}" href="#Quantica.ijselector-NTuple{4,Any}"><code>Quantica.ijselector</code></a> — <span class="docstring-category">Method</span></header><section><div><p>aux<em>vec is organized s.t. {1, Tk</em>1-2, Tk<em>1-1, Tk</em>1, Tk<em>1+1, Tk</em>2-1, ...}, given two indices  <code>(i,j)</code>, <code>ijselector(i, j)</code> returns  a couple of indices <code>x+y, abs(x-y)</code> for the calculation of s and h see eq (22) of scipost<em>202106</em>00048v3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/DACP.jl#LL291-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.isinband-Tuple{Quantica.Bandstructure,Any}" href="#Quantica.isinband-Tuple{Quantica.Bandstructure,Any}"><code>Quantica.isinband</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isinband(b::Bandstructure, ε)
isinband(b::Band, ε)</code></pre><p>Returns true if <code>ε</code> is contained within a band, false otherwise.</p><p><strong>See also:</strong></p><pre><code class="nohighlight hljs">`gap`, `minima`, `maxima`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/bandstructure.jl#LL1073-L1081">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.iterateDACP_f!-NTuple{4,Any}" href="#Quantica.iterateDACP_f!-NTuple{4,Any}"><code>Quantica.iterateDACP_f!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>action of the chebyshev iteration of the operator <code>F</code> on a state <code>x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/DACP.jl#LL345-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.iterateDACP_g!-NTuple{4,Any}" href="#Quantica.iterateDACP_g!-NTuple{4,Any}"><code>Quantica.iterateDACP_g!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>action of the chebyshev iteration of the operator <code>G</code> on a state <code>x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/DACP.jl#LL355-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.iterate_chebyshev-Tuple{Any,Array{Array{Complex{Float64},2},1},Any,Any,Any}" href="#Quantica.iterate_chebyshev-Tuple{Any,Array{Array{Complex{Float64},2},1},Any,Any,Any}"><code>Quantica.iterate_chebyshev</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`iterate_chebyshev(K, ψ0::Vector{Matrix{ComplexF64}}, ψ1, hsquared, bounds)`</code></pre><p>returns the action TK(𝔽)|ψ0⟩ on a block of random vectors <code>ψ0</code> see: <code>semicircle_filter()</code>. numkets Cheby loops are required. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/DACP.jl#LL154-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.ket-Tuple{AbstractArray{T,1} where T,Quantica.OrbitalStructure}" href="#Quantica.ket-Tuple{AbstractArray{T,1} where T,Quantica.OrbitalStructure}"><code>Quantica.ket</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ket(m::AbstractArray, o::OrbitalStructure)
ket(m::AbstractArray, h::Hamiltonian)</code></pre><p>Construct a <code>Ket</code> <code>|k⟩</code> with amplitudes <code>⟨i|k⟩ = m[i]</code>, which can be scalars or <code>SVector</code>s depending on the number of orbitals on site <code>i</code>. If <code>m</code> is an <code>AbstractMatrix</code> instead of an <code>AbstractVector</code>, the <code>Ket</code> represents a multi-column ket (i.e. a collection of kets <code>|kⱼ⟩</code>, one per column), such that <code>⟨i|kⱼ⟩ = m[i,j]</code>. The orbitals per sublattice are encoded in <code>o = orbitalstructure(h)</code>.</p><pre><code class="nohighlight hljs">ket(km::KetModel, h::Hamiltonian)</code></pre><p>Construct a <code>Ket</code> by applying model <code>km</code> to Hamiltonian <code>h</code> (see also <code>ketmodel</code> for details).</p><pre><code class="nohighlight hljs">ket(h::Hamiltonian)</code></pre><p>Construct a zero ket, equivalent to <code>ket(0, h; maporbitals = true, normalization = missing)</code></p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`ketmodel`, `ket!`, `onsite`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/ket.jl#LL169-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.ketmodel-Tuple{Any}" href="#Quantica.ketmodel-Tuple{Any}"><code>Quantica.ketmodel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ketmodel(a; region = missing, sublats = missing, normalization = 1, maporbitals = false, singlesitekets = false)</code></pre><p>Create an <code>KetModel</code> of amplitude <code>a</code> on any site in the specified <code>region</code> and <code>sublats</code>. For single-column kets, the amplitude <code>a</code> can be a <code>Number</code>, an <code>AbstractVector</code>, or for a position-dependent amplitude a function of the form <code>r -&gt; ...</code> returning either. For multi-column kets, make <code>a</code> an <code>AbstractMatrix{&lt;:Number}</code> or a function returning one, which will be sliced into each ket column as appropriate. An error will be thrown if the slicing is impossible, due e.g. to a mismatch of <code>size(a, 1)</code> and the number of orbitals in an applicable sublattice.</p><p><strong>Keyword arguments</strong></p><p>If keyword <code>normalization</code> is not <code>missing</code> or <code>false</code>, each column of the ket will be rescaled to have norm <code>normalization</code> when the <code>KetModel</code> is applied to a specific Hamiltonian. If a ket column <code>iszero</code>, however, it will not be normalized.</p><p>If keyword <code>maporbitals = true</code> and amplitude <code>a</code> is a scalar or a scalar function, <code>a</code> will be applied to each orbital independently. This is particularly useful in multiorbital systems with random amplitudes, e.g. <code>a = r -&gt; randn()</code>. If <code>a</code> is not a scalar and <code>maporbitals == true</code>, an error will be thrown.</p><p>If keyword <code>singlesitekets = true</code>, then the model represents a multicolumn ket, where each column (or block of columns for <code>a::AbstractMatrix</code>) has amplitude <code>a</code> on a single site of those selected by <code>region</code> and <code>sublats</code> (as opposed to having the same amplitude <code>a</code> on all said sites if <code>singlesitekets = false</code>). This is useful e.g. to build a basis for the selected sites.</p><p>Keywords <code>region</code> and <code>sublats</code> are the same as for <code>siteselector</code>. Only sites at position <code>r</code> in sublattice with name <code>s::NameType</code> will be selected if <code>region(r) &amp;&amp; s in sublats</code> is true. Any missing <code>region</code> or <code>sublat</code> will not be used to constraint the selection.</p><p>The keyword <code>sublats</code> allows the following formats:</p><pre><code class="nohighlight hljs">sublats = :A           # Onsite on sublat :A only
sublats = (:A,)        # Same as above
sublats = (:A, :B)     # Onsite on sublat :A and :B</code></pre><p><strong>Ket algebra</strong></p><p><code>KetModel</code>s created with <code>ket</code> can added or substracted together or be multiplied by scalars to build more elaborate <code>KetModel</code>s, e.g. <code>ket(1) - 3 * ket(2, region = r -&gt; norm(r) &lt; 10)</code>. Only models with the same <code>maporbitals</code> can be combined. When combining two models with different <code>singlesitekets</code>, the result has <code>singlesitekets = true</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; k = ketmodel(1, sublats=:A) - ketmodel(1, sublats=:B)
KetModel{2}: model with 2 terms
  Normalization : 1
  Map orbitals  : Val{false}()
  OnsiteTerm{Int64}:
    Sublattices      : A
    Coefficient      : 1
  OnsiteTerm{Int64}:
    Sublattices      : B
    Coefficient      : -1</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`ket`, `onsite`, `orbitalstructure`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/ket.jl#LL10-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.lattice-Tuple{Quantica.Sublat,Vararg{Quantica.Sublat,N} where N}" href="#Quantica.lattice-Tuple{Quantica.Sublat,Vararg{Quantica.Sublat,N} where N}"><code>Quantica.lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice(sublats::Sublat...; bravais = (), dim::Val{E}, type::T, names = missing)</code></pre><p>Create a <code>Lattice{E,L,T}</code> with Bravais vectors <code>bravais</code> and sublattices <code>sublats</code> converted to a common  <code>E</code>-dimensional embedding space and type <code>T</code>. To override the embedding  dimension <code>E</code>, use keyword <code>dim = Val(E)</code>. Similarly, override type <code>T</code> with <code>type = T</code>.</p><p>The keyword <code>bravais</code> indicates one or more Bravais vectors in the form of tuples or other iterables. It can also be an <code>AbstractMatrix</code> of dimension <code>E×L</code>. The default <code>bravais = ()</code> corresponds to a bounded lattice with no Bravais vectors.</p><p>A keyword <code>names</code> can be used to rename <code>sublats</code>. Given names can be replaced to ensure that all sublattice names are unique.</p><pre><code class="nohighlight hljs">lattice(lat::AbstractLattice; bravais = missing, dim = missing, type = missing, names = missing)</code></pre><p>Create a new lattice by applying any non-missing <code>kw</code> to <code>lat</code>. For performance, allocations will be avoided if possible (depends on <code>kw</code>), so the result can share memory of <code>lat</code>. To avoid that, do <code>lattice(copy(lat); kw...)</code>.</p><p>See also <code>LatticePresets</code> for built-in lattices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; lattice(sublat((0, 0)), sublat((0, Float32(1))); bravais = (1, 0), dim = Val(3))
Lattice{3,1,Float32} : 1D lattice in 3D space
  Bravais vectors : ((1.0f0, 0.0f0, 0.0f0),)
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (1, 1) --&gt; 2 total per unit cell

julia&gt; LatticePresets.honeycomb(names = (:C, :D))
Lattice{2,2,Float64} : 2D lattice in 2D space
  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))
  Sublattices     : 2
    Names         : (:C, :D)
    Sites         : (1, 1) --&gt; 2 total per unit cell

julia&gt; LatticePresets.cubic(bravais = ((1, 0), (0, 2)))
Lattice{3,2,Float64} : 2D lattice in 3D space
  Bravais vectors : ((1.0, 0.0, 0.0), (0.0, 2.0, 0.0))
  Sublattices     : 1
    Names         : (:A)
    Sites         : (1) --&gt; 1 total per unit cell</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`LatticePresets`, `bravais`, `sublat`, `supercell`, `intracell`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/lattice.jl#LL213-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.maxima-Union{Tuple{Quantica.Bandstructure{1,#s35,T,B,M} where M&lt;:Quantica.Diagonalizer where B&lt;:(Quantica.Band{1,#s35,T,S,S´,D´} where D´ where S´&lt;:(AbstractArray{T,2} where T) where S&lt;:AbstractArray{#s35,2}) where #s35}, Tuple{T}} where T" href="#Quantica.maxima-Union{Tuple{Quantica.Bandstructure{1,#s35,T,B,M} where M&lt;:Quantica.Diagonalizer where B&lt;:(Quantica.Band{1,#s35,T,S,S´,D´} where D´ where S´&lt;:(AbstractArray{T,2} where T) where S&lt;:AbstractArray{#s35,2}) where #s35}, Tuple{T}} where T"><code>Quantica.maxima</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maxima(b::Bandstructure{1}; refinesteps = 0)</code></pre><p>For a 1D bandstructure <code>b</code>, compute a vector of <code>Vector{Tuple{T,T}}</code>s (one per band), containing pairs <code>(φ, ε)</code> of Bloch phase and energy where the band, as sampled, has a local maximum. The maxima will be further refined by a number <code>refinesteps</code> of bisections steps. Only band vertices with one neighbors on each side will be considered as potential local maximum.</p><p><strong>See also:</strong></p><pre><code class="nohighlight hljs">`minima`, `gapedge`, `gap`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/bandstructure.jl#LL960-L971">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.minima-Union{Tuple{Quantica.Bandstructure{1,#s35,T,B,M} where M&lt;:Quantica.Diagonalizer where B&lt;:(Quantica.Band{1,#s35,T,S,S´,D´} where D´ where S´&lt;:(AbstractArray{T,2} where T) where S&lt;:AbstractArray{#s35,2}) where #s35}, Tuple{T}} where T" href="#Quantica.minima-Union{Tuple{Quantica.Bandstructure{1,#s35,T,B,M} where M&lt;:Quantica.Diagonalizer where B&lt;:(Quantica.Band{1,#s35,T,S,S´,D´} where D´ where S´&lt;:(AbstractArray{T,2} where T) where S&lt;:AbstractArray{#s35,2}) where #s35}, Tuple{T}} where T"><code>Quantica.minima</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minima(b::Bandstructure{1}; refinesteps = 0)</code></pre><p>For a 1D bandstructure <code>b</code>, compute a vector of <code>Vector{Tuple{T,T}}</code>s (one per band), containing pairs <code>(φ, ε)</code> of Bloch phase and energy where the band, as sampled, has a local minimum. The minima will be further refined by a number <code>refinesteps</code> of bisections steps. Only band vertices with one neighbors on each side will be considered as potential local minimum.</p><p><strong>See also:</strong></p><pre><code class="nohighlight hljs">`maxima`, `gapedge`, `gap`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/bandstructure.jl#LL943-L954">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.momentaKPM" href="#Quantica.momentaKPM"><code>Quantica.momentaKPM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">momentaKPM(h::Hamiltonian, A = I; ket = randomkets(1), order = 10, bandrange = missing, flat = Val(true))</code></pre><p>Compute the Kernel Polynomial Method (KPM) momenta <code>μₙ = ⟨k|Tₙ(h) A|k⟩</code>, where <code>|k⟩ = ket(ket::KetModel, h)</code> or <code>|k⟩ = ket::Ket</code> (depending on the type of <code>ket</code>), <code>A</code> is an observable (<code>Hamiltonian</code> or <code>AbstractMatrix</code>) and <code>Tₙ(h)</code> is the order-<code>n</code> Chebyshev polynomial of the Hamiltonian <code>h</code>.</p><p><code>ket</code> can be a single <code>KetModel</code> or <code>Ket</code>, as above, or a collection of them, as in the default <code>ket = randomkets(n)</code>. In the latter case, <code>μₙ</code> is summed over all models/kets, <code>μₙ = ∑_k ⟨k|Tₙ(h) A|k⟩</code>. If <code>ket::Ket</code> is a multi-column ket, a sum over columns will similarly be performed. A <code>ket = randomkets(n)</code> produces a lazy collection of <code>n</code> random <code>KetModel</code>s that is useful to estimate momenta of normalized traces using the stochastic trace approach, whereby <code>μ_n = Tr[A T_n(h)]/N₀ ≈ ∑ₖ⟨k|A T_n(h)|k⟩</code>. Here the <code>|k⟩</code>s are <code>n</code> random kets of norm <code>1/√n</code> and <code>N₀</code> is the total number of orbitals per unit cell of <code>h</code> (see <code>randomkets</code>).</p><p>The order of the Chebyshev expansion is <code>order</code>. The <code>bandbrange = (ϵmin, ϵmax)</code> should completely encompass the full bandwidth of <code>hamiltonian</code>. If <code>missing</code> it is computed automatically using <code>ArnoldiMethod</code> (must be loaded <code>using ArnoldiMethod</code>). <code>flat</code> indicates whether, in the case of multiorbital systems, the internal computations are to be performed using flattened arrays, typically increasing performace by making use of external linear algebra libraries (e.g. MKL or OpenBLAS).</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; h = LatticePresets.cubic() |&gt; hamiltonian(hopping(1)) |&gt; unitcell(region = RegionPresets.sphere(10));

julia&gt; momentaKPM(h, bandrange = (-6,6)).mulist |&gt; length
11</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/KPM.jl#LL99-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.mul_f!-NTuple{4,Any}" href="#Quantica.mul_f!-NTuple{4,Any}"><code>Quantica.mul_f!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns the action of the operator <code>F</code> on a state <code>x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/DACP.jl#LL325-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.mul_g!-NTuple{4,Any}" href="#Quantica.mul_g!-NTuple{4,Any}"><code>Quantica.mul_g!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns the action of the operator <code>G</code> on a state <code>x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/DACP.jl#LL335-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.not-Tuple{Any}" href="#Quantica.not-Tuple{Any}"><code>Quantica.not</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">not(i)</code></pre><p>Wrapper indicating the negation or complement of <code>i</code>, typically used to encode excluded site indices. See <code>siteselector</code> and <code>hopselector</code> for applications.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/model.jl#LL111-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.nrange-Tuple{Int64}" href="#Quantica.nrange-Tuple{Int64}"><code>Quantica.nrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nrange(n::Int)</code></pre><p>Create a <code>NeighborRange</code> that represents a hopping range to distances corresponding to the n-th nearest neighbors in a given lattice. Such distance is obtained by finding the n-th closest pairs of sites in a lattice, irrespective of their sublattice.</p><pre><code class="nohighlight hljs">nrange(n::Int, lat::AbstractLattice)</code></pre><p>Obtain the actual nth-nearest-neighbot distance between sites in lattice <code>lat</code>.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`hopping`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/model.jl#LL10-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.offdiagonal-Tuple{Quantica.TightbindingModel,Any,Any}" href="#Quantica.offdiagonal-Tuple{Quantica.TightbindingModel,Any,Any}"><code>Quantica.offdiagonal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">offdiagonal(model, lat, nsublats::NTuple{N,Int})</code></pre><p>Build a restricted version of <code>model</code> that applies only to off-diagonal blocks formed by sublattice groups of size <code>nsublats</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/model.jl#LL771-L776">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.onsite-Tuple{Any}" href="#Quantica.onsite-Tuple{Any}"><code>Quantica.onsite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">onsite(o; region = missing, sublats = missing)</code></pre><p>Create an <code>TightbindingModel</code> with a single <code>OnsiteTerm</code> that applies an onsite energy <code>o</code> to a <code>Lattice</code> when creating a <code>Hamiltonian</code> with <code>hamiltonian</code>.</p><p>The onsite energy <code>o</code> can be a number, an <code>SMatrix</code>, a <code>UniformScaling</code> (e.g. <code>3*I</code>) or a function of the form <code>r -&gt; ...</code> for a position-dependent onsite energy.</p><p>The dimension of <code>o::AbstractMatrix</code> must match the orbital dimension of applicable sublattices (see also <code>orbitals</code> option for <code>hamiltonian</code>). If <code>o::UniformScaling</code> it will be converted to an identity matrix of the appropriate size when applied to multiorbital sublattices. Similarly, if <code>o::SMatrix</code> it will be truncated or padded to the appropriate size.</p><pre><code class="nohighlight hljs">onsite(model::TightbindingModel; kw...)</code></pre><p>Return a <code>TightbindingModel</code> with only the onsite terms of <code>model</code>. Any non-missing <code>kw</code> is applied to all such terms.</p><p><strong>Keyword arguments</strong></p><p>Keywords are the same as for <code>siteselector</code>. Only sites at position <code>r</code> in sublattice with name <code>s::NameType</code> will be selected if <code>region(r) &amp;&amp; s in sublats</code> is true. Any missing <code>region</code> or <code>sublat</code> will not be used to constraint the selection.</p><p>The keyword <code>sublats</code> allows the following formats:</p><pre><code class="nohighlight hljs">sublats = :A           # Onsite on sublat :A only
sublats = (:A,)        # Same as above
sublats = (:A, :B)     # Onsite on sublat :A and :B</code></pre><p><strong>Combining models</strong></p><p><code>OnsiteTerm</code>s and <code>HoppingTerm</code>s created with <code>onsite</code> or <code>hopping</code> can added or substracted together or be multiplied by scalars to build more complicated <code>TightbindingModel</code>s, e.g. <code>onsite(1) - 3 * hopping(2)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = onsite(1, sublats = (:A,:B)) - 2 * hopping(2, sublats = :A=&gt;:A)
TightbindingModel{2}: model with 2 terms
  OnsiteTerm{Int64}:
    Sublattices      : (:A, :B)
    Coefficient      : 1
  HoppingTerm{Int64}:
    Sublattice pairs : :A =&gt; :A
    dn cell distance : any
    Hopping range    : NeighborRange(1)
    Coefficient      : -2

julia&gt; newmodel = onsite(model; sublats = :A) + hopping(model)
TightbindingModel{2}: model with 2 terms
  OnsiteTerm{Int64}:
    Sublattices      : A
    Coefficient      : 1
  HoppingTerm{Int64}:
    Sublattice pairs : :A =&gt; :A
    dn cell distance : any
    Hopping range    : NeighborRange(1)
    Coefficient      : -2

julia&gt; LatticePresets.honeycomb() |&gt; hamiltonian(onsite(r -&gt; @SMatrix[1 2; 3 4]), orbitals = Val(2))
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 1 (SparseMatrixCSC, sparse)
  Harmonic size    : 2 × 2
  Orbitals         : ((:a, :a), (:a, :a))
  Element type     : 2 × 2 blocks (ComplexF64)
  Onsites          : 2
  Hoppings         : 0
  Coordination     : 0.0</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`hopping`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/model.jl#LL552-L628">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.orbitalstructure-Tuple{Quantica.Hamiltonian}" href="#Quantica.orbitalstructure-Tuple{Quantica.Hamiltonian}"><code>Quantica.orbitalstructure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">orbitalstructure(x::Union{Hamiltonian,ParametricHamiltonian})
orbitalstructure(x::Subspace)</code></pre><p>Return an <code>OrbitalStructure</code> containing information about the orbital structure of <code>x</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sp = spectrum(LP.honeycomb() |&gt; hamiltonian(hopping(I), orbitals = (:up,:down)) |&gt; unitcell);

julia&gt; sp[around = -1] |&gt; orbitalstructure
OrbitalStructure:
  Orbital Type  : SVector{2, ComplexF64}
  Orbitals      : ((:up, :down), (:up, :down))
  Sublattices   : 2
  Dimensions    : 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/hamiltonian.jl#LL803-L821">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.parameters-Tuple{Quantica.ParametricHamiltonian}" href="#Quantica.parameters-Tuple{Quantica.ParametricHamiltonian}"><code>Quantica.parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameters(ph::ParametricHamiltonian)</code></pre><p>Return the names of the parameter that <code>ph</code> depends on</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/parametric.jl#LL243-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.parameters-Tuple{Vararg{Quantica.AbstractModifier,N} where N}" href="#Quantica.parameters-Tuple{Vararg{Quantica.AbstractModifier,N} where N}"><code>Quantica.parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameters(p::AbstractModifier...)</code></pre><p>Return the parameter names for one or several <code>AbstractModifier</code> created with <code>@onsite!</code>, <code>@hopping!</code> or <code>@block!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/model.jl#LL827-L832">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.parametric-Tuple{Quantica.Hamiltonian,Vararg{Quantica.AbstractModifier,N} where N}" href="#Quantica.parametric-Tuple{Quantica.Hamiltonian,Vararg{Quantica.AbstractModifier,N} where N}"><code>Quantica.parametric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parametric(h::Hamiltonian, modifiers::AbstractModifier...; check = true)</code></pre><p>Builds a <code>ParametricHamiltonian</code> that can be used to efficiently apply <code>modifiers</code> to <code>h</code>. <code>modifiers</code> can be any number of <code>@onsite!(args -&gt; body; kw...)</code> and <code>@hopping!(args -&gt; body; kw...)</code> transformations, each with a set of parameters <code>ps</code> given as keyword arguments of functions <code>f = (...; ps...) -&gt; body</code>.</p><p>For sparse <code>h</code> (the default), <code>parametric</code> only modifies existing onsites and hoppings in <code>h</code>, so be sure to add zero onsites and/or hoppings to <code>h</code> if they are originally not present but you need to apply modifiers to them.</p><pre><code class="nohighlight hljs">ph(; ps...)</code></pre><p>For a <code>ph::ParametricHamiltonian</code>, return the corresponding <code>Hamiltonian</code> with parameters <code>ps</code> applied.</p><pre><code class="nohighlight hljs">h |&gt; parametric(modifiers::AbstractModifier...; kw...)</code></pre><p>Function form of <code>parametric</code>, equivalent to <code>parametric(h, modifiers...; kw...)</code>.</p><p><strong>Keywords</strong></p><p>If the keyword argument <code>check = true</code> a check is performed upon each call <code>h = ph(; ps...)</code> to ensure that the harmonics of the produced Hamiltonian are all internally consistent with the orbital structure of <code>h</code> (i.e. if the provided modifiers do not create incorrect matrix elements). Unless the number of orbitals of <code>h</code> is the same in all sublattices, this <code>check</code> can have a substantial performance impact, so it is advisable to disable it with <code>check = false</code> once the user has confirmed that <code>ph(; ps...)</code> throws no error with <code>check = true</code>.</p><p><strong>Indexing</strong></p><p>Indexing into a <code>ParametricHamiltonian</code>, as in <code>ph[rows, cols]</code> creates a <code>Slice{&lt;:ParametricHamiltonian}</code>, which is the parametric version of <code>Slice{&lt;:Hamiltonian}</code>, see <code>hamiltonian</code> for details.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ph = LatticePresets.honeycomb() |&gt; hamiltonian(onsite(0) + hopping(1, range = 1/√3)) |&gt;
       unitcell(10) |&gt; parametric(@onsite!((o; μ) -&gt; o - μ))
ParametricHamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)
  Harmonic size    : 200 × 200
  Orbitals         : ((:a,), (:a,))
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 600
  Coordination     : 3.0
  Parameters       : (:μ,)
  Check each call  : true

julia&gt; ph(μ = 2)
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)
  Harmonic size    : 200 × 200
  Orbitals         : ((:a,), (:a,))
  Element type     : scalar (ComplexF64)
  Onsites          : 200
  Hoppings         : 600
  Coordination     : 3.0</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`@onsite!`, `@hopping!`, `@block!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/parametric.jl#LL23-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.proj_DACP-Tuple{Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian},Any}" href="#Quantica.proj_DACP-Tuple{Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian},Any}"><code>Quantica.proj_DACP</code></a> — <span class="docstring-category">Method</span></header><section><div><p>given a <code>h::Union{ParametricHamiltonian, Hamiltonian}</code> returns the projection of <code>h</code> and of the overlap matrix, <code>s</code> to a lower subspace 𝕃 with eigenvalues inside the energy interval: (-<code>a</code>, <code>a</code>).  The dimension of the desired subspace must be given as an input <code>d</code> and  <code>a &lt; min(Emax, |Emin|)</code></p><p>REMARKS:     - Validity is conditioned to the requirement <code>a &lt;&lt; emax</code>     - in order to accurately span 𝕃, we form a basis by Chebyshev evolution of          <code>ψe</code> using <code>n = (l*d-1)/2</code> states with l&gt;=1 (set by default to l = 1.5).     - for a given <code>d</code>, <code>a</code> must be appropriately chosen to ensure that the number of         eigenstates in <code>[-a, a]</code> is a little less than the dimension of constructed basis,          i.e. &lt; 2n + 1 (overestimation). This requires prior knowledge about the spectrum         edges. However, the subspace dimension, <code>d</code>, can be efficiently determined using          the KPM method. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/DACP.jl#LL51-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.proj_h_s-Tuple{Quantica.DACPsubspace,Any,Missing,Any}" href="#Quantica.proj_h_s-Tuple{Quantica.DACPsubspace,Any,Missing,Any}"><code>Quantica.proj_h_s</code></a> — <span class="docstring-category">Method</span></header><section><div><p>computes the reduced h and s matrices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/DACP.jl#LL188-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.qz_diag-Tuple{Any,Any}" href="#Quantica.qz_diag-Tuple{Any,Any}"><code>Quantica.qz_diag</code></a> — <span class="docstring-category">Method</span></header><section><div><p>codepath with schur diagonalization and a brute force rank revealing factorization</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/DACP.jl#LL418">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.randomkets" href="#Quantica.randomkets"><code>Quantica.randomkets</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">randomkets(n, a = r -&gt; cis(2pi*rand()); kw...)</code></pre><p>Create a lazy collection of <code>n</code> <code>KetModel</code>s of amplitude <code>a</code>, and <code>normalization = 1/√n</code>. Other keyword arguments are forwarded to <code>ketmodel</code>.</p><p>This type of ket model is useful e.g. in stochastic trace evaluation of KPM methods, where the amplitude is chosen as a random function with <code>⟨a⟩ = 0</code>, <code>⟨aa⟩ = 0</code> and <code>⟨a&#39;a⟩ = 1</code>. The default <code>a</code> is a uniform random phase on each site, which satisties these conditions. Then, the normalized trace of an operator <code>A</code> can be estimated with <code>Tr[A]/N₀ ≈ ∑⟨ket|A|ket⟩</code>, where the sum is taken over the <code>n</code> random kets <code>|ket⟩</code> of norm <code>1/√n</code> produced by <code>randomkets</code>, and <code>N₀</code> is the total number of orbitals in the full unit cell.</p><p>To apply it to a multiorbital system with a maximum of <code>N</code> orbitals per site, <code>a</code> must in general be adapted to produce the desired random <code>SVector{N}</code> (unless <code>maporbitals = true</code>), with the above statistical properties for each orbital. Example: to have independent, complex, normally-distributed random components of two orbitals use <code>randomkets(n, r -&gt; randn(SVector{2,ComplexF64}))</code>, or alternatively <code>randomkets(n, r -&gt; randn(ComplexF64), maporbitals = true)</code>.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`ket`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/KPM.jl#LL4-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.rank" href="#Quantica.rank"><code>Quantica.rank</code></a> — <span class="docstring-category">Function</span></header><section><div><p>computes the rank of matrix of a given matrix A, using R<em>A, an upper triangular matrix which comes from the A = Q</em>A R_A. A QR factorisation with complete pivoting</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/DACP.jl#LL465-L467">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.semicircle_filter-Tuple{Quantica.ParametricHamiltonian,Any}" href="#Quantica.semicircle_filter-Tuple{Quantica.ParametricHamiltonian,Any}"><code>Quantica.semicircle_filter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`semicircle_filter(h::ParametricHamiltonian, a)`</code></pre><p>Given an energy cutoff <code>a::Float64</code>, which defines the spectral window (-a, a), a  hamiltonian <code>H</code>, and a random ket <code>ψ</code> s.t. |ψ⟩ = ∑ᵢcᵢ|ϕᵢ⟩ + ∑ⱼdⱼ|χⱼ⟩ where {|ϕᵢ⟩} and {|χj⟩} are eigenstates in a subspace of H with energies inside (-a, a), it returns <code>ψ_e</code> s.t. |ψₑ⟩ ≈ ∑ᵢ c&#39;ᵢ|ψᵢ⟩, that is some linear combination of eigenstates that live in the 𝕃  subspace by means of an exponential filter implemented by means of a Chebyshev iteration</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/DACP.jl#LL92-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.similarmatrix" href="#Quantica.similarmatrix"><code>Quantica.similarmatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">similarmatrix(h::Hamiltonian)</code></pre><p>Create an uninitialized matrix of the same type and size of the Hamiltonian&#39;s matrix.</p><pre><code class="nohighlight hljs">similarmatrix(h::Hamiltonian, T::Type{&lt;:AbstractMatrix})</code></pre><p>Make the matrix of type <code>B&lt;:T</code>. Can be used to specify a different eltype from <code>h</code>&#39;s, (e.g. <code>T=SparseMatrixCSC{Float64}</code> with a multiorbital <code>h</code>)</p><pre><code class="nohighlight hljs">similarmatrix(h::Hamiltonian, flatten)</code></pre><p>Create an unitialized matrix of the same type as a flattened version of <code>h</code>&#39;s, i.e. with a scalar eltype as in the example above.</p><pre><code class="nohighlight hljs">similarmatrix(h::Hamiltonian, T::AbstractDiagonalizeMethod)</code></pre><p>Adapts the type of the matrix (e.g. dense/sparse) to the specified <code>method</code></p><pre><code class="nohighlight hljs">similarmatrix(x::Union{ParametricHamiltonian, GreensFunction}, ...)</code></pre><p>Equivalent to the above, but adapted to the more general type of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = LatticePresets.honeycomb() |&gt; hamiltonian(hopping(I), orbitals = Val(2));

julia&gt; similarmatrix(h) |&gt; summary
&quot;2×2 SparseMatrixCSC{SMatrix{2, 2, ComplexF64, 4}, Int64}&quot;

julia&gt; similarmatrix(h, Matrix{Int}) |&gt; summary
&quot;4×4 Matrix{Int64}&quot;

julia&gt; similarmatrix(h, flatten) |&gt; summary
&quot;4×4 SparseMatrixCSC{ComplexF64, Int64}&quot;

julia&gt; similarmatrix(h, LinearAlgebraPackage()) |&gt; summary
&quot;4×4 Matrix{ComplexF64}&quot;</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`bloch!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/hamiltonian.jl#LL572-L615">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.siteindices-Tuple{Quantica.AbstractLattice}" href="#Quantica.siteindices-Tuple{Quantica.AbstractLattice}"><code>Quantica.siteindices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">siteindices(lat::AbstractLattice; kw...)
siteindices(h::Hamiltonian; kw...)
siteindices(lat_or_h, s::SiteSelector)</code></pre><p>Build a generator of the unique indices of sites in the lattice unitcell. Only sites specified by <code>siteselector(kw...)</code> are selected, see <code>siteselector</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/hamiltonian.jl#LL844-L852">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.sitepositions-Tuple{Quantica.AbstractLattice}" href="#Quantica.sitepositions-Tuple{Quantica.AbstractLattice}"><code>Quantica.sitepositions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sitepositions(lat::AbstractLattice; kw...)
sitepositions(h::Hamiltonian; kw...)</code></pre><p>Build a generator of the positions of sites in the lattice unitcell. Only sites specified by <code>siteselector(kw...)</code> are selected, see <code>siteselector</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/hamiltonian.jl#LL833-L840">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.siteselector-Tuple{}" href="#Quantica.siteselector-Tuple{}"><code>Quantica.siteselector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">siteselector(; region = missing, sublats = missing, indices = missing)</code></pre><p>Return a <code>SiteSelector</code> object that can be used to select sites in a lattice contained within the specified region and sublattices. Only sites with index <code>i</code>, at position <code>r</code> and belonging to a sublattice with name <code>s::NameType</code> will be selected if</p><pre><code class="nohighlight hljs">`region(r) &amp;&amp; s in sublats &amp;&amp; i in indices`</code></pre><p>Any missing <code>region</code>, <code>sublat</code> or <code>indices</code> will not be used to constraint the selection.</p><p>The keyword <code>sublats</code> allows the following formats:</p><pre><code class="nohighlight hljs">sublats = :A                    # Sites on sublat :A only
sublats = (:A,)                 # Same as above
sublats = (:A, :B)              # Sites on sublat :A and :B</code></pre><p>The keyword <code>indices</code> accepts a single integer, or a collection thereof. If several collections are given, they are flattened into a single one. Possible combinations:</p><pre><code class="nohighlight hljs">indices = 1                     # Site 1 only
indices = (1, )                 # Same as above
indices = (1, 2, 3)             # Sites 1, 2 or 3
indices = [1, 2, 3]             # Same as above
indices = 1:3                   # Same as above
indices = (1:3, 7, 8)           # Sites 1, 2, 3, 7 or 8</code></pre><p>Additionally, indices or sublattices can be wrapped in <code>not</code> to exclude them (see <code>not</code>):</p><pre><code class="nohighlight hljs">sublats = not(:A)               # Any sublat different from :A
sublats = not(:A, :B)           # Any sublat different from :A and :B
indices = not(8)                # Any site index different from 8
indices = not(1, 3:4)           # Any site index different from 1, 3 or 4
indices = (not(3:4), 4:6)       # Any site different from 3 and 4, *or* equal to 4, 5 or 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/model.jl#LL121-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.splitbands-Tuple{Quantica.Bandstructure}" href="#Quantica.splitbands-Tuple{Quantica.Bandstructure}"><code>Quantica.splitbands</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splitbands(bs::Bandstructure)</code></pre><p>Splits the bands in <code>bs</code> into disconnected subbands that share no vertices. See also <code>splitbands</code> option in <code>bandstructure</code>.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`bandstructure`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/bandstructure.jl#LL744-L751">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.sublat-Tuple{AbstractArray{#s39,1} where #s39&lt;:(StaticArrays.SArray{Tuple{S},T,1,S} where T where S)}" href="#Quantica.sublat-Tuple{AbstractArray{#s39,1} where #s39&lt;:(StaticArrays.SArray{Tuple{S},T,1,S} where T where S)}"><code>Quantica.sublat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sublat(sites...; name::Symbol)
sublat(sites::Vector{&lt;:SVector}; name::Symbol)</code></pre><p>Create a <code>Sublat{E,T,D}</code> that adds a sublattice, of name <code>name</code>, with sites at positions <code>sites</code> in <code>E</code> dimensional space. Sites can be entered as tuples or <code>SVectors</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sublat((0.0, 0), (1, 1), (1, -1), name = :A)
Sublat{2,Float64} : sublattice of Float64-typed sites in 2D space
  Sites    : 3
  Name     : :A</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/lattice.jl#LL26-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.subspace_dimension-Tuple{Any,Any}" href="#Quantica.subspace_dimension-Tuple{Any,Any}"><code>Quantica.subspace_dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><p>&quot;     <code>subspace_dimension(h, b)</code> performs the numerical integration of the <code>dos</code> inside the interval <code>(-a,a)</code>. <code>dos</code> is  computed using the KPM, see <code>dosKPM</code> with a number of momenta <code>N</code> enough to resolve the  interval <code>(-a, a)</code>, i.e. <code>N = bandwidth/a</code> Arguments: <code>b::DACPbuilder</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/DACP.jl#LL166-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.supercell-Tuple" href="#Quantica.supercell-Tuple"><code>Quantica.supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">supercell(lat::AbstractLattice{E,L}, v::NTuple{L,Integer}...; seed = missing, kw...)
supercell(lat::AbstractLattice{E,L}, sc::SMatrix{L,L´,Int}; seed = missing, kw...)</code></pre><p>Generates a <code>Superlattice</code> from an <code>L</code>-dimensional lattice <code>lat</code> with Bravais vectors <code>br´= br * sc</code>, where <code>sc::SMatrix{L,L´,Int}</code> is the integer supercell matrix with the <code>L´</code> vectors <code>v</code>s as columns. If no <code>v</code> are given, the superlattice will be bounded.</p><p>Only sites selected by <code>siteselector(; kw...)</code> will be included in the supercell (see <code>siteselector</code> for details on the available keywords <code>kw</code>). The search for included sites will start from point <code>seed::Union{Tuple,SVector}</code>, or the origin if <code>seed = missing</code>. If no keyword <code>region</code> is given in <code>kw</code>, a Bravais unit cell perpendicular to the <code>v</code> axes will be selected for the <code>L-L´</code> non-periodic directions.</p><pre><code class="nohighlight hljs">supercell(lattice::AbstractLattice{E,L}, factor::Integer; kw...)</code></pre><p>Calls <code>supercell</code> with a uniformly scaled <code>sc = SMatrix{L,L}(factor * I)</code></p><pre><code class="nohighlight hljs">supercell(lattice::AbstractLattice, factors::Integer...; kw...)</code></pre><p>Calls <code>supercell</code> with different scaling along each Bravais vector (diagonal supercell with factors along the diagonal)</p><pre><code class="nohighlight hljs">lat |&gt; supercell(v...; kw...)</code></pre><p>Curried syntax, equivalent to `supercell(lat, v...; kw...)</p><pre><code class="nohighlight hljs">supercell(h::Hamiltonian, v...; kw...)</code></pre><p>Promotes the <code>Lattice</code> of <code>h</code> to a <code>Superlattice</code> without changing the Hamiltonian itself, which always refers to the unitcell of the lattice.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; supercell(LatticePresets.honeycomb(), region = RegionPresets.circle(300))
Superlattice{2,2,Float64,0} : 2D lattice in 2D space, filling a 0D supercell
  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (1, 1) --&gt; 2 total per unit cell
  Supercell{2,0} for 0D superlattice of the base 2D lattice
    Supervectors  : ()
    Supersites    : 652966

julia&gt; supercell(LatticePresets.triangular(), (1,1), (1, -1))
Superlattice{2,2,Float64,2} : 2D lattice in 2D space, filling a 2D supercell
  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))
  Sublattices     : 1
    Names         : (:A)
    Sites         : (1) --&gt; 1 total per unit cell
  Supercell{2,2} for 2D superlattice of the base 2D lattice
    Supervectors  : ((1, 1), (1, -1))
    Supersites    : 2

julia&gt; LatticePresets.square() |&gt; supercell(3)
Superlattice{2,2,Float64,2} : 2D lattice in 2D space, filling a 2D supercell
  Bravais vectors : ((1.0, 0.0), (0.0, 1.0))
  Sublattices     : 1
    Names         : (:A)
    Sites         : (1) --&gt; 1 total per unit cell
  Supercell{2,2} for 2D superlattice of the base 2D lattice
    Supervectors  : ((3, 0), (0, 3))
    Supersites    : 9</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`unitcell`, `siteselector`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/lattice.jl#LL559-L627">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.transform!-Tuple{Any,Quantica.Bandstructure}" href="#Quantica.transform!-Tuple{Any,Quantica.Bandstructure}"><code>Quantica.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(f::Function, b::Bandstructure)</code></pre><p>Transform the energies of all bands in <code>b</code> by applying <code>f</code> to them in place.</p><pre><code class="nohighlight hljs">transform!((fk, fε), b::Bandstructure)</code></pre><p>Transform Bloch phases and energies of all bands in <code>b</code> by applying <code>fk</code> and <code>fε</code> to them in place, respectively. If any of them is <code>missing</code>, it will be ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/bandstructure.jl#LL274-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.transform!-Tuple{Any,Quantica.Hamiltonian}" href="#Quantica.transform!-Tuple{Any,Quantica.Hamiltonian}"><code>Quantica.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(f::Function, h::Hamiltonian)</code></pre><p>Transform the site positions of the Hamiltonian&#39;s lattice in place without modifying the Hamiltonian harmonics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/hamiltonian.jl#LL857-L862">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.transform!-Tuple{Any,Quantica.Spectrum}" href="#Quantica.transform!-Tuple{Any,Quantica.Spectrum}"><code>Quantica.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(f::Function, s::Spectrum)</code></pre><p>Transform the energies of <code>s</code> by applying <code>f</code> to them in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/bandstructure.jl#LL139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.transform!-Tuple{Function}" href="#Quantica.transform!-Tuple{Function}"><code>Quantica.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x |&gt; transform!(f::Function)</code></pre><p>Curried version of <code>transform!</code>, equivalent to <code>transform!(f, x)</code></p><pre><code class="nohighlight hljs">transform!(f::Function, lat::Lattice)</code></pre><p>Transform the site positions of <code>lat</code> by applying <code>f</code> to them in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/lattice.jl#LL487-L495">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.twoqr_diag-Tuple{Array{Complex{Float64},2},Array{Complex{Float64},2}}" href="#Quantica.twoqr_diag-Tuple{Array{Complex{Float64},2},Array{Complex{Float64},2}}"><code>Quantica.twoqr_diag</code></a> — <span class="docstring-category">Method</span></header><section><div><p>codepath with QRfactorizations; P(A,B) ψ = (A + λ B) ψ = 0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/DACP.jl#LL448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.unflatten-Tuple{Quantica.OrbitalStructure}" href="#Quantica.unflatten-Tuple{Quantica.OrbitalStructure}"><code>Quantica.unflatten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unflatten(x, o::OrbitalStructure)</code></pre><p>Rebuild object <code>x</code> performing the inverse of <code>flatten(x)</code> or <code>flatten(x, o)</code>. The target <code>o</code> is required.</p><pre><code class="nohighlight hljs">x |&gt; unflatten(o::OrbitalStructure)</code></pre><p>Curried form equivalent to <code>unflatten(x, o)</code> (included for consistency with the rest of the API).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = LP.honeycomb() |&gt; hamiltonian(hopping(I), orbitals = (:up,:down)) |&gt; unitcell;

julia&gt; psi = spectrum(h)[around = -1]
Subspace{0}: eigenenergy subspace on a 0D manifold
  Energy       : -0.9999999999999989
  Degeneracy   : 2
  Bloch/params : Float64[]
  Basis eltype : SVector{2, ComplexF64}

julia&gt; psiflat = flatten(psi)
Subspace{0}: eigenenergy subspace on a 0D manifold
  Energy       : -0.9999999999999989
  Degeneracy   : 2
  Bloch/params : Float64[]
  Basis eltype : ComplexF64

julia&gt; unflatten(psiflat, orbitalstructure(psi))
Subspace{0}: eigenenergy subspace on a 0D manifold
  Energy       : -0.9999999999999989
  Degeneracy   : 2
  Bloch/params : Float64[]
  Basis eltype : SVector{2, ComplexF64}

julia&gt; k = ket(ketmodel(1, sublats = :up), h) |&gt; flatten
Ket{ComplexF64}: ket with a 4 × 1 amplitude matrix
  OrbitalStructure:
    Orbital Type  : ComplexF64
    Orbitals      : ((:flat,), (:flat,))
    Sublattices   : 2
    Dimensions    : 4

julia&gt; unflatten(k, orbitalstructure(h))
Ket{SVector{2, ComplexF64}}: ket with a 2 × 1 amplitude matrix
  OrbitalStructure:
    Orbital Type  : SVector{2, ComplexF64}
    Orbitals      : ((:up, :down), (:up, :down))
    Sublattices   : 2
    Dimensions    : 2</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`flatten`, `orbitalstructure`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/hamiltonian.jl#LL404-L459">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.unitcell-Tuple{Vararg{Union{Integer, Tuple, StaticArrays.SArray{Tuple{S},T,1,S} where T where S, StaticArrays.SArray{Tuple{S1,S2},T,2,L} where L where T where S2 where S1},N} where N}" href="#Quantica.unitcell-Tuple{Vararg{Union{Integer, Tuple, StaticArrays.SArray{Tuple{S},T,1,S} where T where S, StaticArrays.SArray{Tuple{S1,S2},T,2,L} where L where T where S2 where S1},N} where N}"><code>Quantica.unitcell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unitcell(lat::Lattice{E,L}, v::NTuple{L,Integer}...; seed = missing, kw...)
unitcell(lat::Lattice{E,L}, uc::SMatrix{L,L´,Int}; seed = missing, kw...)</code></pre><p>Generates a <code>Lattice</code> from an <code>L</code>-dimensional lattice <code>lat</code> and a larger unit cell, such that its Bravais vectors are <code>br´= br * uc</code>. Here <code>uc::SMatrix{L,L´,Int}</code> is the integer unitcell matrix, with the <code>L´</code> vectors <code>v</code>s as columns. If no <code>v</code> are given, the new lattice will be bounded.</p><p>Only sites selected by <code>siteselector(; kw...)</code> will be included in the supercell (see <code>siteselector</code> for details on the available keywords <code>kw</code>). The search for included sites will start from point <code>seed::Union{Tuple,SVector}</code>, or the origin if <code>seed = missing</code>. If no keyword <code>region</code> is given in <code>kw</code>, a Bravais unit cell perpendicular to the <code>v</code> axes will be selected for the <code>L-L´</code> non-periodic directions.</p><pre><code class="nohighlight hljs">unitcell(lattice::Lattice{E,L}, factor::Integer; kw...)</code></pre><p>Calls <code>unitcell</code> with a uniformly scaled <code>uc = SMatrix{L,L}(factor * I)</code></p><pre><code class="nohighlight hljs">unitcell(lattice::Lattice{E,L}, factors::Integer...; kw...)</code></pre><p>Calls <code>unitcell</code> with different scaling along each Bravais vector (diagonal supercell with factors along the diagonal)</p><pre><code class="nohighlight hljs">unitcell(slat::Superlattice)</code></pre><p>Convert Superlattice <code>slat</code> into a lattice with its unit cell matching <code>slat</code>&#39;s supercell.</p><pre><code class="nohighlight hljs">unitcell(h::Hamiltonian, v...; mincoordination, modifiers = (), kw...)</code></pre><p>Transforms the <code>Lattice</code> of <code>h</code> to have a larger unitcell, while expanding the Hamiltonian accordingly.</p><p>A nonzero <code>mincoordination</code> indicates a minimum number of nonzero hopping neighbors required for sites to be included in the resulting unit cell. Sites with inferior coordination will be removed recursively, until all remaining satisfy <code>mincoordination</code>.</p><p>The <code>modifiers</code> (a tuple of <code>ElementModifier</code>s, either <code>@onsite!</code> or <code>@hopping!</code> with no free parameters) will be applied to onsite and hoppings as the hamiltonian is expanded. See <code>@onsite!</code> and <code>@hopping!</code> for details.</p><p>Note: for performance reasons, in sparse hamiltonians only the stored onsites and hoppings will be transformed by <code>ElementModifier</code>s, so you might want to add zero onsites or hoppings when building <code>h</code> to have a modifier applied to them later.</p><pre><code class="nohighlight hljs">lat_or_h |&gt; unitcell(v...; kw...)</code></pre><p>Curried syntax, equivalent to <code>unitcell(lat_or_h, v...; kw...)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unitcell(LatticePresets.honeycomb(), region = RegionPresets.circle(300))
Lattice{2,0,Float64} : 0D lattice in 2D space
  Bravais vectors : ()
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (326483, 326483) --&gt; 652966 total per unit cell

julia&gt; unitcell(LatticePresets.triangular(), (1,1), (1, -1))
Lattice{2,2,Float64} : 2D lattice in 2D space
  Bravais vectors : ((0.0, 1.732051), (1.0, 0.0))
  Sublattices     : 1
    Names         : (:A)
    Sites         : (2) --&gt; 2 total per unit cell

julia&gt; LatticePresets.square() |&gt; unitcell(3)
Lattice{2,2,Float64} : 2D lattice in 2D space
  Bravais vectors : ((3.0, 0.0), (0.0, 3.0))
  Sublattices     : 1
    Names         : (:A)
    Sites         : (9) --&gt; 9 total per unit cell

julia&gt; supercell(LatticePresets.square(), 3) |&gt; unitcell
Lattice{2,2,Float64} : 2D lattice in 2D space
  Bravais vectors : ((3.0, 0.0), (0.0, 3.0))
  Sublattices     : 1
    Names         : (:A)
    Sites         : (9) --&gt; 9 total per unit cell</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`supercell`, `siteselector`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/lattice.jl#LL774-L857">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.vertices-Tuple{Quantica.Bandstructure,Any}" href="#Quantica.vertices-Tuple{Quantica.Bandstructure,Any}"><code>Quantica.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertices(bs::Bandstructure, i)</code></pre><p>Return the vertices <code>(k..., ϵ)</code> of the i-th band in <code>bs</code>, in the form of a <code>Vector{SVector{L+1}}</code>, where <code>L</code> is the lattice dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/bandstructure.jl#LL266-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.wrap-Tuple{Quantica.Hamiltonian,Int64}" href="#Quantica.wrap-Tuple{Quantica.Hamiltonian,Int64}"><code>Quantica.wrap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap(h::Hamiltonian, axes; phases = missing)</code></pre><p>Build a new Hamiltonian from <code>h</code> reducing its dimensions from <code>L</code> to <code>L - length(axes)</code> by wrapping the specified Bravais <code>axes</code> into a loop. <code>axes</code> can be an integer ∈ 1:L or a tuple of such integers. If <code>phases</code> are given (with <code>length(axes) == length(phases)</code>), the wrapped hoppings at a cell distance <code>dn</code> along <code>axes</code> will be multiplied by a factor <code>cis(-dot(phases, dn))</code>. This is useful, for example, to represent a flux Φ through a loop, using a single <code>axes = 1</code> and <code>phases = 2π * Φ/Φ₀</code>.</p><pre><code class="nohighlight hljs">wrap(h::Hamiltonian; kw...)</code></pre><p>Wrap all axes of <code>h</code>, yielding a compactified zero-dimensional Hamiltonian.</p><pre><code class="nohighlight hljs">h |&gt; wrap(axes; kw...)</code></pre><p>Curried form equivalent to <code>wrap(h, axes; kw...)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LatticePresets.honeycomb() |&gt; hamiltonian(hopping(1, range = 1/√3)) |&gt;
       unitcell((1,-1), (10, 10)) |&gt; wrap(2)
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 1D Lattice in 2D space
  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)
  Harmonic size    : 40 × 40
  Orbitals         : ((:a,), (:a,))
  Element type     : scalar (Complex{Float64})
  Onsites          : 0
  Hoppings         : 120
  Coordination     : 3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/hamiltonian.jl#LL1588-L1620">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.@block!-Tuple{Any,Any,Any,Vararg{Any,N} where N}" href="#Quantica.@block!-Tuple{Any,Any,Any,Vararg{Any,N} where N}"><code>Quantica.@block!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@block!((block; params...) -&gt; modified_block, sites; dn = missing)
@block!((block; params...) -&gt; modified_block, (rows, cols); dn = missing)</code></pre><p>Create an <code>BlockModifier &lt;: AbstractModifier</code>, to be used with <code>parametric</code>, that applies <code>f = (block; ...) -&gt; ...</code> to a block <code>h[dn][sites, sites]</code> or <code>h[dn][rows, cols]</code> of hamiltonian <code>h</code>. Keyword arguments <code>params</code> are optional, and include any parameters that <code>modified_block</code> depends on that the user may want to tune. If the keyword <code>dn = missing</code>, the <code>dn</code> in <code>h[dn]</code> will be restricted to <code>dn = (0...)</code>. Otherwise the specified <code>dn</code>&#39;s will be modified (e.g. when <code>dn = (1,0)</code> or <code>dn = ((1,0), (-1,0))</code>).</p><p>Upon construction of a <code>ParametricHamiltonian</code> with a <code>@block!</code> modifier, a check is performed that the whole block specified by <code>(rows, cols)</code> is stored in the sparse Hamiltonian harmonics. If it is not, any non-zero element in <code>modified_block</code> will fail to be applied to the harmonic in question, so a warning is issued. The warning can be ignored if the user knows that all non-zero elements in <code>modified_block</code> are indeed stored in the harmonic, either as finite matrix elements or structural zeros.</p><p>Special care should be taken when using <code>@block!</code> on Hamiltonians with different number of orbitals in different sublattices. To avoid type-instabities in this case, the internal representation of Hamiltonian harmonics uses a uniform <code>eltype</code> that is an <code>SMatrix{N,N}</code> with <code>N</code> the maximum number of orbitals among the different sublattices (padded with zeros in sublattices with less than <code>N</code> orbitals). The matrix <code>modified_block</code> should have this same uniform <code>eltype</code>.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`@onsite!`, `@hopping!`, `parametric`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/model.jl#LL963-L990">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.@hopping!-Tuple{Any,Any}" href="#Quantica.@hopping!-Tuple{Any,Any}"><code>Quantica.@hopping!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@hopping!(args -&gt; body; kw...)</code></pre><p>Create an <code>ElementModifier &lt;: AbstractModifier</code>, to be used with <code>parametric</code>, that applies <code>f = args -&gt; body</code> to hoppings energies specified by <code>kw</code> (see <code>hopping</code> for details on possible <code>kw</code>s). The form of <code>args -&gt; body</code> may be <code>(t; params...) -&gt; ...</code> or <code>(t, r, dr; params...) -&gt; ...</code> if the modification is position (<code>r</code>, <code>dr</code>) dependent. Keyword arguments <code>params</code> are optional, and include any parameters that <code>body</code> depends on that the user may want to tune.</p><p>Note: unlike <code>onsite</code> and <code>hopping</code>, <code>ElementModifier</code>s cannot be combined (i.e. you cannot do <code>@onsite!(...) + @hopping!(...)</code>). <code>ElementModifier</code>s are not model terms but transformations of an existing Hamiltonian that are meant to be applied sequentially (the order of application usually matters).</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`@onsite!`, `@block!`, `parametric`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/model.jl#LL866-L882">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.@onsite!-Tuple{Any,Any}" href="#Quantica.@onsite!-Tuple{Any,Any}"><code>Quantica.@onsite!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@onsite!(args -&gt; body; kw...)</code></pre><p>Create an <code>ElementModifier &lt;: AbstractModifier</code>, to be used with <code>parametric</code>, that applies <code>f = args -&gt; body</code> to onsite energies specified by <code>kw</code> (see <code>onsite</code> for details on possible <code>kw</code>s). The form of <code>args -&gt; body</code> may be <code>(o; params...) -&gt; ...</code> or <code>(o, r; params...) -&gt; ...</code> if the modification is position (<code>r</code>) dependent. Keyword arguments <code>params</code> are optional, and include any parameters that <code>body</code> depends on that the user may want to tune.</p><p>Note: unlike <code>onsite</code> and <code>hopping</code>, <code>ElementModifier</code>s cannot be combined (i.e. you cannot do <code>@onsite!(...) + @hopping!(...)</code>). <code>ElementModifier</code>s are not model terms but transformations of an existing Hamiltonian that are meant to be applied sequentially (the order of application usually matters).</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`@hopping!`, `@block!`, `parametric`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/4c0f45c9761f7a868ec20ed2068e03dd9f6b6f3a/src/model.jl#LL838-L855">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Monday 9 May 2022 07:33">Monday 9 May 2022</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
