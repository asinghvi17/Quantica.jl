<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Quantica.jl</title><link rel="canonical" href="https://pablosanjose.github.io/Quantica.jl/reference/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Quantica.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Quantica.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Quantica.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pablosanjose/Quantica.jl/blob/master/docs/src/reference.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><ul><li><a href="#Quantica.Quantica"><code>Quantica.Quantica</code></a></li><li><a href="#Base.Matrix-Tuple{Quantica.KetModel,Quantica.Hamiltonian}"><code>Base.Matrix</code></a></li><li><a href="#Base.Vector-Tuple{Quantica.KetModel,Quantica.Hamiltonian}"><code>Base.Vector</code></a></li><li><a href="#Quantica.BoxIterator"><code>Quantica.BoxIterator</code></a></li><li><a href="#Quantica.SingleShot1D"><code>Quantica.SingleShot1D</code></a></li><li><a href="#Base.:&amp;-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s38&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s37&lt;:Quantica.Superlattice}"><code>Base.:&amp;</code></a></li><li><a href="#Base.:|-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s38&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s37&lt;:Quantica.Superlattice}"><code>Base.:|</code></a></li><li><a href="#Base.xor-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s38&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s37&lt;:Quantica.Superlattice}"><code>Base.xor</code></a></li><li><a href="#Quantica.averageKPM-Tuple{Any,Any}"><code>Quantica.averageKPM</code></a></li><li><a href="#Quantica.bands-Tuple{Quantica.Bandstructure}"><code>Quantica.bands</code></a></li><li><a href="#Quantica.bandstructure-Tuple"><code>Quantica.bandstructure</code></a></li><li><a href="#Quantica.bloch"><code>Quantica.bloch</code></a></li><li><a href="#Quantica.bloch!"><code>Quantica.bloch!</code></a></li><li><a href="#Quantica.bravais-Tuple{Quantica.AbstractLattice}"><code>Quantica.bravais</code></a></li><li><a href="#Quantica.combine-Tuple{Vararg{Quantica.Lattice,N} where N}"><code>Quantica.combine</code></a></li><li><a href="#Quantica.combine-Tuple{Vararg{Quantica.Hamiltonian,N} where N}"><code>Quantica.combine</code></a></li><li><a href="#Quantica.cuboid-Union{Tuple{Vararg{Tuple,L}}, Tuple{L}} where L"><code>Quantica.cuboid</code></a></li><li><a href="#Quantica.degeneracy-Tuple{Quantica.Subspace}"><code>Quantica.degeneracy</code></a></li><li><a href="#Quantica.densityKPM-Tuple{Any,Any}"><code>Quantica.densityKPM</code></a></li><li><a href="#Quantica.diagonalizer-Tuple{Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian}}"><code>Quantica.diagonalizer</code></a></li><li><a href="#Quantica.dims-Union{Tuple{Quantica.AbstractLattice{E,L,T} where T}, Tuple{L}, Tuple{E}} where L where E"><code>Quantica.dims</code></a></li><li><a href="#Quantica.dosKPM-Tuple{Any}"><code>Quantica.dosKPM</code></a></li><li><a href="#Quantica.flatten-Tuple{}"><code>Quantica.flatten</code></a></li><li><a href="#Quantica.greens-Union{Tuple{L}, Tuple{Quantica.Hamiltonian{#s39,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where #s39,Any}} where L"><code>Quantica.greens</code></a></li><li><a href="#Quantica.hamiltonian-Tuple{Quantica.AbstractLattice,Vararg{Any,N} where N}"><code>Quantica.hamiltonian</code></a></li><li><a href="#Quantica.hopping-Tuple{Any}"><code>Quantica.hopping</code></a></li><li><a href="#Quantica.hopselector-Tuple{}"><code>Quantica.hopselector</code></a></li><li><a href="#Quantica.ket-Tuple{Any}"><code>Quantica.ket</code></a></li><li><a href="#Quantica.lattice-Tuple{Vararg{Quantica.Sublat,N} where N}"><code>Quantica.lattice</code></a></li><li><a href="#Quantica.momentaKPM"><code>Quantica.momentaKPM</code></a></li><li><a href="#Quantica.not-Tuple{Any}"><code>Quantica.not</code></a></li><li><a href="#Quantica.nrange-Tuple{Int64}"><code>Quantica.nrange</code></a></li><li><a href="#Quantica.offdiagonal-Tuple{Quantica.TightbindingModel,Any,Any}"><code>Quantica.offdiagonal</code></a></li><li><a href="#Quantica.onsite-Tuple{Any}"><code>Quantica.onsite</code></a></li><li><a href="#Quantica.orbitalstructure-Tuple{Quantica.Hamiltonian}"><code>Quantica.orbitalstructure</code></a></li><li><a href="#Quantica.parameters-Tuple{Vararg{Quantica.ElementModifier,N} where N}"><code>Quantica.parameters</code></a></li><li><a href="#Quantica.parameters-Tuple{Quantica.ParametricHamiltonian}"><code>Quantica.parameters</code></a></li><li><a href="#Quantica.parametric-Tuple{Quantica.Hamiltonian,Vararg{Quantica.ElementModifier,N} where N}"><code>Quantica.parametric</code></a></li><li><a href="#Quantica.randomkets"><code>Quantica.randomkets</code></a></li><li><a href="#Quantica.similarmatrix"><code>Quantica.similarmatrix</code></a></li><li><a href="#Quantica.siteindices-Tuple{Quantica.AbstractLattice}"><code>Quantica.siteindices</code></a></li><li><a href="#Quantica.sitepositions-Tuple{Quantica.AbstractLattice}"><code>Quantica.sitepositions</code></a></li><li><a href="#Quantica.siteselector-Tuple{}"><code>Quantica.siteselector</code></a></li><li><a href="#Quantica.spectrum-Tuple{Any}"><code>Quantica.spectrum</code></a></li><li><a href="#Quantica.splitbands-Tuple{Quantica.Bandstructure}"><code>Quantica.splitbands</code></a></li><li><a href="#Quantica.sublat-Tuple{AbstractArray{#s36,1} where #s36&lt;:(StaticArrays.SArray{Tuple{S},T,1,S} where T where S)}"><code>Quantica.sublat</code></a></li><li><a href="#Quantica.supercell-Tuple"><code>Quantica.supercell</code></a></li><li><a href="#Quantica.transform!-Tuple{Any,Quantica.Hamiltonian}"><code>Quantica.transform!</code></a></li><li><a href="#Quantica.transform!-Tuple{Any,Quantica.Spectrum}"><code>Quantica.transform!</code></a></li><li><a href="#Quantica.transform!-Tuple{Function}"><code>Quantica.transform!</code></a></li><li><a href="#Quantica.transform!-Tuple{Any,Quantica.Bandstructure}"><code>Quantica.transform!</code></a></li><li><a href="#Quantica.unflatten-Union{Tuple{T}, Tuple{AbstractArray{T,1} where T,Quantica.OrbitalStructure{T,N,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N}} where N}} where T"><code>Quantica.unflatten</code></a></li><li><a href="#Quantica.unitcell-Tuple{Vararg{Union{Integer, Tuple, StaticArrays.SArray{Tuple{S},T,1,S} where T where S, StaticArrays.SArray{Tuple{S1,S2},T,2,L} where L where T where S2 where S1},N} where N}"><code>Quantica.unitcell</code></a></li><li><a href="#Quantica.vertices-Tuple{Quantica.Bandstructure,Any}"><code>Quantica.vertices</code></a></li><li><a href="#Quantica.wrap-Tuple{Quantica.Hamiltonian,Int64}"><code>Quantica.wrap</code></a></li><li><a href="#Quantica.@hopping!-Tuple{Any,Any}"><code>Quantica.@hopping!</code></a></li><li><a href="#Quantica.@onsite!-Tuple{Any,Any}"><code>Quantica.@onsite!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Quantica.Quantica" href="#Quantica.Quantica"><code>Quantica.Quantica</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>Quantica.jl</strong></p><p><a href="https://pablosanjose.github.io/Quantica.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt="Stable"/></a> <a href="https://pablosanjose.github.io/Quantica.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt="Dev"/></a> <a href="https://github.com/pablosanjose/Quantica.jl/actions"><img src="https://github.com/pablosanjose/Quantica.jl/workflows/CI/badge.svg" alt="Build Status"/></a> <a href="https://codecov.io/gh/pablosanjose/Quantica.jl"><img src="https://codecov.io/gh/pablosanjose/Quantica.jl/branch/master/graph/badge.svg" alt="Coverage"/></a> <a href="https://github.com/pablosanjose/Quantica.jl"><img src="https://img.shields.io/github/commits-since/pablosanjose/Quantica.jl/latest?include_prereleases&amp;sort=semver&amp;style=social" alt="GitHub commits since last release"/></a></p><p>The Quantica.jl package provides an expressive API to build arbitrary quantum systems on a discrete lattice, and to compute a number of their properties.</p><p><strong>Some current features</strong></p><ul><li>Build Hamiltonians on discrete lattices of arbitrary dimensions, using tight-binding models with arbitrary number of orbitals</li><li>Compute band structures of periodic systems and extract individual bands by interpolation</li><li>Compute electronic structures and expectation values using Kernel Polynomial methods</li></ul><p><strong>Exported API</strong></p><ul><li><code>lattice</code>, <code>sublat</code>: build lattices</li><li><code>hopping</code>, <code>onsite</code>, <code>siteselector</code>, <code>hopselector</code>, <code>nrange</code>, <code>not</code>: build tightbinding models</li><li><code>hamiltonian</code>: build a Hamiltonian from tightbinding model and a lattice</li><li><code>bloch</code>, <code>bloch!</code>, <code>similarmatrix</code>: build the Bloch matrix of a Hamiltonian</li><li><code>parametric</code>, <code>@onsite!</code>, <code>@hopping!</code>, <code>parameters</code>: build a parametric Hamiltonian</li><li><code>dims</code>, <code>sitepositions</code>, <code>siteindices</code>, <code>bravais</code>: inspect lattices and Hamiltonians</li><li><code>supercell</code>, <code>unitcell</code>, <code>wrap</code>, <code>transform!</code>, <code>combine</code>: build derived lattices or Hamiltonians</li><li><code>flatten</code>, <code>unflatten</code>, <code>orbitalstructure</code>: operate with multiorbital Hamiltonian or Subspaces</li><li><code>cuboid</code>: build a bandstructure discretization mesh</li><li><code>bandstructure</code>, <code>spectrum</code>, <code>diagonalizer</code>: compute the generalized bandstructure of a Hamiltonian or a ParametricHamiltonian</li><li><code>bands</code>, <code>energies</code>, <code>states</code>: inspect spectrum and bandstructure objects</li><li><code>momentaKPM</code>, <code>dosKPM</code>, <code>averageKPM</code>, <code>densityKPM</code>, <code>bandrangeKPM</code>: Kernel Polynomial Method (KPM)</li><li><code>ket</code>, <code>randomkets</code>: define ket models for use in e.g. KPM routines</li><li><code>greens</code>, <code>greensolver</code>: build Green&#39;s functions of a Hamiltonian</li></ul><p>Some of this functionality require loading one or more third-party packages, which include the following:</p><ul><li>KPM: <code>FFTW</code>, <code>ArnoldiMethod</code></li><li>Bandstructures: <code>Arpack</code>, <code>ArnoldiMethod</code>, <code>KrylovKit</code></li></ul><p>The user is told when this is needed. We do this to reduce dependencies and launch time with packages whose functionality is not essential for the use of Quantica.jl</p><p>Other functions become available after loading specific third-party packages:</p><ul><li>Makie: enables <code>plot(::Hamiltonian)</code> and <code>plot(::Bandstructure)</code> (for 1D and 2D bandstructures)</li><li>VegaLite: enables <code>vlplot(::Hamiltonian)</code> and <code>vlplot(::Bandstructure)</code> (for 1D bandstructures)</li></ul><p><strong>Funding</strong></p><pre><code class="language-none">This work has been partly funded by the Spanish Ministry of Economy and Competitiveness under Grant Nos. FIS2015-65706-P, PCI2018-093026, and the CSIC Intramural Project 201760I086.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/Quantica.jl#LL4-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Matrix-Tuple{Quantica.KetModel,Quantica.Hamiltonian}" href="#Base.Matrix-Tuple{Quantica.KetModel,Quantica.Hamiltonian}"><code>Base.Matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Matrix(km::KetModel, h::Hamiltonian)   Matrix(kms::NTuple{N,KetModel}, h::Hamiltonian)   Matrix(kms::AbstractMatrix, h::Hamiltonian)   Matrix(kms::StochasticTraceKets, h::Hamiltonian)</p><p>Construct an <code>M×N</code> <code>Matrix</code> representation of the <code>N</code> kets <code>kms</code> applied to <code>M×M</code> Hamiltonian <code>h</code>. If <code>kms::StochasticTraceKets</code> for <code>n</code> random kets (constructed with <code>randomkets(n)</code>), a normalization <code>1/√n</code> required for stochastic traces is included.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/hamiltonian.jl#LL1295-L1304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Vector-Tuple{Quantica.KetModel,Quantica.Hamiltonian}" href="#Base.Vector-Tuple{Quantica.KetModel,Quantica.Hamiltonian}"><code>Base.Vector</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Vector(km::KetModel, h::Hamiltonian)</p><p>Construct a <code>Vector</code> representation of <code>km</code> applied to Hamiltonian <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/hamiltonian.jl#LL1288-L1292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.BoxIterator" href="#Quantica.BoxIterator"><code>Quantica.BoxIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BoxIterator(seed::SVector{N,Int}; maxiterations = missing)</code></pre><p>Cartesian iterator <code>iter</code> over <code>SVector{N,Int}</code>s (<code>cell</code>s) that starts at <code>seed</code> and grows outwards in the form of a box of increasing sides (not necesarily equal) until it encompasses a certain N-dimensional region. To signal that a cell is in the desired region the user calls <code>acceptcell!(iter, cell)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/iterators.jl#LL5-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.SingleShot1D" href="#Quantica.SingleShot1D"><code>Quantica.SingleShot1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SingleShot1D(; direct = false)</code></pre><p>Return a Greens function solver using the generalized eigenvalue approach, whereby given the energy <code>ω</code>, the eigenmodes of the infinite 1D Hamiltonian, and the corresponding infinite and semi-infinite Greens function can be computed by solving the generalized eigenvalue equation</p><pre><code class="language-none">A⋅φχ = λ B⋅φχ
A = [0 I; V ω-H0]
B = [I 0; 0 V&#39;]</code></pre><p>This is the matrix form of the problem <code>λ(ω-H0)φ - Vφ - λ²V&#39;φ = 0</code>, where <code>φχ = [φ; λφ]</code>, and <code>φ</code> are <code>ω</code>-energy eigenmodes, with (possibly complex) momentum <code>q</code>, and eigenvalues are <code>λ = exp(-iqa₀)</code>. The algorithm assumes the Hamiltonian has only <code>dn = (0,)</code> and <code>dn = (±1, )</code> Bloch harmonics (<code>H0</code>, <code>V</code> and <code>V&#39;</code>), so its unit cell will be enlarged before applying the solver if needed. Bound states in the spectrum will yield delta functions in the density of states that can be resolved by adding a broadening in the form of a small positive imaginary part to <code>ω</code>.</p><p>To avoid singular solutions <code>λ=0,∞</code>, the nullspace of <code>V</code> is projected out of the problem. This produces a new <code>A´</code> and <code>B´</code> with reduced dimensions. <code>B´</code> can often be inverted, turning this into a standard eigenvalue problem, which is slightly faster to solve. This is achieved with <code>direct = true</code>. However, <code>B´</code> sometimes is still non-invertible for some values of <code>ω</code>. In this case use <code>direct = false</code> (the default).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LinearAlgebra

julia&gt; h = LP.honeycomb() |&gt; hamiltonian(hopping(1)) |&gt; unitcell((1,-1), (10,10)) |&gt; Quantica.wrap(2);

julia&gt; g = greens(h, SingleShot1D(), boundaries = (0,))
GreensFunction{SingleShot1DGreensSolver}: Green&#39;s function using the single-shot 1D method
  Matrix size    : 40 × 40
  Reduced size   : 20 × 20
  Element type   : scalar (ComplexF64)
  Boundaries     : (0,)

julia&gt; tr(g(0.3))
-32.193416068730684 - 3.4399800712973074im</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`greens`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/greens.jl#LL92-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&amp;-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s38&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s37&lt;:Quantica.Superlattice}" href="#Base.:&amp;-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s38&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s37&lt;:Quantica.Superlattice}"><code>Base.:&amp;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">&amp;(h1::Hamiltonian{&lt;:Superlattice}, h2::Hamiltonian{&lt;:Superlattice})</code></pre><p>Construct a new <code>Hamiltonian{&lt;:Superlattice}</code> using an <code>and</code> boolean mask, i.e. with a supercell that contains cells that are both in the supercell of <code>h1</code> and <code>h2</code></p><pre><code class="language-none">&amp;(s1::Superlattice, s2::Superlattice}</code></pre><p>Equivalent of the above for <code>Superlattice</code>s</p><p><strong>See also</strong></p><pre><code class="language-none">`|`, `xor`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/hamiltonian.jl#LL960-L972">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:|-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s38&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s37&lt;:Quantica.Superlattice}" href="#Base.:|-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s38&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s37&lt;:Quantica.Superlattice}"><code>Base.:|</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">|(h1::Hamiltonian{&lt;:Superlattice}, h2::Hamiltonian{&lt;:Superlattice})</code></pre><p>Construct a new <code>Hamiltonian{&lt;:Superlattice}</code> using an <code>or</code> boolean mask, i.e. with a supercell that contains cells that are either in the supercell of <code>h1</code> or <code>h2</code></p><pre><code class="language-none">|(s1::Superlattice, s2::Superlattice}</code></pre><p>Equivalent of the above for <code>Superlattice</code>s</p><p><strong>See also</strong></p><pre><code class="language-none">`&amp;`, `xor`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/hamiltonian.jl#LL976-L988">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.xor-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s38&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s37&lt;:Quantica.Superlattice}" href="#Base.xor-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s38&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s37&lt;:Quantica.Superlattice}"><code>Base.xor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">xor(h1::Hamiltonian{&lt;:Superlattice}, h2::Hamiltonian{&lt;:Superlattice})</code></pre><p>Construct a new <code>Hamiltonian{&lt;:Superlattice}</code> using a <code>xor</code> boolean mask, i.e. with a supercell that contains cells that are either in the supercell of <code>h1</code> or <code>h2</code> but not in both</p><pre><code class="language-none">xor(s1::Superlattice, s2::Superlattice}</code></pre><p>Equivalent of the above for <code>Superlattice</code>s</p><p><strong>See also</strong></p><pre><code class="language-none">`&amp;`, `|`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/hamiltonian.jl#LL992-L1005">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.averageKPM-Tuple{Any,Any}" href="#Quantica.averageKPM-Tuple{Any,Any}"><code>Quantica.averageKPM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">averageKPM(h::Hamiltonian, A; kBT = 0, Ef = 0, kw...)</code></pre><p>Compute, using the Kernel Polynomial Method (KPM), the thermal expectation value <code>&lt;A&gt; = Σ_k f(E_k) &lt;k|A|k&gt; = ∫dE f(E) Tr [A δ(E-H)] = Tr [A f(H)]</code> for a given hermitian operator <code>A</code> and a zero-dimensional hamiltonian <code>h</code> (see <code>momentaKPM</code> and its options <code>kw</code> for further details). <code>f(E)</code> is the Fermi-Dirac distribution function, <code>|k⟩</code> are <code>h</code> eigenstates with energy <code>E_k</code>, kBT<code>is the temperature in energy units and</code>Ef` the Fermi energy.</p><pre><code class="language-none">averageKPM(μ::MomentaKPM, A; kBT = 0, Ef = 0)</code></pre><p>Same as above with the KPM momenta as input (see <code>momentaKPM</code>).</p><p><strong>See also</strong></p><pre><code class="language-none">`dosKPM`, `momentaKPM`, `averageKPM`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/KPM.jl#LL285-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.bands-Tuple{Quantica.Bandstructure}" href="#Quantica.bands-Tuple{Quantica.Bandstructure}"><code>Quantica.bands</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bands(bs::Bandstructure[, i])</code></pre><p>Return a <code>bands::Vector{Band}</code> of all the bands in <code>bs</code>, or <code>bands[i]</code> if <code>i</code> is given.</p><p><strong>See also</strong></p><pre><code class="language-none">`bandstructure`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/bandstructure.jl#LL251-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.bandstructure-Tuple" href="#Quantica.bandstructure-Tuple"><code>Quantica.bandstructure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bandstructure(h::Hamiltonian; subticks = 13, kw...)</code></pre><p>Compute <code>bandstructure(h, cuboid((-π,π)...; subticks = subticks); kw...)</code> using a base mesh (of type <code>CuboidMesh</code>) over <code>h</code>&#39;s full Brillouin zone with the specified <code>subticks</code> along each [-π,π] reciprocal axis.</p><pre><code class="language-none">bandstructure(h::Hamiltonian, nodes...; subticks = 13, kw...)</code></pre><p>Create a linecut of a bandstructure of <code>h</code> along a polygonal line connecting two or more <code>nodes</code>. Each node is either a <code>Tuple</code> or <code>SVector</code> of Bloch phases, or a symbolic name for a Brillouin zone point (<code>:Γ</code>,<code>:K</code>, <code>:K´</code>, <code>:M</code>, <code>:X</code>, <code>:Y</code> or <code>:Z</code>). Each segment in the polygon has the specified number of <code>subticks</code>. Different <code>subticks</code> per segments can be specified with <code>subticks = (p1, p2...)</code>.</p><pre><code class="language-none">bandstructure(h::Hamiltonian, mesh::CuboidMesh; mapping = missing, kw...)</code></pre><p>Compute the bandstructure <code>bandstructure(h, mesh; kw...)</code> of Bloch Hamiltonian <code>bloch(h, ϕ)</code>, with <code>ϕ = v</code> taken on each vertex <code>v</code> of the base <code>mesh</code> (or <code>ϕ = mapping(v...)</code> if a <code>mapping</code> function is provided).</p><pre><code class="language-none">bandstructure(ph::ParametricHamiltonian, ...; kw...)</code></pre><p>Compute the bandstructure of a <code>ph</code>. Unless all parameters have default values, a <code>mapping</code> is required between mesh vertices and Bloch/parameters for <code>ph</code>, see details on <code>mapping</code> below.</p><pre><code class="language-none">bandstructure(matrixf::Function, mesh::CuboidMesh; kw...)</code></pre><p>Compute the bandstructure of the Hamiltonian matrix <code>m = matrixf(ϕ)</code>, with <code>ϕ</code> evaluated on the vertices <code>v</code> of the <code>mesh</code>. Note that <code>ϕ</code> in <code>matrixf(ϕ)</code> is an unsplatted container. Hence, i.e. <code>matrixf(x) = ...</code> or <code>matrixf(x, y) = ...</code> will not work. Use <code>matrixf((x,)) = ...</code>, <code>matrixf((x, y)) = ...</code> or matrixf(s::SVector) = ...` instead.</p><pre><code class="language-none">h |&gt; bandstructure([mesh,]; kw...)</code></pre><p>Curried form of the above equivalent to <code>bandstructure(h[, mesh]; kw...)</code>.</p><p><strong>Options</strong></p><p>The default options are</p><pre><code class="language-none">(mapping = missing, method = LinearAlgebraPackage(), transform = missing, splitbands = true, showprogress = true)</code></pre><p><code>mapping</code>: when not <code>missing</code>, <code>mapping = v -&gt; p</code> is a function that map base mesh vertices <code>v</code> to Bloch phases and/or parameters <code>p</code>. The structure of <code>p</code> is whatever is accepted by <code>bloch(h, p, ...)</code> (see <code>bloch</code>). For <code>h::Hamiltonian</code>, <code>p = ϕs::Union{Tuple,SVector}</code> are Bloch phases. For <code>h::ParametricHamiltonian</code>, <code>p = (ϕs..., (; ps))</code> or <code>p = (ϕs, (; ps))</code> combine Bloch phases <code>ϕs</code> and keyword parameters <code>ps</code> of <code>ph</code>. This allows to compute a bandstructure along a cut in the Brillouin zone/parameter space of <code>ph</code>, see examples below.</p><p><code>method</code>: it is chosen automatically if unspecified, and can be one of the following</p><pre><code class="language-none">method                     diagonalization function
--------------------------------------------------------------
LinearAlgebraPackage()     LinearAlgebra.eigen!
ArpackPackage()            Arpack.eigs (must be `using Arpack`)</code></pre><p>Options passed to the <code>method</code> will be forwarded to the diagonalization function. For example, <code>method = ArpackPackage(nev = 8, sigma = 1im)</code> will use <code>Arpack.eigs(matrix; nev = 8, sigma = 1im)</code> to compute the bandstructure.</p><p><code>transform</code>: the option <code>transform = ε -&gt; fε(ε)</code> allows to transform eigenvalues by <code>fε</code> in the returned bandstructure (useful for performing shifts or other postprocessing). We can also do <code>transform -&gt; (fφ, fε)</code> to transform also mesh vertices with fφ. Additionally, <code>transform -&gt; isometric</code> or <code>transform -&gt; (isometric, fε)</code> will transform mesh vertices into momenta, assuming they represent Bloch phases. This works both in full bandstructures and linecuts.</p><p><code>splitbands</code>: split all bands into disconnected subbands. See also <code>splitbands!</code></p><p><code>showprogress</code>: indicate whether progress bars are displayed during the calculation</p><p><strong>Indexing</strong></p><p>The bands in a <code>bs::Bandstructure</code> object can be accessed with <code>bands</code>, while the indexing syntax <code>bs[(φs...)]</code> gives access to one or more <code>sub::Subspace</code> objects, contructed by linear interpolation of each band at base-mesh coordinates <code>φs</code>.</p><pre><code class="language-none">bs[(φs...), 1]                  : first interpolated subspaces at base mesh coordinates `φs`, ordered by energy
bs[(φs...), 1:3]                : interpolated subspaces 1 to 3 at base mesh coordinates `φs`, ordered by energy
bs[(φs...)]                     : interpolated subspaces at base mesh coordinates `φs` in any band
bs[(φs...), around = 0.2]       : the single interpolated subspaces at `φs` with energies closest to 0.2
bs[(φs...), around = (0.2, 10)] : the ten interpolated subspaces at `φs` with energies closest to 0.2</code></pre><p>The eigenenergy <code>ε</code> and subspace basis <code>ψs</code> of a <code>sub::Subspace</code> can themselves be obtained via destructuring, <code>ε, ψs = sub</code>, or <code>ε = first(sub), ψs = last(sub)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; h = LatticePresets.honeycomb() |&gt; hamiltonian(hopping(-1)) |&gt; unitcell(3);

julia&gt; bandstructure(h; subticks = 25, method = LinearAlgebraPackage())
Bandstructure{2}: collection of 2D bands
  Bands        : 8
  Element type : scalar (Complex{Float64})
  Band{2}: mesh of a 2-dimensional manifold
    Vertices   : 625
    Edges      : 1776

julia&gt; bandstructure(h, :Γ, :X, :Y, :Γ; subticks = (10,15,10))
Bandstructure{2}: collection of 1D bands
  Bands        : 18
  Element type : scalar (Complex{Float64})
  Band{1}: mesh of a 1-dimensional manifold
    Vertices   : 33
    Edges      : 32

julia&gt; bandstructure(h, mesh((0, 2π); subticks = 13); mapping = φ -&gt; (φ, 0))
       # Equivalent to bandstructure(h, :Γ, :X; subticks = 13)
Bandstructure{2}: collection of 1D bands
  Bands        : 18
  Element type : scalar (Complex{Float64})
  Band{1}: mesh of a 1-dimensional manifold
    Vertices   : 11
    Edges      : 10

julia&gt; ph = parametric(h, @hopping!((t; α) -&gt; t * α));

julia&gt; bandstructure(ph, mesh((0, 2π); subticks = 13); mapping = φ -&gt; (φ, 0, (; α = 2φ)))
Bandstructure{2}: collection of 1D bands
  Bands        : 18
  Element type : scalar (Complex{Float64})
  Band{1}: mesh of a 1-dimensional manifold
    Vertices   : 11
    Edges      : 10</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`cuboid`, `diagonalizer`, `bloch`, `parametric`, `splitbands!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/bandstructure.jl#LL353-L483">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.bloch" href="#Quantica.bloch"><code>Quantica.bloch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bloch(h::Hamiltonian{&lt;:Lattice}, ϕs)</code></pre><p>Build the Bloch Hamiltonian matrix of <code>h</code>, for Bloch phases <code>ϕs = (ϕ₁, ϕ₂,...)</code> (or an <code>SVector(ϕs...)</code>). In terms of Bloch wavevector <code>k</code>, <code>ϕs = k * bravais(h)</code>, it is defined as <code>H(ϕs) = ∑exp(-im * ϕs&#39; * dn) h_dn</code> where <code>h_dn</code> are Bloch harmonics connecting unit cells at a distance <code>dR = bravais(h) * dn</code>.</p><pre><code class="language-none">bloch(h::Hamiltonian{&lt;:Lattice})</code></pre><p>Build the intra-cell Hamiltonian matrix of <code>h</code>, without adding any Bloch harmonics.</p><pre><code class="language-none">bloch(h::Hamiltonian{&lt;:Lattice}, ϕs, axis::Int)</code></pre><p>A nonzero <code>axis</code> produces the derivative of the Bloch matrix respect to <code>ϕs[axis]</code> (i.e. the velocity operator along this axis), <code>∂H(ϕs) = ∑ -im * dn[axis] * exp(-im * ϕs&#39; * dn) h_dn</code></p><pre><code class="language-none">bloch(matrix, h::Hamiltonian{&lt;:Lattice}, ϕs::NTuple{L,Real}, dnfunc::Function)</code></pre><p>Generalization that applies a prefactor <code>dnfunc(dn) * exp(im * ϕs&#39; * dn)</code> to the <code>dn</code> harmonic.</p><pre><code class="language-none">bloch(ph::ParametricHamiltonian, [pϕs, [axis]])</code></pre><p>Build the Bloch matrix for <code>ph</code>. <code>pϕs = (ϕs, (;kw...))</code> or <code>pϕs = (ϕs..., (;kw...))</code> specifies both Bloch phases <code>ϕs</code> and the parameters <code>kw</code> passed to <code>ph(; kw...)</code>. If there are no <code>ϕs</code>, the syntax <code>pϕs = (;kw...)</code> is also allowed, which is in that case equivalent to <code>bloch(ph(; kw...))</code>. Similarly, <code>bloch(ph)</code> is equivalent to <code>bloch(ph())</code>.</p><pre><code class="language-none">h |&gt; bloch(ϕs, ...)
ph |&gt; bloch(pϕs, ...)</code></pre><p>Curried forms of <code>bloch</code>, equivalent to <code>bloch(h, ϕs, ...)</code> and <code>bloch(ph, pϕs, ...)</code></p><p><strong>Notes</strong></p><p><code>bloch</code> allocates a new matrix on each call. For a non-allocating version of <code>bloch</code>, see <code>bloch!</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; h = LatticePresets.honeycomb() |&gt; hamiltonian(onsite(1) + hopping(2)) |&gt; bloch((0, 0))
2×2 SparseMatrixCSC{Complex{Float64},Int64} with 4 stored entries:
  [1, 1]  =  1.0+0.0im
  [2, 1]  =  6.0+0.0im
  [1, 2]  =  6.0+0.0im
  [2, 2]  =  1.0+0.0im</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`bloch!`, `similarmatrix`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/hamiltonian.jl#LL1634-L1686">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.bloch!" href="#Quantica.bloch!"><code>Quantica.bloch!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bloch!(matrix, h::Hamiltonian, [ϕs, [axis]])</code></pre><p>In-place version of <code>bloch</code>. Overwrite <code>matrix</code> with the Bloch Hamiltonian matrix of <code>h</code> for the specified Bloch phases <code>ϕs = (ϕ₁,ϕ₂,...)</code> (see <code>bloch</code> for definition and API). A conventient way to obtain a <code>matrix</code> is to use <code>similarmatrix(h,matrix_type)</code>, which will return an <code>AbstractMatrix</code> of the same type as the Hamiltonian&#39;s. Note, however, that matrix need not be of the same type (e.g. it can be dense with <code>Number</code> eltype for a sparse <code>h</code> with <code>SMatrix</code> block eltype).</p><pre><code class="language-none">bloch!(matrix, ph::ParametricHamiltonian, [pϕs, [axis]])</code></pre><p>Same as above but with <code>pϕs = (ϕs, (;kw...))</code>, <code>pϕs = (ϕs..., (;kw...))</code> or <code>pϕs = (;kw...)</code> (see <code>bloch</code> for details).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; h = LatticePresets.honeycomb() |&gt; hamiltonian(hopping(2I), orbitals = (Val(2), Val(1)));

julia&gt; bloch!(similarmatrix(h), h, (0, 0))
2×2 SparseMatrixCSC{StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4},Int64} with 2 stored entries:
  [2, 1]  =  [6.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]
  [1, 2]  =  [6.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]

julia&gt; bloch!(similarmatrix(h, flatten), h, (0, 0))
3×3 SparseMatrixCSC{Complex{Float64},Int64} with 9 stored entries:
  [1, 1]  =  0.0+0.0im
  [2, 1]  =  0.0+0.0im
  [3, 1]  =  6.0+0.0im
  [1, 2]  =  0.0+0.0im
  [2, 2]  =  0.0+0.0im
  [3, 2]  =  0.0+0.0im
  [1, 3]  =  6.0+0.0im
  [2, 3]  =  0.0+0.0im
  [3, 3]  =  0.0+0.0im

julia&gt; ph = parametric(h, @hopping!((t; α, β = 0) -&gt; α * t + β));

julia&gt; bloch!(similarmatrix(ph, flatten), ph, (0, 0, (; α = 2)))
3×3 SparseMatrixCSC{Complex{Float64},Int64} with 9 stored entries:
  [1, 1]  =  0.0+0.0im
  [2, 1]  =  0.0+0.0im
  [3, 1]  =  12.0+0.0im
  [1, 2]  =  0.0+0.0im
  [2, 2]  =  0.0+0.0im
  [3, 2]  =  0.0+0.0im
  [1, 3]  =  12.0+0.0im
  [2, 3]  =  0.0+0.0im
  [3, 3]  =  0.0+0.0im</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`bloch`, `similarmatrix`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/hamiltonian.jl#LL1690-L1744">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.bravais-Tuple{Quantica.AbstractLattice}" href="#Quantica.bravais-Tuple{Quantica.AbstractLattice}"><code>Quantica.bravais</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bravais(lat::Lattice)
bravais(h::Hamiltonian)</code></pre><p>Obtain the Bravais matrix of lattice <code>lat</code> or Hamiltonian <code>h</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; bravais((1.0, 2), (3, 4))
Bravais{2,2,Float64} : set of 2 Bravais vectors in 2D space.
  Vectors     : ((1.0, 2.0), (3.0, 4.0))
  Matrix      : [1.0 3.0; 2.0 4.0]</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`lattice`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/lattice.jl#LL153-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.combine-Tuple{Vararg{Quantica.Hamiltonian,N} where N}" href="#Quantica.combine-Tuple{Vararg{Quantica.Hamiltonian,N} where N}"><code>Quantica.combine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">combine(hams::Hamiltonian...; coupling = missing)</code></pre><p>Build a new Hamiltonian <code>h</code> that combines all <code>hams</code> as diagonal blocks, and applies <code>coupling::Model</code>, if provided, to build the off-diagonal couplings. Note that the diagonal blocks are not modified by the coupling model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/hamiltonian.jl#LL1610-L1616">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.combine-Tuple{Vararg{Quantica.Lattice,N} where N}" href="#Quantica.combine-Tuple{Vararg{Quantica.Lattice,N} where N}"><code>Quantica.combine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">combine(lats::Lattice...)</code></pre><p>If all <code>lats</code> have compatible Bravais vectors, combine them into a single lattice. Sublattice names are renamed to be unique if necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/lattice.jl#LL498-L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.cuboid-Union{Tuple{Vararg{Tuple,L}}, Tuple{L}} where L" href="#Quantica.cuboid-Union{Tuple{Vararg{Tuple,L}}, Tuple{L}} where L"><code>Quantica.cuboid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cuboid(ticks...; subticks = 13)</code></pre><p>Create a <code>CuboidMesh</code> of L-dimensional marching-tetrahedra over a cuboid aligned with the Cartesian axes. The dimension <code>L</code> is given by the number of <code>ticks</code>, each of the form <code>(x₁, x₂,...)</code>. The interval between <code>xⱼ</code> and <code>xⱼ₊₁</code> ticks in axis <code>i</code> are further subdivided to have a number of subticks including endpoints. The number is <code>subticks</code> if <code>subticks</code> is an <code>Integer</code>, <code>subticks[i]</code> if <code>subticks = (s₁, s₂,...)</code> or <code>subticks[i][j]</code> if <code>subticks = ((s₁₁, s₁₂,...), (s₂₁, s₂₂,...), ...)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cuboid((-π, π), (0, 2π); subticks = 25)

julia&gt; cuboid((-π, π), (0, 2π); subticks = (10, 10))</code></pre><p><strong>External links</strong></p><ul><li>Marching tetrahedra (https://en.wikipedia.org/wiki/Marching_tetrahedra) in Wikipedia</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/mesh.jl#LL18-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.degeneracy-Tuple{Quantica.Subspace}" href="#Quantica.degeneracy-Tuple{Quantica.Subspace}"><code>Quantica.degeneracy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">degeneracy(s::Subspace)</code></pre><p>Return the degeneracy of a given energy subspace. It is equal to <code>size(s.basis, 2)</code>.</p><p><strong>See also</strong></p><pre><code class="language-none">`spectrum`, `bandstructure`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/bandstructure.jl#LL28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.densityKPM-Tuple{Any,Any}" href="#Quantica.densityKPM-Tuple{Any,Any}"><code>Quantica.densityKPM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">densityKPM(h::Hamiltonian, A; resolution = 2, kets = randomkets(1), kw...)</code></pre><p>Compute, using the Kernel Polynomial Method (KPM), the spectral density of <code>A</code> for zero-dimensional Hamiltonian <code>h</code>, <code>ρ_A(ϵ) = ∑⟨ket|A δ(ϵ-h)|ket⟩/R ≈ Tr[Aδ(ϵ-h)]</code> (the sum is over <code>R</code> random <code>kets</code>). <code>A</code> can itself be a <code>Hamiltonian</code> or a <code>UniformScaling</code> <code>λ*I</code>. If <code>kets</code> are not <code>randomkets</code> but one or more <code>KetModel</code>s (see <code>ket</code>), the division by <code>R</code> is ommitted, which results in a <em>local</em> spectral density <code>ρ_A(ϵ) = ∑⟨ket|Aδ(ϵ-h)|ket⟩</code> at sites specified by <code>kets</code>.</p><p>The result is a tuple of energy points <code>xk::Vector</code> and real <code>ρ_A::Vector</code> values (unlike for <code>dosKPM</code>, all imaginary parts in <code>ρ_A</code> are preserved), where the number of energy points <code>xk</code> is <code>order * resolution</code>, rounded to the closest integer.</p><pre><code class="language-none">densityKPM(momenta::MomentaKPM; resolution = 2)</code></pre><p>Same as above with the KPM momenta as input (see <code>momentaKPM</code>).</p><p><strong>See also</strong></p><pre><code class="language-none">`dosKPM`, `momentaKPM`, `averageKPM`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/KPM.jl#LL248-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.diagonalizer-Tuple{Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian}}" href="#Quantica.diagonalizer-Tuple{Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian}}"><code>Quantica.diagonalizer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diagonalizer(h::Union{Hamiltonian,ParametricHamiltonian}; method = LinearAlgebraPackage(), mapping = missing)</code></pre><p>Build a <code>d::Diagonalizer</code> object that, when called as <code>d(φs)</code> , uses the specified diagonalization <code>method</code> to produce the sorted eigenpairs <code>(εs, ψs)</code> of <code>h</code> at Bloch phases/parameters given by <code>mapping</code>. See <code>bandstructure</code> for further details.</p><p>A 0D Hamiltonian <code>h</code> also supports <code>d = diagonalizer(h)</code>. In this case <code>d</code> can be called with no arguments and gives the same information as <code>spectrum</code>, <code>d() == Tuple(spectrum(h))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; h = LatticePresets.honeycomb() |&gt; hamiltonian(hopping(1));

julia&gt; d = diagonalizer(h)
Diagonalizer with method : LinearAlgebraPackage{NamedTuple{(),Tuple{}}}

julia&gt; d((0, 0)) |&gt; first
2-element Array{Float64,1}:
 -3.0
  3.0

julia&gt; h = wrap(h); d = diagonalizer(h);

julia&gt; d() == Tuple(spectrum(h))
true</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`bandstructure`, `spectrum`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/diagonalizer.jl#LL25-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.dims-Union{Tuple{Quantica.AbstractLattice{E,L,T} where T}, Tuple{L}, Tuple{E}} where L where E" href="#Quantica.dims-Union{Tuple{Quantica.AbstractLattice{E,L,T} where T}, Tuple{L}, Tuple{E}} where L where E"><code>Quantica.dims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dims(lh::Union{Hamiltonian,AbstractLattice}) -&gt; (E, L)</code></pre><p>Return a tuple <code>(E, L)</code> of the embedding <code>E</code> and lattice dimensions <code>L</code> of <code>AbstractLattice</code> or <code>Hamiltonian</code> <code>lh</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/hamiltonian.jl#LL692-L697">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.dosKPM-Tuple{Any}" href="#Quantica.dosKPM-Tuple{Any}"><code>Quantica.dosKPM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dosKPM(h::Hamiltonian; resolution = 2, kets = randomkets(1), kw...)</code></pre><p>Compute, using the Kernel Polynomial Method (KPM), the density of states per site of zero-dimensional Hamiltonian <code>h</code>, <code>ρ(ϵ) = ∑⟨ket|δ(ϵ-h)|ket⟩/(NR) ≈ Tr[δ(ϵ-h)]/N</code> (N is the number of sites, and the sum is over <code>R</code> random <code>kets</code>). If <code>kets</code> are not <code>randomkets</code> but one or more <code>KetModel</code>s (see <code>ket</code>), the division by <code>NR</code> is ommitted, which results in a <em>local</em> density of states <code>ρ(ϵ) = ∑⟨ket|δ(ϵ-h)|ket⟩</code> at sites specified by <code>kets</code>.</p><p>The result is a tuple of energy points <code>xk::Vector</code> and real <code>ρ::Vector</code> values (any residual imaginary part in ρ is dropped), where the number of energy points <code>xk</code> is <code>order * resolution</code>, rounded to the closest integer.</p><pre><code class="language-none">dosKPM(μ::MomentaKPM; resolution = 2)</code></pre><p>Same as above with KPM momenta <code>μ</code> as input. Equivalent to <code>densityKPM(μ; kw...)</code> except that imaginary parts are dropped.</p><p><strong>See also</strong></p><pre><code class="language-none">`momentaKPM`, `densityKPM`, `averageKPM`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/KPM.jl#LL217-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.flatten-Tuple{}" href="#Quantica.flatten-Tuple{}"><code>Quantica.flatten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flatten(h::Hamiltonian)</code></pre><p>Flatten a multiorbital Hamiltonian <code>h</code> into one with a single orbital per site. The associated lattice is flattened also, so that there is one site per orbital for each initial site (all at the same position). Note that in the case of sparse Hamiltonians, zeros in hopping/onsite matrices are preserved as structural zeros upon flattening.</p><pre><code class="language-none">flatten(s::Subspace)</code></pre><p>Rebuild <code>s</code> by flattening its basis to have a scalar eltype.</p><pre><code class="language-none">h |&gt; flatten()</code></pre><p>Curried form equivalent to <code>flatten(h)</code> of <code>h |&gt; flatten</code> (included for consistency with the rest of the API).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; h = LatticePresets.honeycomb() |&gt;
           hamiltonian(hopping(@SMatrix[1; 2], range = 1/√3, sublats = :A =&gt;:B),
           orbitals = (Val(1), Val(2)))
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)
  Harmonic size    : 2 × 2
  Orbitals         : ((:a,), (:a, :a))
  Element type     : 2 × 2 blocks (Complex{Float64})
  Onsites          : 0
  Hoppings         : 3
  Coordination     : 1.5

julia&gt; flatten(h)
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)
  Harmonic size    : 3 × 3
  Orbitals         : ((:flat,), (:flat,))
  Element type     : scalar (Complex{Float64})
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 2.0</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`unflatten`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/hamiltonian.jl#LL140-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.greens-Union{Tuple{L}, Tuple{Quantica.Hamiltonian{#s39,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where #s39,Any}} where L" href="#Quantica.greens-Union{Tuple{L}, Tuple{Quantica.Hamiltonian{#s39,L,M,A,H,O} where O&lt;:Quantica.OrbitalStructure where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where #s39,Any}} where L"><code>Quantica.greens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">greens(h::Hamiltonian, solveobject; boundaries::NTuple{L,Integer} = missing)</code></pre><p>Construct the Green&#39;s function <code>g::GreensFunction</code> of <code>L</code>-dimensional Hamiltonian <code>h</code> using the provided <code>solveobject</code>. Currently valid <code>solveobject</code>s are</p><ul><li>the <code>Bandstructure</code> of <code>h</code> (for an unbounded <code>h</code> or an <code>Hamiltonian{&lt;:Superlattice}}</code>)</li><li>the <code>Spectrum</code> of <code>h</code> (for a bounded <code>h</code>)</li><li><code>SingleShot1D(; direct = false)</code> (single-shot generalized [or direct if <code>direct = true</code>] eigenvalue approach for 1D Hamiltonians)</li></ul><p>If a <code>boundaries = (n₁, n₂, ...)</code> is provided, a reflecting boundary is assumed for each non-missing <code>nᵢ</code> perpendicular to Bravais vector <code>i</code> at a cell distance <code>nᵢ</code> from the origin.</p><pre><code class="language-none">h |&gt; greens(h -&gt; solveobject(h), args...)</code></pre><p>Curried form equivalent to the above, giving <code>greens(h, solveobject(h), args...)</code>.</p><pre><code class="language-none">g(ω, cells::Pair)</code></pre><p>From a constructed <code>g::GreensFunction</code>, obtain the retarded Green&#39;s function matrix at frequency <code>ω</code> between unit cells <code>src</code> and <code>dst</code> by calling <code>g(ω, src =&gt; dst)</code>, where <code>src, dst</code> are <code>::NTuple{L,Int}</code> or <code>SVector{L,Int}</code>. If not provided, <code>cells</code> default to <code>(1, 1, ...) =&gt; (1, 1, ...)</code>.</p><pre><code class="language-none">g(ω, missing)</code></pre><p>If allowed by the used <code>solveobject</code>, build an efficient function <code>cells -&gt; g(ω, cells)</code> that can produce the Greens function between different cells at fixed <code>ω</code> without repeating cell-independent parts of the computation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = LatticePresets.square() |&gt; hamiltonian(hopping(-1)) |&gt; greens(bandstructure(resolution = 17))
GreensFunction{Bandstructure}: Green&#39;s function from a 2D bandstructure
  Matrix size    : 1 × 1
  Element type   : scalar (Complex{Float64})
  Band simplices : 512

julia&gt; g(0.2)
1×1 Array{Complex{Float64},2}:
 6.663377810046025 - 24.472789025006396im

julia&gt; m = similarmatrix(g); g(m, 0.2)
1×1 Array{Complex{Float64},2}:
 6.663377810046025 - 24.472789025006396im</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`greens!`, `SingleShot1D`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/greens.jl#LL12-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.hamiltonian-Tuple{Quantica.AbstractLattice,Vararg{Any,N} where N}" href="#Quantica.hamiltonian-Tuple{Quantica.AbstractLattice,Vararg{Any,N} where N}"><code>Quantica.hamiltonian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hamiltonian(lat, model; orbitals, orbtype)</code></pre><p>Create a <code>Hamiltonian</code> by applying <code>model::TighbindingModel</code> to the lattice <code>lat</code> (see <code>hopping</code> and <code>onsite</code> for details on building tightbinding models).</p><pre><code class="language-none">lat |&gt; hamiltonian(model; kw...)</code></pre><p>Curried form of <code>hamiltonian</code> equivalent to <code>hamiltonian(lat, model; kw...)</code>.</p><p><strong>Keywords</strong></p><p>The number of orbitals on each sublattice can be specified by the keyword <code>orbitals</code> (otherwise all sublattices have one orbital by default). The following, and obvious combinations, are possible formats for the <code>orbitals</code> keyword:</p><pre><code class="language-none">orbitals = :a                # all sublattices have 1 orbital named :a
orbitals = (:a,)             # same as above
orbitals = (:a, :b, 3)       # all sublattices have 3 orbitals named :a and :b and :3
orbitals = ((:a, :b), (:c,)) # first sublattice has 2 orbitals, second has one
orbitals = ((:a, :b), :c)    # same as above
orbitals = (Val(2), Val(1))  # same as above, with automatic names
orbitals = (:A =&gt; (:a, :b), :D =&gt; :c) # sublattice :A has two orbitals, :D and rest have one
orbitals = :D =&gt; Val(4)      # sublattice :D has four orbitals, rest have one</code></pre><p>The matrix sizes of tightbinding <code>model</code> must match the orbitals specified. Internally, we define a block size <code>N = max(num_orbitals)</code>. If <code>N = 1</code> (all sublattices with one orbital) the Hamiltonian element type is <code>orbtype</code>. Otherwise it is <code>SMatrix{N,N,orbtype}</code> blocks, padded with the necessary zeros as required. Keyword <code>orbtype</code> is <code>Complex{T}</code> by default, where <code>T</code> is the number type of <code>lat</code>.</p><p><strong>Indexing</strong></p><p>Indexing into a Hamiltonian <code>h</code> works as follows. Access the <code>HamiltonianHarmonic</code> matrix at a given <code>dn::NTuple{L,Int}</code> with <code>h[dn]</code>. Assign <code>v</code> into element <code>(i,j)</code> of said matrix with <code>h[dn][i,j] = v</code> or <code>h[dn, i, j] = v</code>. Broadcasting with vectors of indices <code>is</code> and <code>js</code> is supported, <code>h[dn][is, js] = v_matrix</code>.</p><p>To add an empty harmonic with a given <code>dn::NTuple{L,Int}</code>, do <code>push!(h, dn)</code>. To delete it, do <code>deleteat!(h, dn)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; h = hamiltonian(LatticePresets.honeycomb(), hopping(@SMatrix[1 2; 3 4], range = 1/√3), orbitals = Val(2))
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)
  Harmonic size    : 2 × 2
  Orbitals         : ((:a, :a), (:a, :a))
  Element type     : 2 × 2 blocks (Complex{Float64})
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 3.0

julia&gt; push!(h, (3,3)) # Adding a new Hamiltonian harmonic (if not already present)
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 6 (SparseMatrixCSC, sparse)
  Harmonic size    : 2 × 2
  Orbitals         : ((:a, :a), (:a, :a))
  Element type     : 2 × 2 blocks (Complex{Float64})
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 3.0

julia&gt; h[(3,3)][1,1] = @SMatrix[1 2; 2 1]; h[(3,3)] # element assignment
2×2 SparseMatrixCSC{StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4},Int64} with 1 stored entry:
  [1, 1]  =  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]

julia&gt; h[(3,3)][[1,2],[1,2]] .= Ref(@SMatrix[1 2; 2 1])
2×2 view(::SparseMatrixCSC{StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4},Int64}, [1, 2], [1, 2]) with eltype StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4}:
 [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]
 [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`onsite`, `hopping`, `bloch`, `bloch!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/hamiltonian.jl#LL563-L639">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.hopping-Tuple{Any}" href="#Quantica.hopping-Tuple{Any}"><code>Quantica.hopping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hopping(t; range = nrange(1), dn = missing, sublats = missing, indices = missing, region = missing, plusadjoint = false)</code></pre><p>Create an <code>TightbindingModel</code> with a single <code>HoppingTerm</code> that applies a hopping <code>t</code> to a <code>Lattice</code> when creating a <code>Hamiltonian</code> with <code>hamiltonian</code>.</p><p>The hopping amplitude <code>t</code> can be a number, an <code>SMatrix</code>, a <code>UniformScaling</code> (e.g. <code>3*I</code>) or a function of the form <code>(r, dr) -&gt; ...</code> for a position-dependent hopping (<code>r</code> is the bond center, and <code>dr</code> the bond vector). If <code>sublats</code> is specified as a sublattice name pair, or tuple thereof, <code>hopping</code> is only applied between sublattices with said names.</p><p>The dimension of <code>t::AbstractMatrix</code> must match the orbital dimension of applicable sublattices (see also <code>orbitals</code> option for <code>hamiltonian</code>). If <code>t::UniformScaling</code> it will be converted to a (possibly rectangular) identity matrix of the appropriate size when applied to multiorbital sublattices. Similarly, if <code>t::SMatrix</code> it will be truncated or padded to the appropriate size.</p><p><code>OnsiteTerm</code>s and <code>HoppingTerm</code>s created with <code>onsite</code> or <code>hopping</code> can be added or substracted together to build more complicated <code>TightbindingModel</code>s.</p><pre><code class="language-none">hopping(model::TightbindingModel; kw...)</code></pre><p>Return a <code>TightbindingModel</code> with only the hopping terms of <code>model</code>. Any non-missing <code>kw</code> is applied to all such terms.</p><p><strong>Keyword arguments</strong></p><p>Most keywords are the same as for <code>hopselector</code>. Only hoppings between two sites at positions <code>r₁ = r - dr/2</code> and <code>r₂ = r + dr</code>, belonging to unit cells at integer distance <code>dn´</code> and to sublattices <code>s₁</code> and <code>s₂</code> will be selected if: <code>region(r, dr) &amp;&amp; s in sublats &amp;&amp; dn´ in dn &amp;&amp; norm(dr) &lt;= range</code>. If any of these is <code>missing</code> it will not be used to constraint the selection.</p><p>The keyword <code>range</code> admits the following possibilities</p><pre><code class="language-none">max_range                   # i.e. `norm(dr) &lt;= max_range`
(min_range, max_range)      # i.e. `min_range &lt;= norm(dr) &lt;= max_range`</code></pre><p>Both <code>max_range</code> and <code>min_range</code> can be a <code>Real</code> or a <code>NeighborRange</code> created with <code>nrange(n)</code>. The latter represents the distance of <code>n</code>-th nearest neighbors. Note that the <code>range</code> default for <code>hopping</code> (unlike for the more general <code>hopselector</code>) is <code>nrange(1)</code>, i.e. first-nearest-neighbors.</p><p>The keyword <code>dn</code> can be a <code>Tuple</code>/<code>Vector</code>/<code>SVector</code> of <code>Int</code>s, or a tuple thereof. The keyword <code>sublats</code> allows the following formats:</p><pre><code class="language-none">sublats = :A =&gt; :B                 # Hopping from :A to :B sublattices
sublats = (:A =&gt; :B,)              # Same as above
sublats = (:A =&gt; :B, :C =&gt; :D)     # Hopping from :A to :B or :C to :D
sublats = (:A, :C) .=&gt; (:B, :D)    # Broadcasted pairs, same as above
sublats = (:A, :C) =&gt; (:B, :D)     # Direct product, (:A=&gt;:B, :A=:D, :C=&gt;:B, :C=&gt;D)</code></pre><p>The keyword <code>plusadjoint</code> produces a model with the input hopping term plus its adjoint. Note that this substitution is made before multiplying by any coefficient, so that <code>im*hopping(..., plusadjoint = true) == im*(hopping(...) + hopping(...)&#39;)</code>.</p><p><strong>Combining models</strong></p><p><code>OnsiteTerm</code>s and <code>HoppingTerm</code>s created with <code>onsite</code> or <code>hopping</code> can added or substracted together or be multiplied by scalars to build more complicated <code>TightbindingModel</code>s, e.g. <code>onsite(1) - 3 * hopping(2)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; model = 3 * onsite(1) - hopping(2, dn = ((1,2), (0,0)), sublats = :A=&gt;:B)
TightbindingModel{2}: model with 2 terms
  OnsiteTerm{Int64}:
    Sublattices      : any
    Coefficient      : 3
  HoppingTerm{Int64}:
    Sublattice pairs : (:A =&gt; :B,)
    dn cell distance : ([1, 2], [0, 0])
    Hopping range    : 1.0
    Coefficient      : -1

julia&gt; newmodel = onsite(model) + hopping(model, range = 2)
TightbindingModel{2}: model with 2 terms
  OnsiteTerm{Int64}:
    Sublattices      : any
    Coefficient      : 3
  HoppingTerm{Int64}:
    Sublattice pairs : (:A =&gt; :B,)
    dn cell distance : ([1, 2], [0, 0])
    Hopping range    : 2.0
    Coefficient      : -1

julia&gt; LatticePresets.honeycomb() |&gt; hamiltonian(hopping((r,dr) -&gt; cos(r[1]), sublats = (:A,:B) =&gt; (:A,:B)))
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 7 (SparseMatrixCSC, sparse)
  Harmonic size    : 2 × 2
  Orbitals         : ((:a,), (:a,))
  Element type     : scalar (Complex{Float64})
  Onsites          : 0
  Hoppings         : 18
  Coordination     : 9.0</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`onsite`, `nrange`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/model.jl#LL636-L736">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.hopselector-Tuple{}" href="#Quantica.hopselector-Tuple{}"><code>Quantica.hopselector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hopselector(; range = missing, dn = missing, sublats = missing, indices = missing, region = missing)</code></pre><p>Return a <code>HopSelector</code> object that can be used to select hops between two sites in a lattice. Only hops between two sites, with indices <code>ipair = src =&gt; dst</code>, at positions <code>r₁ = r - dr/2</code> and <code>r₂ = r + dr</code>, belonging to unit cells at integer distance <code>dn´</code> and to sublattices <code>s₁</code> and <code>s₂</code> will be selected if:</p><pre><code class="language-none">`region(r, dr) &amp;&amp; s in sublats &amp;&amp; dn´ in dn &amp;&amp; norm(dr) &lt;= range &amp;&amp; ipair in indices`</code></pre><p>If any of these is <code>missing</code> it will not be used to constraint the selection.</p><p>The keyword <code>range</code> admits the following possibilities</p><pre><code class="language-none">max_range                   # i.e. `norm(dr) &lt;= max_range`
(min_range, max_range)      # i.e. `min_range &lt;= norm(dr) &lt;= max_range`</code></pre><p>Both <code>max_range</code> and <code>min_range</code> can be a <code>Real</code> or a <code>NeighborRange</code> created with <code>nrange(n)</code>. The latter represents the distance of <code>n</code>-th nearest neighbors.</p><p>The keyword <code>dn</code> can be a <code>Tuple</code>/<code>Vector</code>/<code>SVector</code> of <code>Int</code>s, or a tuple thereof.</p><p>The keyword <code>sublats</code> allows the following formats:</p><pre><code class="language-none">sublats = :A =&gt; :B                  # Hopping from :A to :B sublattices, but not from :B to :A
sublats = (:A =&gt; :B,)               # Same as above
sublats = (:A =&gt; :B, :C =&gt; :D)      # Hopping from :A to :B or :C to :D
sublats = (:A, :C) .=&gt; (:B, :D)     # Broadcasted pairs, same as above
sublats = (:A, :C) =&gt; (:B, :D)      # Direct product, (:A=&gt;:B, :A=:D, :C=&gt;:B, :C=&gt;D)</code></pre><p>The keyword <code>indices</code> accepts a single <code>src =&gt; dest</code> pair or a collection thereof. Any <code>src == dest</code> will be neglected. Possible combinations:</p><pre><code class="language-none">indices = 1 =&gt; 2                    # Hopping from site 1 to 2, but not from 2 to 1
indices = (1 =&gt; 2, 2 =&gt; 1)          # Hoppings from 1 to 2 or from 2 to 1
indices = [1 =&gt; 2, 2 =&gt; 1]          # Same as above
indices = [(1, 2) .=&gt; (2, 1)]       # Broadcasted pairs, same as above
indices = [1:10 =&gt; 20:25, 3 =&gt; 30]  # Direct product, any hopping from sites 1:10 to sites 20:25, or from 3 to 30</code></pre><p>Additionally, indices or sublattices can be wrapped in <code>not</code> to exclude them (see <code>not</code>):</p><pre><code class="language-none">sublats = not(:A =&gt; :B, :B =&gt; :A)   # Any sublat pairs different from :A =&gt; :B or :B =&gt; :A
sublats = not(:A) =&gt; :B             # Any sublat pair s1 =&gt; s2 with s1 different from :A and s2 equal to :B
indices = not(8 =&gt; 9)               # Any site indices different from 8 =&gt; 9
indices = 1 =&gt; not(3:4)             # Any site pair 1 =&gt; s with s different from 3, 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/model.jl#LL161-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.ket-Tuple{Any}" href="#Quantica.ket-Tuple{Any}"><code>Quantica.ket</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ket(a; region = missing, sublats = missing, normalized = true, maporbitals = false)</code></pre><p>Create an <code>KetModel</code> of amplitude <code>a</code> on the specified <code>region</code> and <code>sublats</code>. The amplitude <code>a</code> can be a number, an <code>SVector</code>, or a function of the form <code>r -&gt; ...</code> for a position-dependent amplitude.</p><p>Unless <code>maporbitals = true</code>, the dimension of <code>a::AbstractVector</code> must match the orbital dimension of applicable sublattices (see also <code>orbitals</code> option for <code>hamiltonian</code>).</p><p>One or more <code>k::KetModel</code> can be converted to a <code>Vector</code> or <code>Matrix</code> representation corresponding to Hamiltonian <code>h</code> with <code>Vector(k, h)</code> and <code>Matrix(k, h)</code>, see <code>Vector</code> and <code>Matrix</code>.</p><p><strong>Keyword arguments</strong></p><p>Keyword <code>normalized</code> indicates whether to force normalization of the ket when the <code>KetModel</code> is applied to a specific Hamiltonian.</p><p>If keyword <code>maporbitals == true</code> and <code>a</code> is a scalar or a scalar function, <code>a</code> will be applied to each orbital independently. This is particularly useful in multiorbital systems with random amplitudes, e.g. <code>a = randn()</code>. If <code>a</code> is not a scalar, a <code>convert</code> error will be thrown.</p><p>Keywords <code>region</code> and <code>sublats</code> are the same as for <code>siteselector</code>. Only sites at position <code>r</code> in sublattice with name <code>s::NameType</code> will be selected if <code>region(r) &amp;&amp; s in sublats</code> is true. Any missing <code>region</code> or <code>sublat</code> will not be used to constraint the selection.</p><p>The keyword <code>sublats</code> allows the following formats:</p><pre><code class="language-none">sublats = :A           # Onsite on sublat :A only
sublats = (:A,)        # Same as above
sublats = (:A, :B)     # Onsite on sublat :A and :B</code></pre><p><strong>Ket algebra</strong></p><p><code>KetModel</code>s created with <code>ket</code> can added or substracted together or be multiplied by scalars to build more elaborate <code>KetModel</code>s, e.g. <code>ket(1) - 3 * ket(2, region = r -&gt; norm(r) &lt; 10)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; k = ket(1, sublats=:A) - ket(1, sublats=:B)
KetModel{2}: model with 2 terms
  Normalized : false
  OnsiteTerm{Int64}:
    Sublattices      : (:A,)
    Coefficient      : 1
  OnsiteTerm{Int64}:
    Sublattices      : (:B,)
    Coefficient      : -1</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`onsite`, `Vector`, `Matrix`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/model.jl#LL953-L1009">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.lattice-Tuple{Vararg{Quantica.Sublat,N} where N}" href="#Quantica.lattice-Tuple{Vararg{Quantica.Sublat,N} where N}"><code>Quantica.lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lattice(sublats::Sublat...; bravais = (), dim::Val{E}, type::T, names = missing)</code></pre><p>Create a <code>Lattice{E,L,T}</code> with Bravais vectors <code>bravais</code> and sublattices <code>sublats</code> converted to a common  <code>E</code>-dimensional embedding space and type <code>T</code>. To override the embedding  dimension <code>E</code>, use keyword <code>dim = Val(E)</code>. Similarly, override type <code>T</code> with <code>type = T</code>.</p><p>The keyword <code>bravais</code> indicates one or more Bravais vectors in the form of tuples or other iterables. It can also be an <code>AbstractMatrix</code> of dimension <code>E×L</code>. The default <code>bravais = ()</code> corresponds to a bounded lattice with no Bravais vectors.</p><p>A keyword <code>names</code> can be used to rename <code>sublats</code>. Given names can be replaced to ensure that all sublattice names are unique.</p><pre><code class="language-none">lattice(lat::AbstractLattice; bravais = missing, dim = missing, type = missing, names = missing)</code></pre><p>Create a new lattice by applying any non-missing <code>kw</code> to <code>lat</code>. For performance, allocations will be avoided if possible (depends on <code>kw</code>), so the result can share memory of <code>lat</code>. To avoid that, do <code>lattice(copy(lat); kw...)</code>.</p><p>See also <code>LatticePresets</code> for built-in lattices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; lattice(sublat((0, 0)), sublat((0, Float32(1))); bravais = (1, 0), dim = Val(3))
Lattice{3,1,Float32} : 1D lattice in 3D space
  Bravais vectors : ((1.0f0, 0.0f0, 0.0f0),)
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (1, 1) --&gt; 2 total per unit cell

julia&gt; LatticePresets.honeycomb(names = (:C, :D))
Lattice{2,2,Float64} : 2D lattice in 2D space
  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))
  Sublattices     : 2
    Names         : (:C, :D)
    Sites         : (1, 1) --&gt; 2 total per unit cell

julia&gt; LatticePresets.cubic(bravais = ((1, 0), (0, 2)))
Lattice{3,2,Float64} : 2D lattice in 3D space
  Bravais vectors : ((1.0, 0.0, 0.0), (0.0, 2.0, 0.0))
  Sublattices     : 1
    Names         : (:A)
    Sites         : (1) --&gt; 1 total per unit cell</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`LatticePresets`, `bravais`, `sublat`, `supercell`, `intracell`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/lattice.jl#LL210-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.momentaKPM" href="#Quantica.momentaKPM"><code>Quantica.momentaKPM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">momentaKPM(h::Hamiltonian, A = I; kets = randomkets(1), order = 10, bandrange = missing)</code></pre><p>Compute the Kernel Polynomial Method (KPM) momenta <code>μ_n = ∑⟨ket|T_n(h) A|ket⟩</code>, where the sum is over <code>kets</code> and where <code>T_n(x)</code> is the Chebyshev polynomial of order <code>n</code>, for a given <code>ket</code>, hamiltonian <code>h</code>, and observable <code>A</code>.</p><p><code>kets</code> can be a <code>KetModel</code> or a tuple of <code>KetModel</code>s (see <code>ket</code> and <code>randomkets</code>). A <code>kets = randomkets(R, ...)</code> produces a special <code>RepeatedKets</code> object that can be used to compute momenta by means of a stochastic trace <code>μ_n = Tr[A T_n(h)] ≈ ∑ₐ⟨a|A T_n(h)|a⟩</code>, where the <code>|a⟩</code> are the <code>R</code> random <code>kets</code> of norm 1/√R.</p><p>The order of the Chebyshev expansion is <code>order</code>. The <code>bandbrange = (ϵmin, ϵmax)</code> should completely encompass the full bandwidth of <code>hamiltonian</code>. If <code>missing</code> it is computed automatically using <code>ArnoldiMethods</code> (must be loaded).</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; h = LatticePresets.cubic() |&gt; hamiltonian(hopping(1)) |&gt; unitcell(region = RegionPresets.sphere(10));

julia&gt; momentaKPM(h, bandrange = (-6,6)).mulist |&gt; length
11</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/KPM.jl#LL43-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.not-Tuple{Any}" href="#Quantica.not-Tuple{Any}"><code>Quantica.not</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">not(i)</code></pre><p>Wrapper indicating the negation or complement of <code>i</code>, typically used to encode excluded site indices. See <code>siteselector</code> and <code>hopselector</code> for applications.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/model.jl#LL111-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.nrange-Tuple{Int64}" href="#Quantica.nrange-Tuple{Int64}"><code>Quantica.nrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nrange(n::Int)</code></pre><p>Create a <code>NeighborRange</code> that represents a hopping range to distances corresponding to the n-th nearest neighbors in a given lattice. Such distance is obtained by finding the n-th closest pairs of sites in a lattice, irrespective of their sublattice.</p><pre><code class="language-none">nrange(n::Int, lat::AbstractLattice)</code></pre><p>Obtain the actual nth-nearest-neighbot distance between sites in lattice <code>lat</code>.</p><p><strong>See also</strong></p><pre><code class="language-none">`hopping`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/model.jl#LL10-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.offdiagonal-Tuple{Quantica.TightbindingModel,Any,Any}" href="#Quantica.offdiagonal-Tuple{Quantica.TightbindingModel,Any,Any}"><code>Quantica.offdiagonal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">offdiagonal(model, lat, nsublats::NTuple{N,Int})</code></pre><p>Build a restricted version of <code>model</code> that applies only to off-diagonal blocks formed by sublattice groups of size <code>nsublats</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/model.jl#LL766-L771">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.onsite-Tuple{Any}" href="#Quantica.onsite-Tuple{Any}"><code>Quantica.onsite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">onsite(o; region = missing, sublats = missing)</code></pre><p>Create an <code>TightbindingModel</code> with a single <code>OnsiteTerm</code> that applies an onsite energy <code>o</code> to a <code>Lattice</code> when creating a <code>Hamiltonian</code> with <code>hamiltonian</code>.</p><p>The onsite energy <code>o</code> can be a number, an <code>SMatrix</code>, a <code>UniformScaling</code> (e.g. <code>3*I</code>) or a function of the form <code>r -&gt; ...</code> for a position-dependent onsite energy.</p><p>The dimension of <code>o::AbstractMatrix</code> must match the orbital dimension of applicable sublattices (see also <code>orbitals</code> option for <code>hamiltonian</code>). If <code>o::UniformScaling</code> it will be converted to an identity matrix of the appropriate size when applied to multiorbital sublattices. Similarly, if <code>o::SMatrix</code> it will be truncated or padded to the appropriate size.</p><pre><code class="language-none">onsite(model::TightbindingModel; kw...)</code></pre><p>Return a <code>TightbindingModel</code> with only the onsite terms of <code>model</code>. Any non-missing <code>kw</code> is applied to all such terms.</p><p><strong>Keyword arguments</strong></p><p>Keywords are the same as for <code>siteselector</code>. Only sites at position <code>r</code> in sublattice with name <code>s::NameType</code> will be selected if <code>region(r) &amp;&amp; s in sublats</code> is true. Any missing <code>region</code> or <code>sublat</code> will not be used to constraint the selection.</p><p>The keyword <code>sublats</code> allows the following formats:</p><pre><code class="language-none">sublats = :A           # Onsite on sublat :A only
sublats = (:A,)        # Same as above
sublats = (:A, :B)     # Onsite on sublat :A and :B</code></pre><p><strong>Combining models</strong></p><p><code>OnsiteTerm</code>s and <code>HoppingTerm</code>s created with <code>onsite</code> or <code>hopping</code> can added or substracted together or be multiplied by scalars to build more complicated <code>TightbindingModel</code>s, e.g. <code>onsite(1) - 3 * hopping(2)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; model = onsite(1, sublats = (:A,:B)) - 2 * hopping(2, sublats = :A=&gt;:A)
TightbindingModel{2}: model with 2 terms
  OnsiteTerm{Int64}:
    Sublattices      : (:A, :B)
    Coefficient      : 1
  HoppingTerm{Int64}:
    Sublattice pairs : (:A =&gt; :A,)
    dn cell distance : any
    Hopping range    : 1.0
    Coefficient      : -2

julia&gt; newmodel = onsite(model; sublats = :A) + hopping(model)
TightbindingModel{2}: model with 2 terms
  OnsiteTerm{Int64}:
    Sublattices      : (:A,)
    Coefficient      : 1
  HoppingTerm{Int64}:
    Sublattice pairs : (:A =&gt; :A,)
    dn cell distance : any
    Hopping range    : 1.0
    Coefficient      : -2

julia&gt; LatticePresets.honeycomb() |&gt; hamiltonian(onsite(r -&gt; @SMatrix[1 2; 3 4]), orbitals = Val(2))
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 1 (SparseMatrixCSC, sparse)
  Harmonic size    : 2 × 2
  Orbitals         : ((:a, :a), (:a, :a))
  Element type     : 2 × 2 blocks (Complex{Float64})
  Onsites          : 2
  Hoppings         : 0
  Coordination     : 0.0</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`hopping`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/model.jl#LL547-L623">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.orbitalstructure-Tuple{Quantica.Hamiltonian}" href="#Quantica.orbitalstructure-Tuple{Quantica.Hamiltonian}"><code>Quantica.orbitalstructure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">orbitalstructure(x::Union{Hamiltonian,ParametricHamiltonian})
orbitalstructure(x::Subspace)</code></pre><p>Return an <code>OrbitalStructure</code> containing information about the orbital structure of <code>x</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sp = spectrum(LP.honeycomb() |&gt; hamiltonian(hopping(I), orbitals = (:up,:down)) |&gt; unitcell);

julia&gt; sp[around = -1] |&gt; orbitalstructure
OrbitalStructure: orbital structure of Hamiltonian
  Orbital Type  : SVector{2, ComplexF64}
  Orbitals      : ((:up, :down), (:up, :down))
  Sublattices   : 2
  Dimensions    : 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/hamiltonian.jl#LL671-L689">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.parameters-Tuple{Quantica.ParametricHamiltonian}" href="#Quantica.parameters-Tuple{Quantica.ParametricHamiltonian}"><code>Quantica.parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameters(ph::ParametricHamiltonian)</code></pre><p>Return the names of the parameter that <code>ph</code> depends on</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/parametric.jl#LL180-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.parameters-Tuple{Vararg{Quantica.ElementModifier,N} where N}" href="#Quantica.parameters-Tuple{Vararg{Quantica.ElementModifier,N} where N}"><code>Quantica.parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameters(p::ElementModifier...)</code></pre><p>Return the parameter names for one or several  <code>ElementModifier</code> created with <code>@onsite!</code> or <code>@hopping!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/model.jl#LL821-L826">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.parametric-Tuple{Quantica.Hamiltonian,Vararg{Quantica.ElementModifier,N} where N}" href="#Quantica.parametric-Tuple{Quantica.Hamiltonian,Vararg{Quantica.ElementModifier,N} where N}"><code>Quantica.parametric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parametric(h::Hamiltonian, modifiers::ElementModifier...)</code></pre><p>Builds a <code>ParametricHamiltonian</code> that can be used to efficiently apply <code>modifiers</code> to <code>h</code>. <code>modifiers</code> can be any number of <code>@onsite!(args -&gt; body; kw...)</code> and <code>@hopping!(args -&gt; body; kw...)</code> transformations, each with a set of parameters <code>ps</code> given as keyword arguments of functions <code>f = (...; ps...) -&gt; body</code>.</p><p>For sparse <code>h</code> (the default), <code>parametric</code> only modifies existing onsites and hoppings in <code>h</code>, so be sure to add zero onsites and/or hoppings to <code>h</code> if they are originally not present but you need to apply modifiers to them.</p><pre><code class="language-none">ph(; ps...)</code></pre><p>For a <code>ph::ParametricHamiltonian</code>, return the corresponding <code>Hamiltonian</code> with parameters <code>ps</code> applied.</p><pre><code class="language-none">h |&gt; parametric(modifiers::ElementModifier...)</code></pre><p>Function form of <code>parametric</code>, equivalent to <code>parametric(h, modifiers...)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ph = LatticePresets.honeycomb() |&gt; hamiltonian(onsite(0) + hopping(1, range = 1/√3)) |&gt;
       unitcell(10) |&gt; parametric(@onsite!((o; μ) -&gt; o - μ))
ParametricHamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)
  Harmonic size    : 200 × 200
  Orbitals         : ((:a,), (:a,))
  Element type     : scalar (Complex{Float64})
  Onsites          : 0
  Hoppings         : 600
  Coordination     : 3.0
  Parameters       : (:μ,)

julia&gt; ph(μ = 2)
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)
  Harmonic size    : 200 × 200
  Orbitals         : ((:a,), (:a,))
  Element type     : scalar (Complex{Float64})
  Onsites          : 200
  Hoppings         : 600
  Coordination     : 3.0</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`@onsite!`, `@hopping!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/parametric.jl#LL20-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.randomkets" href="#Quantica.randomkets"><code>Quantica.randomkets</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randomkets(n, f::Function = r -&gt; cis(2pi*rand()); maporbitals = false, kw...)</code></pre><p>Create a <code>StochasticTraceKets</code> object to use in stochastic trace evaluation of KPM methods. The ket amplitudes at point <code>r</code> is given by function <code>f(r)</code>. In order to produce an accurate estimate of traces ∑⟨ket|A|ket⟩/n ≈ Tr<a href="sum over the `n` random kets">A</a>, <code>f</code> must be a random function satisfying <code>⟨f⟩ = 0</code>, <code>⟨ff⟩ = 0</code> and <code>⟨f&#39;f⟩ = 1</code>. The default <code>f</code> produces a uniform random phase. To apply it to an N-orbital system, <code>f</code> must in general be adapted to produce the desired random <code>SVector{N}</code> (unless <code>maporbitals = true</code>), with the above statistical properties for each orbital.</p><p>For example, to have independent, complex, normally-distributed random components of two orbitals use <code>randomkets(n, r -&gt; randn(SVector{2,ComplexF64}))</code>, or alternatively <code>randomkets(n, r -&gt; randn(ComplexF64), maporbitals = true)</code>.</p><p>If <code>maporbitals == true</code> the function <code>f</code> (which should then return a scalar) is applied independently to each orbital. The remaining keywords <code>kw</code> are passed to <code>ket</code> and can be used to constrain the random amplitude to a subset of sites. <code>normalized</code>, however, is always <code>false</code>.</p><p><strong>See also</strong></p><pre><code class="language-none">`ket`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/model.jl#LL1042-L1064">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.similarmatrix" href="#Quantica.similarmatrix"><code>Quantica.similarmatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">similarmatrix(h::Hamiltonian)</code></pre><p>Create an uninitialized matrix of the same type and size of the Hamiltonian&#39;s matrix.</p><pre><code class="language-none">similarmatrix(h::Hamiltonian, T::Type{&lt;:AbstractMatrix})</code></pre><p>Make the matrix of type <code>B&lt;:T</code>. Can be used to specify a different eltype from <code>h</code>&#39;s, (e.g. <code>T=SparseMatrixCSC{Float64}</code> with a multiorbital <code>h</code>)</p><pre><code class="language-none">similarmatrix(h::Hamiltonian, flatten)</code></pre><p>Create an unitialized matrix of the same type as a flattened version of <code>h</code>&#39;s, i.e. with a scalar eltype as in the example above.</p><pre><code class="language-none">similarmatrix(h::Hamiltonian, T::AbstractDiagonalizeMethod)</code></pre><p>Adapts the type of the matrix (e.g. dense/sparse) to the specified <code>method</code></p><pre><code class="language-none">similarmatrix(x::Union{ParametricHamiltonian, GreensFunction}, ...)</code></pre><p>Equivalent to the above, but adapted to the more general type of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; h = LatticePresets.honeycomb() |&gt; hamiltonian(hopping(I), orbitals = Val(2))

julia&gt; similarmatrix(h) |&gt; summary
&quot;2×2 SparseMatrixCSC{StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4},Int64}&quot;

julia&gt; similarmatrix(h, Matrix{Int}) |&gt; summary
&quot;4×4 Array{Int64,2}&quot;

julia&gt; similarmatrix(h, flatten) |&gt; summary
&quot;4×4 SparseMatrixCSC{Complex{Float64},Int64}&quot;

julia&gt; similarmatrix(h, LinearAlgebraPackage()) |&gt; summary
&quot;4×4 Array{Complex{Float64},2}&quot;</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`bloch!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/hamiltonian.jl#LL456-L499">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.siteindices-Tuple{Quantica.AbstractLattice}" href="#Quantica.siteindices-Tuple{Quantica.AbstractLattice}"><code>Quantica.siteindices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">siteindices(lat::AbstractLattice; kw...)
siteindices(lat::Hamiltonian; kw...)</code></pre><p>Build a generator of the unique indices of sites in the lattice unitcell. Only sites specified by <code>siteselector(kw...)</code> are selected, see <code>siteselector</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/hamiltonian.jl#LL712-L719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.sitepositions-Tuple{Quantica.AbstractLattice}" href="#Quantica.sitepositions-Tuple{Quantica.AbstractLattice}"><code>Quantica.sitepositions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sitepositions(lat::AbstractLattice; kw...)
sitepositions(h::Hamiltonian; kw...)</code></pre><p>Build a generator of the positions of sites in the lattice unitcell. Only sites specified by <code>siteselector(kw...)</code> are selected, see <code>siteselector</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/hamiltonian.jl#LL701-L708">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.siteselector-Tuple{}" href="#Quantica.siteselector-Tuple{}"><code>Quantica.siteselector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">siteselector(; region = missing, sublats = missing, indices = missing)</code></pre><p>Return a <code>SiteSelector</code> object that can be used to select sites in a lattice contained within the specified region and sublattices. Only sites with index <code>i</code>, at position <code>r</code> and belonging to a sublattice with name <code>s::NameType</code> will be selected if</p><pre><code class="language-none">`region(r) &amp;&amp; s in sublats &amp;&amp; i in indices`</code></pre><p>Any missing <code>region</code>, <code>sublat</code> or <code>indices</code> will not be used to constraint the selection.</p><p>The keyword <code>sublats</code> allows the following formats:</p><pre><code class="language-none">sublats = :A                    # Sites on sublat :A only
sublats = (:A,)                 # Same as above
sublats = (:A, :B)              # Sites on sublat :A and :B</code></pre><p>The keyword <code>indices</code> accepts a single integer, or a collection thereof. If several collections are given, they are flattened into a single one. Possible combinations:</p><pre><code class="language-none">indices = 1                     # Site 1 only
indices = (1, )                 # Same as above
indices = (1, 2, 3)             # Sites 1, 2 or 3
indices = [1, 2, 3]             # Same as above
indices = 1:3                   # Same as above
indices = (1:3, 7, 8)           # Sites 1, 2, 3, 7 or 8</code></pre><p>Additionally, indices or sublattices can be wrapped in <code>not</code> to exclude them (see <code>not</code>):</p><pre><code class="language-none">sublats = not(:A)               # Any sublat different from :A
sublats = not(:A, :B)           # Any sublat different from :A and :B
indices = not(8)                # Any site index different from 8
indices = not(1, 3:4)           # Any site index different from 1, 3 or 4
indices = (not(3:4), 4:6)       # Any site different from 3 and 4, *or* equal to 4, 5 or 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/model.jl#LL121-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.spectrum-Tuple{Any}" href="#Quantica.spectrum-Tuple{Any}"><code>Quantica.spectrum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spectrum(h; method = LinearAlgebraPackage(), transform = missing)</code></pre><p>Compute the spectrum of a 0D Hamiltonian <code>h</code> (or alternatively of the bounded unit cell of a finite dimensional <code>h</code>) using one of the following <code>method</code>s</p><pre><code class="language-none">method                    diagonalization function
--------------------------------------------------------------
LinearAlgebraPackage()     LinearAlgebra.eigen!
ArpackPackage()            Arpack.eigs (must be `using Arpack`)</code></pre><p>The option <code>transform = ε -&gt; f(ε)</code> allows to transform eigenvalues by <code>f</code> in the returned spectrum (useful for performing shifts or other postprocessing).</p><p><strong>Indexing</strong></p><p>The eigenenergies <code>εv::Vector</code> and eigenstates <code>ψm::Matrix</code> in a <code>s::Spectrum</code> object can be accessed via destructuring, <code>εv, ψm = sp</code>, or <code>εv, ψm = Tuple(sp)</code>, or <code>εv = first(sp) = sp.energies, ψm = last(sp) = sp.states</code>. Any degenerate energies appear repeated in <code>εv</code>. Alternatively, one can access one or more complete <code>sub::Subspace</code>s (eigenenergy together with its eigenstates, including all degenerates) via the indexing syntax,</p><pre><code class="language-none">s[1]                   : first `Subspace`
s[2:4]                 : subspaces 2, 3 and 4
s[[2,5,6]]             : subspaces 2, 5 and 6
s[around = 0.2]        : single subspace with energy closest to 0.2
s[around = (0.2, 10)]  : the ten subspaces with energies closest to 0.2</code></pre><p>The eigenenergy <code>ε</code> and subspace basis <code>ψs</code> of a <code>sub::Subspace</code> can be obtained via destructuring, <code>ε, ψs = sub</code>, or <code>ε = first(sub) = sub.energy, ψs = last(sub) = sub.basis</code>. For performance reasons <code>ψs</code> is a <code>SubArray</code> view of the appropriate columns of <code>ψm</code>, not an independent copy.</p><p><strong>See also</strong></p><pre><code class="language-none">`bandstructure`, `diagonalizer`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/bandstructure.jl#LL91-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.splitbands-Tuple{Quantica.Bandstructure}" href="#Quantica.splitbands-Tuple{Quantica.Bandstructure}"><code>Quantica.splitbands</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">splitbands(bs::Bandstructure)</code></pre><p>Splits the bands in <code>bs</code> into disconnected subbands that share no vertices. See also <code>splitbands</code> option in <code>bandstructure</code>.</p><p><strong>See also</strong></p><pre><code class="language-none">`bandstructure`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/bandstructure.jl#LL745-L752">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.sublat-Tuple{AbstractArray{#s36,1} where #s36&lt;:(StaticArrays.SArray{Tuple{S},T,1,S} where T where S)}" href="#Quantica.sublat-Tuple{AbstractArray{#s36,1} where #s36&lt;:(StaticArrays.SArray{Tuple{S},T,1,S} where T where S)}"><code>Quantica.sublat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sublat(sites...; name::Symbol)
sublat(sites::Vector{&lt;:SVector}; name::Symbol)</code></pre><p>Create a <code>Sublat{E,T,D}</code> that adds a sublattice, of name <code>name</code>, with sites at positions <code>sites</code> in <code>E</code> dimensional space. Sites can be entered as tuples or <code>SVectors</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sublat((0.0, 0), (1, 1), (1, -1), name = :A)
Sublat{2,Float64} : sublattice of Float64-typed sites in 2D space
  Sites    : 3
  Name     : :A</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/lattice.jl#LL26-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.supercell-Tuple" href="#Quantica.supercell-Tuple"><code>Quantica.supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">supercell(lat::AbstractLattice{E,L}, v::NTuple{L,Integer}...; seed = missing, kw...)
supercell(lat::AbstractLattice{E,L}, sc::SMatrix{L,L´,Int}; seed = missing, kw...)</code></pre><p>Generates a <code>Superlattice</code> from an <code>L</code>-dimensional lattice <code>lat</code> with Bravais vectors <code>br´= br * sc</code>, where <code>sc::SMatrix{L,L´,Int}</code> is the integer supercell matrix with the <code>L´</code> vectors <code>v</code>s as columns. If no <code>v</code> are given, the superlattice will be bounded.</p><p>Only sites selected by <code>siteselector(; kw...)</code> will be included in the supercell (see <code>siteselector</code> for details on the available keywords <code>kw</code>). The search for included sites will start from point <code>seed::Union{Tuple,SVector}</code>, or the origin if <code>seed = missing</code>. If no keyword <code>region</code> is given in <code>kw</code>, a Bravais unit cell perpendicular to the <code>v</code> axes will be selected for the <code>L-L´</code> non-periodic directions.</p><pre><code class="language-none">supercell(lattice::AbstractLattice{E,L}, factor::Integer; kw...)</code></pre><p>Calls <code>supercell</code> with a uniformly scaled <code>sc = SMatrix{L,L}(factor * I)</code></p><pre><code class="language-none">supercell(lattice::AbstractLattice, factors::Integer...; kw...)</code></pre><p>Calls <code>supercell</code> with different scaling along each Bravais vector (diagonal supercell with factors along the diagonal)</p><pre><code class="language-none">lat |&gt; supercell(v...; kw...)</code></pre><p>Curried syntax, equivalent to `supercell(lat, v...; kw...)</p><pre><code class="language-none">supercell(h::Hamiltonian, v...; kw...)</code></pre><p>Promotes the <code>Lattice</code> of <code>h</code> to a <code>Superlattice</code> without changing the Hamiltonian itself, which always refers to the unitcell of the lattice.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; supercell(LatticePresets.honeycomb(), region = RegionPresets.circle(300))
Superlattice{2,2,Float64,0} : 2D lattice in 2D space, filling a 0D supercell
  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (1, 1) --&gt; 2 total per unit cell
  Supercell{2,0} for 0D superlattice of the base 2D lattice
    Supervectors  : ()
    Supersites    : 652966

julia&gt; supercell(LatticePresets.triangular(), (1,1), (1, -1))
Superlattice{2,2,Float64,2} : 2D lattice in 2D space, filling a 2D supercell
  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))
  Sublattices     : 1
    Names         : (:A)
    Sites         : (1) --&gt; 1 total per unit cell
  Supercell{2,2} for 2D superlattice of the base 2D lattice
    Supervectors  : ((1, 1), (1, -1))
    Supersites    : 2

julia&gt; LatticePresets.square() |&gt; supercell(3)
Superlattice{2,2,Float64,2} : 2D lattice in 2D space, filling a 2D supercell
  Bravais vectors : ((1.0, 0.0), (0.0, 1.0))
  Sublattices     : 1
    Names         : (:A)
    Sites         : (1) --&gt; 1 total per unit cell
  Supercell{2,2} for 2D superlattice of the base 2D lattice
    Supervectors  : ((3, 0), (0, 3))
    Supersites    : 9</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`unitcell`, `siteselector`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/lattice.jl#LL553-L621">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.transform!-Tuple{Any,Quantica.Bandstructure}" href="#Quantica.transform!-Tuple{Any,Quantica.Bandstructure}"><code>Quantica.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(f::Function, b::Bandstructure)</code></pre><p>Transform the energies of all bands in <code>b</code> by applying <code>f</code> to them in place.</p><pre><code class="language-none">transform!((fk, fε), b::Bandstructure)</code></pre><p>Transform Bloch phases and energies of all bands in <code>b</code> by applying <code>fk</code> and <code>fε</code> to them in place, respectively. If any of them is <code>missing</code>, it will be ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/bandstructure.jl#LL270-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.transform!-Tuple{Any,Quantica.Hamiltonian}" href="#Quantica.transform!-Tuple{Any,Quantica.Hamiltonian}"><code>Quantica.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(f::Function, h::Hamiltonian)</code></pre><p>Transform the site positions of the Hamiltonian&#39;s lattice in place without modifying the Hamiltonian harmonics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/hamiltonian.jl#LL723-L728">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.transform!-Tuple{Any,Quantica.Spectrum}" href="#Quantica.transform!-Tuple{Any,Quantica.Spectrum}"><code>Quantica.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(f::Function, s::Spectrum)</code></pre><p>Transform the energies of <code>s</code> by applying <code>f</code> to them in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/bandstructure.jl#LL135-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.transform!-Tuple{Function}" href="#Quantica.transform!-Tuple{Function}"><code>Quantica.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">x |&gt; transform!(f::Function)</code></pre><p>Curried version of <code>transform!</code>, equivalent to <code>transform!(f, x)</code></p><pre><code class="language-none">transform!(f::Function, lat::Lattice)</code></pre><p>Transform the site positions of <code>lat</code> by applying <code>f</code> to them in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/lattice.jl#LL481-L489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.unflatten-Union{Tuple{T}, Tuple{AbstractArray{T,1} where T,Quantica.OrbitalStructure{T,N,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N}} where N}} where T" href="#Quantica.unflatten-Union{Tuple{T}, Tuple{AbstractArray{T,1} where T,Quantica.OrbitalStructure{T,N,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N}} where N}} where T"><code>Quantica.unflatten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unflatten(v::AbstractArray, o::OrbitalStructure{T})</code></pre><p>Rebuild <code>v</code> to have element type <code>T</code> and orbital structure <code>o</code> by performing the inverse of <code>flatten(v)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; h = LP.honeycomb() |&gt; hamiltonian(hopping(I), orbitals = (:up,:down)) |&gt; unitcell;

julia&gt; psi = spectrum(h)[around = -1]
Subspace{0}: eigenenergy subspace on a 0D manifold
  Energy       : -0.9999999999999989
  Degeneracy   : 2
  Bloch/params : Float64[]
  Basis eltype : SVector{2, ComplexF64}

julia&gt; psiflat = flatten(psi)
Subspace{0}: eigenenergy subspace on a 0D manifold
  Energy       : -0.9999999999999989
  Degeneracy   : 2
  Bloch/params : Float64[]
  Basis eltype : ComplexF64

julia&gt; unflatten(psiflat, orbitalstructure(psi))
Subspace{0}: eigenenergy subspace on a 0D manifold
  Energy       : -0.9999999999999989
  Degeneracy   : 2
  Bloch/params : Float64[]
  Basis eltype : SVector{2, ComplexF64}</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`flatten`, `orbitalstructure`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/hamiltonian.jl#LL360-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.unitcell-Tuple{Vararg{Union{Integer, Tuple, StaticArrays.SArray{Tuple{S},T,1,S} where T where S, StaticArrays.SArray{Tuple{S1,S2},T,2,L} where L where T where S2 where S1},N} where N}" href="#Quantica.unitcell-Tuple{Vararg{Union{Integer, Tuple, StaticArrays.SArray{Tuple{S},T,1,S} where T where S, StaticArrays.SArray{Tuple{S1,S2},T,2,L} where L where T where S2 where S1},N} where N}"><code>Quantica.unitcell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unitcell(lat::Lattice{E,L}, v::NTuple{L,Integer}...; seed = missing, kw...)
unitcell(lat::Lattice{E,L}, uc::SMatrix{L,L´,Int}; seed = missing, kw...)</code></pre><p>Generates a <code>Lattice</code> from an <code>L</code>-dimensional lattice <code>lat</code> and a larger unit cell, such that its Bravais vectors are <code>br´= br * uc</code>. Here <code>uc::SMatrix{L,L´,Int}</code> is the integer unitcell matrix, with the <code>L´</code> vectors <code>v</code>s as columns. If no <code>v</code> are given, the new lattice will be bounded.</p><p>Only sites selected by <code>siteselector(; kw...)</code> will be included in the supercell (see <code>siteselector</code> for details on the available keywords <code>kw</code>). The search for included sites will start from point <code>seed::Union{Tuple,SVector}</code>, or the origin if <code>seed = missing</code>. If no keyword <code>region</code> is given in <code>kw</code>, a Bravais unit cell perpendicular to the <code>v</code> axes will be selected for the <code>L-L´</code> non-periodic directions.</p><pre><code class="language-none">unitcell(lattice::Lattice{E,L}, factor::Integer; kw...)</code></pre><p>Calls <code>unitcell</code> with a uniformly scaled <code>uc = SMatrix{L,L}(factor * I)</code></p><pre><code class="language-none">unitcell(lattice::Lattice{E,L}, factors::Integer...; kw...)</code></pre><p>Calls <code>unitcell</code> with different scaling along each Bravais vector (diagonal supercell with factors along the diagonal)</p><pre><code class="language-none">unitcell(slat::Superlattice)</code></pre><p>Convert Superlattice <code>slat</code> into a lattice with its unit cell matching <code>slat</code>&#39;s supercell.</p><pre><code class="language-none">unitcell(h::Hamiltonian, v...; mincoordination, modifiers = (), kw...)</code></pre><p>Transforms the <code>Lattice</code> of <code>h</code> to have a larger unitcell, while expanding the Hamiltonian accordingly.</p><p>A nonzero <code>mincoordination</code> indicates a minimum number of nonzero hopping neighbors required for sites to be included in the resulting unit cell. Sites with inferior coordination will be removed recursively, until all remaining satisfy <code>mincoordination</code>.</p><p>The <code>modifiers</code> (a tuple of <code>ElementModifier</code>s, either <code>@onsite!</code> or <code>@hopping!</code> with no free parameters) will be applied to onsite and hoppings as the hamiltonian is expanded. See <code>@onsite!</code> and <code>@hopping!</code> for details.</p><p>Note: for performance reasons, in sparse hamiltonians only the stored onsites and hoppings will be transformed by <code>ElementModifier</code>s, so you might want to add zero onsites or hoppings when building <code>h</code> to have a modifier applied to them later.</p><pre><code class="language-none">lat_or_h |&gt; unitcell(v...; kw...)</code></pre><p>Curried syntax, equivalent to <code>unitcell(lat_or_h, v...; kw...)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; unitcell(LatticePresets.honeycomb(), region = RegionPresets.circle(300))
Lattice{2,0,Float64} : 0D lattice in 2D space
  Bravais vectors : ()
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (326483, 326483) --&gt; 652966 total per unit cell

julia&gt; unitcell(LatticePresets.triangular(), (1,1), (1, -1))
Lattice{2,2,Float64} : 2D lattice in 2D space
  Bravais vectors : ((0.0, 1.732051), (1.0, 0.0))
  Sublattices     : 1
    Names         : (:A)
    Sites         : (2) --&gt; 2 total per unit cell

julia&gt; LatticePresets.square() |&gt; unitcell(3)
Lattice{2,2,Float64} : 2D lattice in 2D space
  Bravais vectors : ((3.0, 0.0), (0.0, 3.0))
  Sublattices     : 1
    Names         : (:A)
    Sites         : (9) --&gt; 9 total per unit cell

julia&gt; supercell(LatticePresets.square(), 3) |&gt; unitcell
Lattice{2,2,Float64} : 2D lattice in 2D space
  Bravais vectors : ((3.0, 0.0), (0.0, 3.0))
  Sublattices     : 1
    Names         : (:A)
    Sites         : (9) --&gt; 9 total per unit cell</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`supercell`, `siteselector`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/lattice.jl#LL772-L855">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.vertices-Tuple{Quantica.Bandstructure,Any}" href="#Quantica.vertices-Tuple{Quantica.Bandstructure,Any}"><code>Quantica.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vertices(bs::Bandstructure, i)</code></pre><p>Return the vertices <code>(k..., ϵ)</code> of the i-th band in <code>bs</code>, in the form of a <code>Vector{SVector{L+1}}</code>, where <code>L</code> is the lattice dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/bandstructure.jl#LL262-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.wrap-Tuple{Quantica.Hamiltonian,Int64}" href="#Quantica.wrap-Tuple{Quantica.Hamiltonian,Int64}"><code>Quantica.wrap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wrap(h::Hamiltonian, axes; phases = missing)</code></pre><p>Build a new Hamiltonian from <code>h</code> reducing its dimensions from <code>L</code> to <code>L - length(axes)</code> by wrapping the specified Bravais <code>axes</code> into a loop. <code>axes</code> can be an integer ∈ 1:L or a tuple of such integers. If <code>phases</code> are given (with <code>length(axes) == length(phases)</code>), the wrapped hoppings at a cell distance <code>dn</code> along <code>axes</code> will be multiplied by a factor <code>cis(-dot(phases, dn))</code>. This is useful, for example, to represent a flux Φ through a loop, using a single <code>axes = 1</code> and <code>phases = 2π * Φ/Φ₀</code>.</p><pre><code class="language-none">wrap(h::Hamiltonian; kw...)</code></pre><p>Wrap all axes of <code>h</code>, yielding a compactified zero-dimensional Hamiltonian.</p><pre><code class="language-none">h |&gt; wrap(axes; kw...)</code></pre><p>Curried form equivalent to <code>wrap(h, axes; kw...)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; LatticePresets.honeycomb() |&gt; hamiltonian(hopping(1, range = 1/√3)) |&gt;
       unitcell((1,-1), (10, 10)) |&gt; wrap(2)
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 1D Lattice in 2D space
  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)
  Harmonic size    : 40 × 40
  Orbitals         : ((:a,), (:a,))
  Element type     : scalar (Complex{Float64})
  Onsites          : 0
  Hoppings         : 120
  Coordination     : 3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/hamiltonian.jl#LL1540-L1572">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.@hopping!-Tuple{Any,Any}" href="#Quantica.@hopping!-Tuple{Any,Any}"><code>Quantica.@hopping!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@hopping!(args -&gt; body; kw...)</code></pre><p>Create an <code>ElementModifier</code>, to be used with <code>parametric</code>, that applies <code>f = args -&gt; body</code> to hoppings energies specified by <code>kw</code> (see <code>hopping</code> for details on possible <code>kw</code>s). The form of <code>args -&gt; body</code> may be <code>(t; params...) -&gt; ...</code> or <code>(t, r, dr; params...) -&gt; ...</code> if the modification is position (<code>r</code>, <code>dr</code>) dependent. Keyword arguments <code>params</code> are optional, and include any parameters that <code>body</code> depends on that the user may want to tune.</p><p>Note: unlike <code>onsite</code> and <code>hopping</code>, <code>ElementModifier</code>s cannot be combined (i.e. you cannot do <code>@onsite!(...) + @hopping!(...)</code>). <code>ElementModifier</code>s are not model terms but transformations of an existing Hamiltonian that are meant to be applied sequentially (the order of application usually matters).</p><p><strong>See also</strong></p><pre><code class="language-none">`@onsite!`, `parametric`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/model.jl#LL859-L875">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.@onsite!-Tuple{Any,Any}" href="#Quantica.@onsite!-Tuple{Any,Any}"><code>Quantica.@onsite!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@onsite!(args -&gt; body; kw...)</code></pre><p>Create an <code>ElementModifier</code>, to be used with <code>parametric</code>, that applies <code>f = args -&gt; body</code> to onsite energies specified by <code>kw</code> (see <code>onsite</code> for details  on possible <code>kw</code>s). The form of <code>args -&gt; body</code> may be <code>(o; params...) -&gt; ...</code> or <code>(o, r; params...) -&gt; ...</code> if the modification is position (<code>r</code>) dependent. Keyword arguments <code>params</code> are optional, and include any parameters that <code>body</code> depends on that the user may want to tune.</p><p>Note: unlike <code>onsite</code> and <code>hopping</code>, <code>ElementModifier</code>s cannot be combined (i.e. you cannot do <code>@onsite!(...) + @hopping!(...)</code>). <code>ElementModifier</code>s are not model terms but transformations of an existing Hamiltonian that are meant to be applied sequentially (the order of application usually matters).</p><p><strong>See also</strong></p><pre><code class="language-none">`@hopping!`, `parametric`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/13392489f386912a03707a4435fd1f053cff9653/src/model.jl#LL832-L848">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 30 March 2021 09:48">Tuesday 30 March 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
