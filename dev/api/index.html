<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Quantica.jl</title><meta name="title" content="API · Quantica.jl"/><meta property="og:title" content="API · Quantica.jl"/><meta property="twitter:title" content="API · Quantica.jl"/><meta name="description" content="Documentation for Quantica.jl."/><meta property="og:description" content="Documentation for Quantica.jl."/><meta property="twitter:description" content="Documentation for Quantica.jl."/><meta property="og:url" content="https://pablosanjose.github.io/Quantica.jl/api/"/><meta property="twitter:url" content="https://pablosanjose.github.io/Quantica.jl/api/"/><link rel="canonical" href="https://pablosanjose.github.io/Quantica.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Quantica.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Quantica.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Quantica.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../tutorial/tutorial/">Welcome</a></li><li><a class="tocitem" href="../tutorial/glossary/">Glossary</a></li><li><a class="tocitem" href="../tutorial/lattices/">Lattices</a></li><li><a class="tocitem" href="../tutorial/models/">Models</a></li><li><a class="tocitem" href="../tutorial/hamiltonians/">Hamiltonians</a></li><li><a class="tocitem" href="../tutorial/bandstructures/">Bandstructures</a></li><li><a class="tocitem" href="../tutorial/greenfunctions/">GreenFunctions</a></li><li><a class="tocitem" href="../tutorial/observables/">Observables</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/pablosanjose/Quantica.jl/blob/master/docs/src/api.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="api"><a class="docs-heading-anchor" href="#api">API</a><a id="api-1"></a><a class="docs-heading-anchor-permalink" href="#api" title="Permalink"></a></h1><ul><li><a href="#Quantica.EigenSolvers"><code>Quantica.EigenSolvers</code></a></li><li><a href="#Quantica.GreenSolvers"><code>Quantica.GreenSolvers</code></a></li><li><a href="#Quantica.HamiltonianPresets"><code>Quantica.HamiltonianPresets</code></a></li><li><a href="#Quantica.LatticePresets"><code>Quantica.LatticePresets</code></a></li><li><a href="#Quantica.RegionPresets"><code>Quantica.RegionPresets</code></a></li><li><a href="#Quantica.BoxIterator"><code>Quantica.BoxIterator</code></a></li><li><a href="#Base.reverse"><code>Base.reverse</code></a></li><li><a href="#Base.reverse!"><code>Base.reverse!</code></a></li><li><a href="#LinearAlgebra.ishermitian"><code>LinearAlgebra.ishermitian</code></a></li><li><a href="#Quantica.attach"><code>Quantica.attach</code></a></li><li><a href="#Quantica.bands"><code>Quantica.bands</code></a></li><li><a href="#Quantica.bravais_matrix"><code>Quantica.bravais_matrix</code></a></li><li><a href="#Quantica.cellsites"><code>Quantica.cellsites</code></a></li><li><a href="#Quantica.combine"><code>Quantica.combine</code></a></li><li><a href="#Quantica.conductance"><code>Quantica.conductance</code></a></li><li><a href="#Quantica.current"><code>Quantica.current</code></a></li><li><a href="#Quantica.energies"><code>Quantica.energies</code></a></li><li><a href="#Quantica.greenfunction"><code>Quantica.greenfunction</code></a></li><li><a href="#Quantica.hamiltonian"><code>Quantica.hamiltonian</code></a></li><li><a href="#Quantica.hopping"><code>Quantica.hopping</code></a></li><li><a href="#Quantica.hopselector"><code>Quantica.hopselector</code></a></li><li><a href="#Quantica.josephson"><code>Quantica.josephson</code></a></li><li><a href="#Quantica.lattice"><code>Quantica.lattice</code></a></li><li><a href="#Quantica.ldos"><code>Quantica.ldos</code></a></li><li><a href="#Quantica.neighbors"><code>Quantica.neighbors</code></a></li><li><a href="#Quantica.onsite"><code>Quantica.onsite</code></a></li><li><a href="#Quantica.plusadjoint"><code>Quantica.plusadjoint</code></a></li><li><a href="#Quantica.sites"><code>Quantica.sites</code></a></li><li><a href="#Quantica.siteselector"><code>Quantica.siteselector</code></a></li><li><a href="#Quantica.spectrum"><code>Quantica.spectrum</code></a></li><li><a href="#Quantica.states"><code>Quantica.states</code></a></li><li><a href="#Quantica.subdiv"><code>Quantica.subdiv</code></a></li><li><a href="#Quantica.sublat"><code>Quantica.sublat</code></a></li><li><a href="#Quantica.supercell"><code>Quantica.supercell</code></a></li><li><a href="#Quantica.transform"><code>Quantica.transform</code></a></li><li><a href="#Quantica.translate"><code>Quantica.translate</code></a></li><li><a href="#Quantica.transmission"><code>Quantica.transmission</code></a></li><li><a href="#Quantica.unflat"><code>Quantica.unflat</code></a></li><li><a href="#Quantica.wrap"><code>Quantica.wrap</code></a></li><li><a href="#Quantica.@hopping"><code>Quantica.@hopping</code></a></li><li><a href="#Quantica.@hopping!"><code>Quantica.@hopping!</code></a></li><li><a href="#Quantica.@onsite"><code>Quantica.@onsite</code></a></li><li><a href="#Quantica.@onsite!"><code>Quantica.@onsite!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.EigenSolvers" href="#Quantica.EigenSolvers"><code>Quantica.EigenSolvers</code></a> — <span class="docstring-category">Module</span></header><section><div><p><code>EigenSolvers</code> is a Quantica submodule containing several pre-defined eigensolvers. The alias <code>ES</code> can be used in place of <code>EigenSolvers</code>. Currently supported solvers are</p><pre><code class="nohighlight hljs">ES.LinearAlgebra(; kw...)       # Uses `eigen(mat; kw...)` from the `LinearAlgebra` package
ES.Arpack(; kw...)              # Uses `eigs(mat; kw...)` from the `Arpack` package
ES.KrylovKit(params...; kw...)  # Uses `eigsolve(mat, params...; kw...)` from the `KrylovKit` package
ES.ArnoldiMethod(; kw...)       # Uses `partialschur(mat; kw...)` from the `ArnoldiMethod` package</code></pre><p>Additionally, to compute interior eigenvalues, we can use a shift-invert method around energy <code>ϵ0</code> (uses <code>LinearMaps</code> and a <code>LinearSolve.lu</code> factorization), combined with any solver <code>s</code> from the list above:</p><pre><code class="nohighlight hljs">ES.ShiftInvert(s, ϵ0)           # Perform a lu-based shift-invert with solver `s`</code></pre><p>If the required packages are not already available, they will be automatically loaded when calling these solvers.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; h = HP.graphene(t0 = 1) |&gt; supercell(10);

julia&gt; spectrum(h, (0,0); solver = ES.ShiftInvert(ES.ArnoldiMethod(nev = 4), 0.0)) |&gt; energies
4-element Vector{ComplexF64}:
 -0.3819660112501042 + 2.407681231060336e-16im
 -0.6180339887498942 - 2.7336317916863215e-16im
  0.6180339887498937 - 1.7243387890744497e-16im
  0.3819660112501042 - 1.083582785131051e-16im</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`spectrum`, `bands`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL1086-L1119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.GreenSolvers" href="#Quantica.GreenSolvers"><code>Quantica.GreenSolvers</code></a> — <span class="docstring-category">Module</span></header><section><div><p><code>GreenSolvers</code> is a Quantica submodule containing several pre-defined Green function solvers. The alias <code>GS</code> can be used in place of <code>GS</code>. Currently supported solvers and their possible keyword arguments are</p><ul><li><code>GS.SparseLU()</code> : Direct inversion solver for 0D Hamiltonians using a <code>SparseArrays.lu(hmat)</code> factorization</li><li><code>GS.Schur(; boundary = Inf)</code> : Solver for 1D Hamiltonians based on a deflated, generalized Schur factorization<ul><li><code>boundary</code> : 1D cell index of a boundary cell, or <code>Inf</code> for no boundaries. Equivalent to removing that specific cell from the lattice when computing the Green function.</li></ul></li><li><code>GS.KPM(; order = 100, bandrange = missing, kernel = I)</code> : Kernel polynomial method solver for 0D Hamiltonians<ul><li><code>order</code> : order of the expansion in Chebyshev polynomials <code>Tₙ(h)</code> of the Hamiltonian <code>h</code> (lowest possible order is <code>n = 0</code>).</li><li><code>bandrange</code> : a <code>(min_energy, max_energy)::Tuple</code> interval that encompasses the full band of the Hamiltonian. If <code>missing</code>, it is computed automatically.</li><li><code>kernel</code> : generalization that computes momenta as <code>μₙ = Tr[Tₙ(h)*kernel]</code>, so that the local density of states (see <code>ldos</code>) becomes the density of the <code>kernel</code> operator.</li><li>This solver does not allow arbitrary indexing of the resulting <code>g::GreenFunction</code>, only on contacts <code>g[contact_ind::Integer]</code>. If the system has none, we can add a dummy contact using <code>attach(h, nothing; sites...)</code>, see <code>attach</code>.</li></ul></li><li><code>GS.Bands(bands_arguments; boundary = missing, bands_kw...)</code>: solver based on the integration of bandstructure simplices<ul><li><code>bands_arguments</code>: positional arguments passed on to <code>bands</code></li><li><code>bands_kw</code>: keyword arguments passed on to <code>bands</code></li><li><code>boundary</code>: either <code>missing</code> (no boundary), or <code>dir =&gt; cell_pos</code>, where <code>dir::Integer</code> is the Bravais vector normal to the boundary, and <code>cell_pos::Integer</code> the value of cell indices <code>cells[dir]</code> that define the boundary (i.e. <code>cells[dir] &lt;= cell_pos</code> are vaccum)</li><li>This solver only allows zero or one boundary. WARNING: if a boundary is used, the algorithm may become unstable for very fine band meshes.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL1514-L1534">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.HamiltonianPresets" href="#Quantica.HamiltonianPresets"><code>Quantica.HamiltonianPresets</code></a> — <span class="docstring-category">Module</span></header><section><div><p><code>HamiltonianPresets</code> is a Quantica submodule containing several pre-defined Hamiltonians. The alias <code>HP</code> can be used in place of <code>LatticePresets</code>. Currently supported hamiltonians are</p><pre><code class="nohighlight hljs">HP.graphene(; kw...)
HP.twisted_bilayer_graphene(; kw...)</code></pre><p>For details on the keyword arguments <code>kw</code> see the corresponding docstring</p><pre><code class="language-julia-repl hljs">julia&gt; HamiltonianPresets.twisted_bilayer_graphene(twistindices = (30, 1))
Hamiltonian{Float64,3,2}: Hamiltonian on a 2D Lattice in 3D space
  Bloch harmonics  : 7
  Harmonic size    : 11164 × 11164
  Orbitals         : [1, 1, 1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 315684
  Coordination     : 28.27696</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`LatticePresets`, `RegionPresets`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL40-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.LatticePresets" href="#Quantica.LatticePresets"><code>Quantica.LatticePresets</code></a> — <span class="docstring-category">Module</span></header><section><div><p><code>LatticePresets</code> is a Quantica submodule containing several pre-defined lattices. The alias <code>LP</code> can be used in place of <code>LatticePresets</code>. Currently supported lattices are</p><pre><code class="nohighlight hljs">LP.linear(; a0 = 1, kw...)      # linear lattice in 1D
LP.square(; a0 = 1, kw...)      # square lattice in 2D
LP.triangular(; a0 = 1, kw...)  # triangular lattice in 2D
LP.honeycomb(; a0 = 1, kw...)   # honeycomb lattice in 2D
LP.cubic(; a0 = 1, kw...)       # cubic lattice in 3D
LP.fcc(; a0 = 1, kw...)         # face-centered-cubic lattice in 3D
LP.bcc(; a0 = 1, kw...)         # body-centered-cubic lattice in 3D
LP.hcp(; a0 = 1, kw...)         # hexagonal-closed-packed lattice in 3D</code></pre><p>In all cases <code>a0</code> denotes the lattice constant, and <code>kw...</code> are extra keywords forwarded to <code>lattice</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LatticePresets.honeycomb(names = (:C, :D))
Lattice{Float64,2,2} : 2D lattice in 2D space
  Bravais vectors : [[0.5, 0.866025], [-0.5, 0.866025]]
  Sublattices     : 2
    Names         : (:C, :D)
    Sites         : (1, 1) --&gt; 2 total per unit cell

julia&gt; LatticePresets.cubic(bravais = ((1, 0), (0, 2)))
Lattice{Float64,3,2} : 2D lattice in 3D space
  Bravais vectors : [[1.0, 0.0, 0.0], [0.0, 2.0, 0.0]]
  Sublattices     : 1
    Names         : (:A,)
    Sites         : (1,) --&gt; 1 total per unit cell</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`RegionPresets`, `HamiltonianPresets`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.RegionPresets" href="#Quantica.RegionPresets"><code>Quantica.RegionPresets</code></a> — <span class="docstring-category">Module</span></header><section><div><p><code>RegionPresets</code> is a Quantica submodule containing several pre-defined regions of type <code>Region{E}</code>, where <code>E</code> is the space dimension. The alias <code>RP</code> can be used in place of <code>RegionPresets</code>. Supported regions are</p><pre><code class="nohighlight hljs">RP.circle(radius = 10, center = (0, 0))                         # 2D
RP.ellipse((rx, ry) = (10, 15), center = (0, 0))                # 2D
RP.square(side = 10, center = (0, 0))                           # 2D
RP.rectangle((sx, sy) = (10, 15), center = (0, 0))              # 2D
RP.sphere(radius = 10, center = (0, 0, 0))                      # 3D
RP.spheroid((rx, ry, rz) = (10, 15, 20), center = (0, 0, 0))    # 3D
RP.cube(side = 10, center = (0, 0, 0))                          # 3D
RP.cuboid((sx, sy, sz) = (10, 15, 20), center = (0, 0, 0))      # 3D</code></pre><p>Calling a <code>f::Region{E}</code> object on a <code>r::Tuple</code> or <code>r::SVector</code> with <code>f(r)</code> or <code>f(r...)</code> returns <code>true</code> or <code>false</code> if <code>r</code> is inside the region or not. Note that only the first <code>E</code> coordinates of <code>r</code> will be checked. Arbitrary boolean functions can also be wrapped in <code>Region{E}</code> to create custom regions, e.g. <code>f = Region{2}(r -&gt; r[1]^2 &lt; r[2])</code>.</p><p>Boolean combinations of <code>Regions</code> are supported using <code>&amp;</code>, <code>|</code>, <code>xor</code> and <code>!</code> operators, such as <code>annulus = RP.circle(10) &amp; !RP.circle(5)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; RegionPresets.circle(10)(20, 0, 0)
false

julia&gt; RegionPresets.circle(10)(0, 0, 20)
true</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`LatticePresets`, `HamiltonianPresets`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL68-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.BoxIterator" href="#Quantica.BoxIterator"><code>Quantica.BoxIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxIterator(seed::SVector{N,Int}; maxiterations = TOOMANYITERS)</code></pre><p>Cartesian iterator <code>iter</code> over <code>SVector{N,Int}</code>s (<code>cell</code>s) that starts at <code>seed</code> and grows outwards in the form of a box of increasing sides (not necesarily equal) until it encompasses a certain N-dimensional region. To signal that a cell is in the desired region the user calls <code>acceptcell!(iter, cell)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/iterators.jl#LL5-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reverse" href="#Base.reverse"><code>Base.reverse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reverse(lat_or_h::Union{Lattice,AbstractHamiltonian})</code></pre><p>Build a new lattice or hamiltonian with the orientation of all Bravais vectors reversed.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`reverse!`, `transform`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL290-L297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reverse!" href="#Base.reverse!"><code>Base.reverse!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reverse!(lat_or_h::Union{Lattice,AbstractHamiltonian})</code></pre><p>In-place version of <code>reverse</code>, inverts all Bravais vectors of <code>lat_or_h</code>.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`reverse`, `transform`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL300-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.ishermitian" href="#LinearAlgebra.ishermitian"><code>LinearAlgebra.ishermitian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ishermitian(h::Hamiltonian)</code></pre><p>Check whether <code>h</code> is Hermitian. This is not supported for <code>h::ParametricHamiltonian</code>, as the result can depend of the specific values of its parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL632-L638">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.attach" href="#Quantica.attach"><code>Quantica.attach</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">attach(h::AbstractHamiltonian, args..; sites...)
attach(h::OpenHamiltonian, args...; sites...)</code></pre><p>Build an <code>h´::OpenHamiltonian</code> by attaching (adding) a <code>Σ::SelfEnergy</code> to a finite number of sites in <code>h</code> specified by <code>siteselector(; sites...)</code>. This also defines a &quot;contact&quot; on said sites that can be referred to (with index <code>i::Integer</code> for the i-th attached contact) when slicing Green functions later. Self-energies are taken into account when building the Green function <code>g(ω) = (ω - h´ - Σ(ω))⁻¹</code> of the resulting <code>h´</code>, see <code>greenfunction</code>.</p><p><strong>Self-energy forms</strong></p><p>The different forms of <code>args</code> yield different types of self-energies <code>Σ</code>. Currently supported forms are:</p><pre><code class="nohighlight hljs">attach(h, gs::GreenSlice, coupling::AbstractModel; sites...)</code></pre><p>Adds a generic self-energy <code>Σ(ω) = V´⋅gs(ω)⋅V</code> on <code>h</code>&#39;s <code>sites</code>, where <code>V</code> and <code>V´</code> are couplings, given by <code>coupling</code>, between said <code>sites</code> and the <code>LatticeSlice</code> in <code>gs</code>. Allowed forms of <code>gs</code> include both <code>g[bath_sites...]</code> and <code>g[contactind::Integer]</code> where <code>g</code> is any <code>GreenFunction</code>.</p><pre><code class="nohighlight hljs">attach(h, model::ParametricModel; sites...)</code></pre><p>Add self-energy <code>Σᵢⱼ(ω)</code> defined by a <code>model</code> composed of parametric terms (<code>@onsite</code> and <code>@hopping</code>) with <code>ω</code> as first argument, as in e.g. <code>@onsite((ω, r) -&gt; Σᵢᵢ(ω, r))</code> and <code>@hopping((ω, r, dr) -&gt; Σᵢⱼ(ω, r, dr))</code></p><pre><code class="nohighlight hljs">attach(h, nothing; sites...)</code></pre><p>Add null self-energy <code>Σᵢⱼ(ω) = 0</code> on selected sites, which in effect simply amounts to defining a contact on said sites, but does not lead to any dressing the Green function. This is useful for some <code>GreenFunction</code> solvers such as <code>GS.KPM</code> (see <code>greenfunction</code>), which need to know the sites of interest beforehand (the contact sites in this case).</p><pre><code class="nohighlight hljs">attach(h, g1D::GreenFunction; reverse = false, transform = identity, sites...)</code></pre><p>Add a self-energy <code>Σ(ω) = h₋₁⋅g1D(ω)[surface]⋅h₁</code> corresponding to a semi-infinite 1D lead (i.e. with a finite <code>boundary</code>, see <code>greenfunction</code>), where <code>h₁</code> and <code>h₋₁</code> are intercell couplings, and <code>g1D</code> is the lead <code>GreenFunction</code>. The <code>g1D(ω)</code> is taken at the <code>suface</code> unitcell, either adjacent to the <code>boundary</code> on its positive side (if <code>reverse = false</code>) or on its negative side (if <code>reverse = true</code>). The positions of the selected <code>sites</code> in <code>h</code> must match, modulo an arbitrary displacement, those of the lead unit cell, after applying <code>transform</code> to the latter. If they don&#39;t, use the <code>attach</code> syntax below.</p><p>Advanced: If the <code>g1D</code> does not have any self-energies, the produced self-energy is in fact an <code>ExtendedSelfEnergy</code>, which is numerically more stable than a naive implementation of <code>RegularSelfEnergy</code>&#39;s, since <code>g1D(ω)[surface]</code> is never actually computed. Conversely, if <code>g1D</code> has self-energies attached, a <code>RegularSelfEnergy</code> is produced.</p><pre><code class="nohighlight hljs">attach(h, g1D::GreenFunction, coupling::AbstractModel; reverse = false, transform = identity,  sites...)</code></pre><p>Add a self-energy <code>Σ(ω) = V´⋅g1D(ω)[surface]⋅V</code> corresponding to a 1D lead (semi-infinite or infinite), but with couplings <code>V</code> and <code>V´</code>, defined by <code>coupling</code>, between <code>sites</code> and the <code>surface</code> lead unitcell (or the one with index zero if there is no boundary) . See also Advanced note above.</p><p><strong>Currying</strong></p><pre><code class="nohighlight hljs">h |&gt; attach(args...; sites...)</code></pre><p>Curried form equivalent to <code>attach(h, args...; sites...)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # A graphene flake with two out-of-plane cubic-lattice leads

julia&gt; g1D = LP.cubic(names = :C) |&gt; hamiltonian(hopping(1)) |&gt; supercell((0,0,1), region = RP.square(4)) |&gt; greenfunction(GS.Schur(boundary = 0));

julia&gt; coupling = hopping(1, range = 2);

julia&gt; gdisk = HP.graphene(a0 = 1, dim = 3) |&gt; supercell(region = RP.circle(10)) |&gt; attach(g1D, coupling; region = RP.square(4)) |&gt; attach(g1D, coupling; region = RP.square(4), reverse = true) |&gt; greenfunction;</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`greenfunction`, `GreenSolvers`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL1319-L1397">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.bands" href="#Quantica.bands"><code>Quantica.bands</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bands(h::AbstractHamiltonian, xcolᵢ...; kw...)</code></pre><p>Construct a <code>Bandstructure</code> object, which contains in particular a collection of continuously connected <code>Subband</code>s of <code>h</code>, obtained by diagonalizing the matrix <code>h(ϕs; params...)</code> on an <code>M</code>-dimensional mesh of points <code>(x₁, x₂, ..., xₘ)</code>, where each <code>xᵢ</code> takes values in the collection <code>xcolᵢ</code>. The mapping between points in the mesh points and values of <code>(ϕs; params...)</code> is defined by keyword <code>mapping</code> (<code>identity</code> by default, see Keywords). Diagonalization is multithreaded and will use all available Julia threads (start session with <code>julia -t N</code> to have <code>N</code> threads).</p><pre><code class="nohighlight hljs">bands(f::Function, xcolᵢ...; kw...)</code></pre><p>Like the above using <code>f(ϕs)::AbstractMatrix</code> in place of <code>h(ϕs; params...)</code>, and returning a <code>Vector{&lt;:Subband}</code> instead of a <code>Bandstructure</code> object. This is provided as a lower level driver without the added slicing functionality of a full <code>Bandstructure</code> object, see below.</p><pre><code class="nohighlight hljs">bands(h::AbstractHamiltonian; kw...)</code></pre><p>Equivalent to <code>bands(h::AbstractHamiltonian, xcolᵢ...; kw...)</code> with a default <code>xcolᵢ = subdiv(-π, π, 49)</code>.</p><p><strong>Keywords</strong></p><ul><li><code>solver</code>: eigensolver to use for each diagonalization (see <code>Eigensolvers</code>). Default: <code>ES.LinearAlgebra()</code></li><li><code>mapping</code>: a function of the form <code>(x, y, ...) -&gt; ϕs</code> or <code>(x, y, ...) -&gt; ftuple(ϕs...; params...)</code> that translates points <code>(x, y, ...)</code> in the mesh to Bloch phases <code>ϕs</code> or phase+parameter FrankenTuples <code>ftuple(ϕs...; params...)</code>. See also linecuts below. Default: <code>identity</code></li><li><code>transform</code>: function to apply to each eigenvalue after diagonalization. Default: <code>identity</code></li><li><code>degtol::Real</code>: maximum distance between to nearby eigenvalue so that they are classified as degenerate. Default: <code>sqrt(eps)</code></li><li><code>split::Bool</code>: whether to split bands into disconnected subbands. Default: <code>true</code></li><li><code>projectors::Bool</code>: whether to compute interpolating subspaces in each simplex (for use as GreenSolver). Default: <code>true</code></li><li><code>warn::Bool</code>: whether to emit warning when band dislocations are encountered. Default: <code>true</code></li><li><code>showprogress::Bool</code>: whether to show or not a progress bar. Default: <code>true</code></li><li><code>defects</code>: (experimental) a collection of extra points to add to the mesh, typically the location of topological band defects such as Dirac points, so that interpolation avoids creating dislocation defects in the bands. You need to also increase <code>patches</code> to repair the subband dislocations using the added defect vertices. Default: <code>()</code></li><li><code>patches::Integer</code>: (experimental) if a dislocation is encountered, attempt to patch it by searching for the defect recursively to a given order, or using the provided <code>defects</code> (preferred). Default: <code>0</code></li></ul><p><strong>Currying</strong></p><pre><code class="nohighlight hljs">h |&gt; bands(xcolᵢ...; kw...)</code></pre><p>Curried form of <code>bands</code> equivalent to <code>bands(h, xcolᵢ...; kw...)</code></p><p><strong>Band linecuts</strong></p><p>To do a linecut of a bandstructure along a polygonal path in the <code>L</code>-dimensional Brillouin zone, mapping a set of 1D points <code>xs</code> to a set of <code>nodes</code>, with <code>pts</code> interpolation points in each segment, one can use the following convenient syntax</p><pre><code class="nohighlight hljs">bands(h, subdiv(xs, pts); mapping = (xs =&gt; nodes))</code></pre><p>Here <code>nodes</code> can be a collection of <code>SVector{L}</code> or of named Brillouin zone points from the list (<code>:Γ</code>,<code>:K</code>, <code>:K´</code>, <code>:M</code>, <code>:X</code>, <code>:Y</code>, <code>:Z</code>). If <code>mapping = nodes</code>, then <code>xs</code> defaults to <code>0:length(nodes)-1</code>. See also <code>subdiv</code> for its alternative methods.</p><p><strong>Indexing and slicing</strong></p><pre><code class="nohighlight hljs">b[i]</code></pre><p>Extract <code>i</code>-th subband from <code>b::Bandstructure</code>. <code>i</code> can also be a <code>Vector</code>, an <code>AbstractRange</code> or any other argument accepted by <code>getindex(subbands::Vector, i)</code></p><pre><code class="nohighlight hljs">b[slice::Tuple]</code></pre><p>Compute a section of <code>b::Bandstructure</code> with a &quot;plane&quot; defined by <code>slice = (ϕ₁, ϕ₂,..., ϕₗ[, ϵ])</code>, where each <code>ϕᵢ</code> or <code>ϵ</code> can be a real number (representing a fixed momentum or energy) or a <code>:</code> (unconstrained along that dimension). For bands of an <code>L</code>-dimensional lattice, <code>slice</code> will be padded to an <code>L+1</code>-long tuple with <code>:</code> if necessary. The result is a collection of of sliced <code>Subband</code>s.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; phis = range(0, 2pi, length = 50); h = LP.honeycomb() |&gt; hamiltonian(@hopping((; t = 1) -&gt; t));

julia&gt; bands(h(t = 1), phis, phis)
Bandstructure{Float64,3,2}: 3D Bandstructure over a 2-dimensional parameter space of type Float64
  Subbands  : 1
  Vertices  : 5000
  Edges     : 14602
  Simplices : 9588

julia&gt; bands(h, phis, phis; mapping = (x, y) -&gt; ftuple(0, x; t = y/2π))
Bandstructure{Float64,3,2}: 3D Bandstructure over a 2-dimensional parameter space of type Float64
  Subbands  : 1
  Vertices  : 4950
  Edges     : 14553
  Simplices : 9604

julia&gt; bands(h(t = 1), subdiv((0, 2, 3), (20, 30)); mapping = (0, 2, 3) =&gt; (:Γ, :M, :K))
Bandstructure{Float64,2,1}: 2D Bandstructure over a 1-dimensional parameter space of type Float64
  Subbands  : 1
  Vertices  : 97
  Edges     : 96
  Simplices : 96</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`spectrum`, `subdiv`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL1203-L1300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.bravais_matrix" href="#Quantica.bravais_matrix"><code>Quantica.bravais_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bravais_matrix(lat::Lattice)
bravais_matrix(h::AbstractHamiltonian)</code></pre><p>Return the Bravais matrix of lattice <code>lat</code> or AbstractHamiltonian <code>h</code>, with Bravais vectors as its columns.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; lat = lattice(sublat((0,0)), bravais = ((1.0, 2), (3, 4)));

julia&gt; bravais_matrix(lat)
2×2 SMatrix{2, 2, Float64, 4} with indices SOneTo(2)×SOneTo(2):
 1.0  3.0
 2.0  4.0
</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`lattice`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL123-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.cellsites" href="#Quantica.cellsites"><code>Quantica.cellsites</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cellsites(cell_indices, site_indices)</code></pre><p>Simple selector of sites with given <code>site_indices</code> in a given cell at <code>cell_indices</code>. Here, <code>site_indices</code> can be an index, a collection of integers or <code>:</code> (for all sites), and <code>cell_indices</code> should be a collection of <code>L</code> integers, where <code>L</code> is the lattice dimension.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`siteselector`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL1400-L1409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.combine" href="#Quantica.combine"><code>Quantica.combine</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">combine(lats::Lattice...)</code></pre><p>If all <code>lats</code> have compatible Bravais vectors, combine them into a single lattice. If necessary, sublattice names are renamed to remain unique.</p><pre><code class="nohighlight hljs">combine(hams::AbstractHamiltonians...; coupling = TighbindingModel())</code></pre><p>Combine a collection <code>hams</code> of hamiltonians into one by combining their corresponding lattices, and optionally by adding a coupling between them, given by the hopping terms in <code>coupling</code>.</p><p>Note that the <code>coupling</code> model will be applied to the combined lattice (which may have renamed sublattices to avoid name collissions). However, only hopping terms between different <code>hams</code> blocks will be applied.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # Building Bernal-stacked bilayer graphene

julia&gt; hbot = HP.graphene(a0 = 1, dim = 3, names = (:A,:B));

julia&gt; htop = translate(HP.graphene(a0 = 1, dim = 3, names = (:C,:D)), (0, 1/√3, 1/√3));

julia&gt; h2 = combine(hbot, htop; coupling = hopping(1, sublats = :B =&gt; :C) |&gt; plusadjoint)
Hamiltonian{Float64,3,2}: Hamiltonian on a 2D Lattice in 3D space
  Bloch harmonics  : 5
  Harmonic size    : 4 × 4
  Orbitals         : [1, 1, 1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 14
  Coordination     : 3.5</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`hopping`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL372-L409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.conductance" href="#Quantica.conductance"><code>Quantica.conductance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conductance(gs::GreenSlice; nambu = false)</code></pre><p>Given a slice <code>gs = g[i::Integer, j::Integer]</code> of a <code>g::GreenFunction</code>, build a partially evaluated object <code>G::Conductance</code> representing the zero-temperature, linear, differential conductance <code>Gᵢⱼ = dIᵢ/dVⱼ</code> between contacts <code>i</code> and <code>j</code> at arbitrary bias <code>ω = eV</code> in units of <code>e^2/h</code>. <code>Gᵢⱼ</code> is given by</p><pre><code class="nohighlight hljs">  Gᵢⱼ =  e^2/h × Tr{[im*δᵢⱼ(gʳ-gᵃ)Γⁱ-gʳΓⁱgᵃΓʲ]}         (nambu = false)
  Gᵢⱼ =  e^2/h × Tr{[im*δᵢⱼ(gʳ-gᵃ)Γⁱτₑ-gʳΓⁱτ₃gᵃΓʲτₑ]}   (nambu = true)</code></pre><p>Here <code>gʳ = g(ω)</code> and <code>gᵃ = (gʳ)&#39; = g(ω&#39;)</code> are the retarded and advanced Green function of the system, and <code>Γⁱ = im * (Σⁱ - Σⁱ&#39;)</code> is the decay rate at contact <code>i</code>. For Nambu systems (<code>nambu = true</code>), the matrices <code>τₑ=[I 0; 0 0]</code> and <code>τ₃ = [I 0; 0 -I]</code> ensure that charge reversal in Andreev reflections is properly taken into account. For normal systems (<code>nambu = false</code>), the total current at finite bias and temperatures is given by <span>$Iᵢ = e/h × ∫ dω ∑ⱼ [fᵢ(ω) - fⱼ(ω)] Gᵢⱼ(ω)$</span>, where <span>$fᵢ(ω)$</span> is the Fermi distribution in lead <code>i</code>.</p><p><strong>Keywords</strong></p><ul><li><code>nambu</code> : whether to consider the Hamiltonian of the system is written in a Nambu basis, each site containing <code>N</code> electron orbitals followed by <code>N</code> hole orbitals.</li></ul><p><strong>Full evaluation</strong></p><pre><code class="nohighlight hljs">G(ω; params...)</code></pre><p>Compute the conductance at the specified contacts.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # A central system g0 with two 1D leads and transparent contacts

julia&gt; glead = LP.square() |&gt; hamiltonian(hopping(1)) |&gt; supercell((1,0), region = r-&gt;-2&lt;r[2]&lt;2) |&gt; greenfunction(GS.Schur(boundary = 0));

julia&gt; g0 = LP.square() |&gt; hamiltonian(hopping(1)) |&gt; supercell(region = r-&gt;-2&lt;r[2]&lt;2 &amp;&amp; r[1]≈0) |&gt; attach(glead, reverse = true) |&gt; attach(glead) |&gt; greenfunction;

julia&gt; G = conductance(g0[1])
Conductance{Float64}: Zero-temperature conductance dIᵢ/dVⱼ from contacts i,j, in units of e^2/h
  Current contact  : 1
  Bias contact     : 1

julia&gt; G(0.2) ≈ 3
true</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`greenfunction`, `ldos`, `current`, `josephson`, `transmission`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL1703-L1751">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.current" href="#Quantica.current"><code>Quantica.current</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">current(gs::GreenSlice; charge = -I, direction = missing)</code></pre><p>Build <code>Js::CurrentDensitySlice</code>, a partially evaluated object representing the equilibrium local current density <code>Jᵢⱼ(ω)</code> at arbitrary energy <code>ω</code> from site <code>j</code> to site <code>i</code>, both taken from a specific lattice slice. The current is computed along a given <code>direction</code> (see Keywords).</p><pre><code class="nohighlight hljs">current(gω::GreenSolution; charge = -I, direction = missing)</code></pre><p>Build <code>Jω::CurrentDensitySolution</code>, as above, but for <code>Jᵢⱼ(ω)</code> at a fixed <code>ω</code> and arbitrary sites <code>i, j</code>. See also <code>greenfunction</code> for details on building a <code>GreenSlice</code> and <code>GreenSolution</code>.</p><p>The local current density is defined here as <span>$Jᵢⱼ(ω) = (2/h) rᵢⱼ Re Tr[(Hᵢⱼgⱼᵢ(ω) - gᵢⱼ(ω)Hⱼᵢ) * charge]$</span>, with the integrated local current given by <span>$Jᵢⱼ = ∫ f(ω) Jᵢⱼ(ω) dω$</span>. Here <code>Hᵢⱼ</code> is the hopping from site <code>j</code> at <code>rⱼ</code> to <code>i</code> at <code>rᵢ</code>, <code>rᵢⱼ = rᵢ - rⱼ</code>, <code>charge</code> is the charge of carriers in orbital space (see Keywords), and <code>gᵢⱼ(ω)</code> is the retarded Green function between said sites.</p><p><strong>Keywords</strong></p><ul><li><code>charge</code> : for multiorbital sites, <code>charge</code> can be a general matrix, which allows to compute arbitrary currents, such as spin currents.</li><li><code>direction</code>: as defined above, <code>Jᵢⱼ(ω)</code> is a vector. If <code>direction</code> is <code>missing</code> the norm <code>|Jᵢⱼ(ω)|</code> is returned. If it is an <code>u::Union{SVector,Tuple}</code>, <code>u⋅Jᵢⱼ(ω)</code> is returned. If an <code>n::Integer</code>, <code>Jᵢⱼ(ω)[n]</code> is returned.</li></ul><p><strong>Full evaluation</strong></p><pre><code class="nohighlight hljs">Jω[sites...]
Js(ω; params...)</code></pre><p>Given a partially evaluated <code>Jω::CurrentDensitySolution</code> or <code>ρs::CurrentDensitySlice</code>, build a sparse matrix <code>Jᵢⱼ(ω)</code> along the specified <code>direction</code> of fully evaluated local current densities.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; # A semi-infinite 1D lead with a magnetic field `B`

julia&gt; g = LP.square() |&gt; supercell((1,0), region = r-&gt;-2&lt;r[2]&lt;2) |&gt; hamiltonian(@hopping((r, dr; B = 0.1) -&gt; cis(B * dr&#39; * SA[r[2],-r[1]]))) |&gt; greenfunction(GS.Schur(boundary = 0));

julia&gt; J = current(g[cells = SA[1]])
CurrentDensitySlice{Float64} : current density at a fixed location and arbitrary energy
  charge      : LinearAlgebra.UniformScaling{Int64}(-1)
  direction   : missing

julia&gt; J(0.2; B = 0.1)
3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:
  ⋅         0.0290138   ⋅
 0.0290138   ⋅         0.0290138
  ⋅         0.0290138   ⋅

julia&gt; J(0.2; B = 0.0)
3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:
  ⋅           7.77156e-16   ⋅
 7.77156e-16   ⋅           5.55112e-16
  ⋅           5.55112e-16   ⋅</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`greenfunction`, `ldos`, `conductance`, `josephson`, `transmission`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL1638-L1700">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.energies" href="#Quantica.energies"><code>Quantica.energies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">energies(sp::Spectrum)</code></pre><p>Returns the energies in <code>sp</code> as a vector of Numbers (not necessarily real). Equivalent to <code>first(sp)</code>.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`spectrum`, `bands`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL1183-L1190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.greenfunction" href="#Quantica.greenfunction"><code>Quantica.greenfunction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">greenfunction(h::Union{AbstractHamiltonian,OpenHamiltonian}, solver::GreenSolver)</code></pre><p>Build a <code>g::GreenFunction</code> of Hamiltonian <code>h</code> using <code>solver</code>. See <code>GreenSolvers</code> for available solvers. If <code>solver</code> is not provided, a default solver is chosen automatically based on the type of <code>h</code>.</p><p><strong>Currying</strong></p><pre><code class="nohighlight hljs">h |&gt; greenfunction(solver)</code></pre><p>Curried form equivalent to <code>greenfunction(h, solver)</code>.</p><p><strong>Partial evaluation</strong></p><p><code>GreenFunction</code>s allow independent, partial evaluation of their positions (producing a <code>GreenSlice</code>) and energy/parameters (producing a <code>GreenSolution</code>). Depending on the solver, this may avoid repeating calculations unnecesarily when sweeping over either of these with the other fixed.</p><pre><code class="nohighlight hljs">g[ss]
g[siteselector(; ss...)]</code></pre><p>Build a <code>gs::GreenSlice</code> that represents a Green function at arbitrary energy and parameter values, but at specific sites on the lattice defined by <code>siteselector(; ss...)</code>, with <code>ss::NamedTuple</code> (see <code>siteselector</code>).</p><pre><code class="nohighlight hljs">g[contact_index::Integer]</code></pre><p>Build a <code>GreenSlice</code> equivalent to <code>g[contact_sites...]</code>, where <code>contact_sites...</code> correspond to sites in contact number <code>contact_index</code> (must have <code>1&lt;= contact_index &lt;= number_of_contacts</code>). See <code>attach</code> for details on attaching contacts to a Hamiltonian.</p><pre><code class="nohighlight hljs">g[:]</code></pre><p>Build a <code>GreenSlice</code> over all contacts.</p><pre><code class="nohighlight hljs">g[dst, src]</code></pre><p>Build a <code>gs::GreenSlice</code> between sites specified by <code>src</code> and <code>dst</code>, which can take any of the forms above. Therefore, all the previous single-index slice forms correspond to a diagonal block <code>g[i, i]</code>.</p><pre><code class="nohighlight hljs">g[diagonal(i, kernel = missing)]</code></pre><p>If <code>kernel = missing</code>, efficiently construct <code>diag(g[i, i])</code>. If <code>kernel</code> is a matrix, return <code>tr(g[site, site] * kernel)</code> over each site encoded in <code>i</code>. Note that if there are several orbitals per site, these will have different length (i.e. number of orbitals vs number of sites). See also <code>diagonal</code>.</p><pre><code class="nohighlight hljs">g(ω; params...)</code></pre><p>Build a <code>gω::GreenSolution</code> that represents a retarded Green function at arbitrary points on the lattice, but at fixed energy <code>ω</code> and system parameter values <code>param</code>. If <code>ω</code> is complex, the retarded or advanced Green function is returned, depending on <code>sign(imag(ω))</code>. If <code>ω</code> is <code>Real</code>, a small, positive imaginary part is automatically added internally to produce the retarded <code>g</code>.</p><pre><code class="nohighlight hljs">gω[i]
gω[i, j]
gs(ω; params...)</code></pre><p>For any <code>gω::GreenSolution</code> or <code>gs::GreenSlice</code>, build the Green function matrix fully evaluated at fixed energy, parameters and positions. The matrix is dense and has scalar elements, so that any orbital structure on each site is flattened.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = LP.honeycomb() |&gt; hamiltonian(@hopping((; t = 1) -&gt; t)) |&gt; supercell(region = RP.circle(10)) |&gt; greenfunction(GS.SparseLU())
GreenFunction{Float64,2,0}: Green function of a Hamiltonian{Float64,2,0}
  Solver          : AppliedSparseLUGreenSolver
  Contacts        : 0
  Contact solvers : ()
  Contact sizes   : ()
  ParametricHamiltonian{Float64,2,0}: Parametric Hamiltonian on a 0D Lattice in 2D space
    Bloch harmonics  : 1
    Harmonic size    : 726 × 726
    Orbitals         : [1, 1]
    Element type     : scalar (ComplexF64)
    Onsites          : 0
    Hoppings         : 2098
    Coordination     : 2.88981
    Parameters       : [:t]

julia&gt; gω = g(0.1; t = 2)
GreenSolution{Float64,2,0}: Green function at arbitrary positions, but at a fixed energy

julia&gt; ss = (; region = RP.circle(2), sublats = :B);

julia&gt; gs = g[ss]
GreenSlice{Float64,2,0}: Green function at arbitrary energy, but at a fixed lattice positions

julia&gt; gω[ss] == gs(0.1; t = 2)
true</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`GreenSolvers`, `diagonal`, `ldos`, `conductance`, `current`, `josephson`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL1412-L1511">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.hamiltonian" href="#Quantica.hamiltonian"><code>Quantica.hamiltonian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hamiltonian(lat::Lattice, model; orbitals = 1)</code></pre><p>Create a <code>Hamiltonian</code> or <code>ParametricHamiltonian</code> by applying <code>model</code> to the lattice <code>lat</code> (see <code>onsite</code>, <code>@onsite</code>, <code>hopping</code> and <code>@hopping</code> for details on building tight-binding models).</p><pre><code class="nohighlight hljs">hamiltonian(lat::Lattice, model, modifiers...; orbitals = 1)
hamiltonian(h::AbstractHamiltonian, modifiers...; orbitals = 1)</code></pre><p>Create a <code>ParametricHamiltonian</code> where all onsite and hopping terms in <code>model</code> can be parametrically modified through the provided <code>modifiers</code> (see <code>@onsite!</code> and <code>@hopping!</code> for details on defining modifiers).</p><p><strong>Keywords</strong></p><ul><li><code>orbitals</code>: number of orbitals per sublattice. If an <code>Integer</code> (or a <code>Val{&lt;:Integer}</code> for type-stability), all sublattices will have the same number of orbitals. A collection of values indicates the orbitals on each sublattice.</li></ul><p><strong>Currying</strong></p><pre><code class="nohighlight hljs">lat |&gt; hamiltonian(model[, modifiers...]; kw...)</code></pre><p>Curried form of <code>hamiltonian</code> equivalent to <code>hamiltonian(lat, model, modifiers...; kw...)</code>.</p><pre><code class="nohighlight hljs">lat |&gt; model</code></pre><p>Alternative and less general curried form equivalent to <code>hamiltonian(lat, model)</code>.</p><pre><code class="nohighlight hljs">h |&gt; modifier</code></pre><p>Alternative and less general curried form equivalent to <code>hamiltonian(h, modifier)</code>.</p><p><strong>Indexing</strong></p><pre><code class="nohighlight hljs">h[dn::SVector{L,Int}]
h[dn::NTuple{L,Int}]</code></pre><p>Return the Bloch harmonic of an <code>h::AbstractHamiltonian</code> in the form of a <code>SparseMatrixCSC</code> with complex scalar <code>eltype</code>. This matrix is &quot;flat&quot;, in the sense that it contains matrix elements between indivisual orbitals, not sites. This distinction is only relevant for multiorbital Hamiltonians. To access the non-flattened matrix use <code>h[unflat(dn)]</code> (see also <code>unflat</code>).</p><pre><code class="nohighlight hljs">h[()]</code></pre><p>Special syntax equivalent to <code>h[(0...)]</code>, which access the fundamental Bloch harmonic.</p><p><strong>Call syntax</strong></p><pre><code class="nohighlight hljs">ph(; params...)</code></pre><p>Return a <code>h::Hamiltonian</code> from a <code>ph::ParametricHamiltonian</code> by applying specific values to its parameters <code>params</code>. If <code>ph</code> is a non-parametric <code>Hamiltonian</code> instead, this is a no-op.</p><pre><code class="nohighlight hljs">h(φs; params...)</code></pre><p>Return the flat, sparse Bloch matrix of <code>h::AbstractHamiltonian</code> at Bloch phases <code>φs</code>, with applied parameters <code>params</code> if <code>h</code> is a <code>ParametricHamiltonian</code>. The Bloch matrix is defined as</p><pre><code class="nohighlight hljs">    H = ∑_dn exp(-im φs⋅dn) H_dn</code></pre><p>where <code>H_dn = h[dn]</code> is the <code>dn</code> flat Bloch harmonic of <code>h</code>, and <code>φs[i] = k⋅aᵢ</code> in terms of the wavevector <code>k</code> and the Bravais vectors <code>aᵢ</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = hamiltonian(LP.honeycomb(), hopping(SA[0 1; 1 0], range = 1/√3), orbitals = 2)
Hamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5
  Harmonic size    : 2 × 2
  Orbitals         : [2, 2]
  Element type     : 2 × 2 blocks (ComplexF64)
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 3.0

julia&gt; h((0,0))
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:
     ⋅          ⋅      0.0+0.0im  3.0+0.0im
     ⋅          ⋅      3.0+0.0im  0.0+0.0im
 0.0+0.0im  3.0+0.0im      ⋅          ⋅
 3.0+0.0im  0.0+0.0im      ⋅          ⋅</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`lattice`, `onsite`, `hopping`, `@onsite`, `@hopping`, `@onsite!`, `@hopping!`, `ishermitian`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL541-L629">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.hopping" href="#Quantica.hopping"><code>Quantica.hopping</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hopping(t; hops...)
hopping((r, dr) -&gt; t(r, dr); hops...)</code></pre><p>Build a <code>TighbindingModel</code> representing a uniform or a position-dependent hopping amplitude, respectively, on hops selected by <code>hopselector(; hops...)</code> (see <code>hopselector</code> for details).</p><p>Hops from a site at position <code>r₁</code> to another at <code>r₂</code> are described using the hop center <code>r = (r₁ + r₂)/2</code> and the hop vector <code>dr = r₂ - r₁</code>. Hopping amplitudes <code>t</code> can be a <code>Number</code> (for hops between single-orbital sites), a <code>UniformScaling</code> (e.g. <code>2I</code>) or an <code>AbstractMatrix</code> (use <code>SMatrix</code> for performance) of dimensions matching the number of orbitals in the selected sites. Models may be applied to a lattice <code>lat</code> to produce an <code>Hamiltonian</code> with <code>hamiltonian(lat, model; ...)</code>, see <code>hamiltonian</code>. Position dependent models are forced to preserve the periodicity of the lattice.</p><pre><code class="nohighlight hljs">hopping(m::Union{TighbindingModel,ParametricModel}; hops...)</code></pre><p>Convert <code>m</code> into a new model with just hopping terms acting on <code>hops</code>.</p><p><strong>Model algebra</strong></p><p>Models can be combined using <code>+</code>, <code>-</code> and <code>*</code>, or conjugated with <code>&#39;</code>, e.g. <code>onsite(1) - 2 * hopping(1)&#39;</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = hopping((r, dr) -&gt; cis(dot(SA[r[2], -r[1]], dr)); dcells = (0,0)) + onsite(r -&gt; rand())
TightbindingModel: model with 2 terms
  HoppingTerm{Function}:
    Region            : any
    Sublattice pairs  : any
    Cell distances    : (0, 0)
    Hopping range     : Neighbors(1)
    Reverse hops      : false
    Coefficient       : 1
  OnsiteTerm{Function}:
    Region            : any
    Sublattices       : any
    Cells             : any
    Coefficient       : 1

julia&gt; LP.honeycomb() |&gt; supercell(2) |&gt; hamiltonian(model)
Hamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 1
  Harmonic size    : 8 × 8
  Orbitals         : [1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 8
  Hoppings         : 16
  Coordination     : 2.0</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`onsite`, `@onsite`, `@hopping`, `@onsite!`, `@hopping!`, `hamiltonian`, `plusadjoint`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL698-L752">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.hopselector" href="#Quantica.hopselector"><code>Quantica.hopselector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hopselector(; range = neighbors(1), dcells = missing, sublats = missing, region = missing)</code></pre><p>Return a <code>HopSelector</code> object that can be used to select a finite set of hops between sites in a lattice. Hops between two sites at positions <code>r₁ = r - dr/2</code> and <code>r₂ = r + dr</code>, belonging to unit cells with a cell distance <code>dn::SVector{L,Int}</code> and to a sublattices with names <code>s₁::Symbol</code> and <code>s₂::Symbol</code> will be selected only if</p><pre><code class="nohighlight hljs">`region(r, dr) &amp;&amp; (s₁ =&gt; s₂ in sublats) &amp;&amp; (dcell in dcells) &amp;&amp; (norm(dr) &lt;= range)`</code></pre><p>If any of these is <code>missing</code> it will not be used to constraint the selection.</p><p><strong>Generalization</strong></p><p>While <code>range</code> is usually a <code>Real</code>, and <code>sublats</code> and <code>dcells</code> are usually collections of <code>Pair{Symbol}</code>s and <code>SVector</code>s, respectively, they also admit other possibilities:</p><pre><code class="nohighlight hljs">sublats = :A                       # Hops from :A to :A
sublats = :A =&gt; :B                 # Hops from :A to :B sublattices, but not from :B to :A
sublats = (:A =&gt; :B,)              # Same as above
sublats = (:A =&gt; :B, :C =&gt; :D)     # Hopping from :A to :B or :C to :D
sublats = (:A, :C) .=&gt; (:B, :D)    # Broadcasted pairs, same as above
sublats = (:A, :C) =&gt; (:B, :D)     # Direct product, (:A=&gt;:B, :A=&gt;:D, :C=&gt;:B, :C=&gt;D)
sublats = 1 =&gt; 2                   # Hops from 1st to 2nd sublat. All the above patterns also admit Ints
sublats = (spec₁, spec₂, ...)      # Hops matching any of the specs with any of the above forms

dcells  = dn::SVector{L,Integer}   # Hops between cells separated by `dn`
dcells  = dn::NTuple{L,Integer}    # Hops between cells separated by `SVector(dn)`
dcells  = f::Function              # Hops between cells separated by `dn` such that `f(dn) == true`

range   = neighbors(n)             # Hops within the `n`-th nearest neighbor distance in the lattice
range   = (min, max)               # Hops at distance inside the `[min, max]` closed interval (bounds can also be `neighbors(n)`)</code></pre><p><strong>Usage</strong></p><p>Although the constructor <code>hopselector(; kw...)</code> is exported, the end user does not usually need to call it directly. Instead, the keywords <code>kw</code> are input into different functions that allow filtering hops, which themselves call <code>hopselector</code> internally as needed. Some of these functions are</p><pre><code class="nohighlight hljs">- hopping(...; kw...)   : hopping model term to be applied to site pairs specified by `kw`
- @hopping(...; kw...)  : parametric hopping model term to be applied to site pairs specified by `kw`
- @hopping!(...; kw...) : hopping modifier to be applied to site pairs specified by `kw`</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = LP.honeycomb() |&gt; hamiltonian(hopping(1, range = neighbors(2), sublats = (:A, :B) .=&gt; (:A, :B)))
Hamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 7
  Harmonic size    : 2 × 2
  Orbitals         : [1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 12
  Coordination     : 6.0

julia&gt; h = LP.honeycomb() |&gt; hamiltonian(hopping(1, range = (neighbors(2), neighbors(3)), sublats = (:A, :B) =&gt; (:A, :B)))
Hamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 9
  Harmonic size    : 2 × 2
  Orbitals         : [1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 18
  Coordination     : 9.0</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`siteselector`, `lattice`, `hopping`, `@hopping`, `@hopping!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL451-L522">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.josephson" href="#Quantica.josephson"><code>Quantica.josephson</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">josephson(gs::GreenSlice, ωmax; kBT = 0.0, phases = missing, imshift = missing, slope = 1, post = real, atol = 1e-7, quadgk_opts...)</code></pre><p>For a <code>gs = g[i::Integer]</code> slice of the <code>g::GreenFunction</code> of a hybrid junction, build a partially evaluated object <code>J::Integrator</code> representing the equilibrium (static) Josephson current <code>I_J</code> flowing into <code>g</code> through contact <code>i</code>, integrated from <code>-ωmax</code> to <code>ωmax</code> (or from <code>-ωmax</code> to <code>0</code> at zero temperature <code>kBT = 0</code>). The result of <code>I_J</code> is given in units of <code>qe/h</code> (<code>q</code> is the dimensionless carrier charge). <code>I_J</code> can be written as <span>$I_J = Re ∫ dω f(ω) j(ω)$</span>, where <span>$j(ω) = (qe/h) × 2Tr[(ΣʳᵢGʳ - GʳΣʳᵢ)τz]$</span>.</p><p><strong>Full evaluation</strong></p><pre><code class="nohighlight hljs">J(; params...)</code></pre><p>Evaluate the Josephson current <code>I_J</code> for the given <code>g</code> parameters <code>params</code>, if any.</p><p><strong>Keywords</strong></p><ul><li><code>kBT</code> : temperature in same energy units as the Hamiltonian</li><li><code>phases</code> : collection of superconducting phase biases to apply to the contact, so as to efficiently compute the full current-phase relation <code>[I_J(ϕ) for ϕ in phases]</code>. Note that each phase bias <code>ϕ</code> is applied by a <code>[cis(-ϕ/2) 0; 0 cis(ϕ/2)]</code> rotation to the self energy, which is almost free. If <code>missing</code>, a single <code>I_J</code> is returned.</li><li><code>imshift</code>: if <code>missing</code> the initial and final integration points <code>± ωmax</code> are shifted by <code>im * sqrt(eps(ωmax))</code>, to avoid the real axis. Otherwise a shift <code>im*imshift</code> is applied (may be zero if <code>ωmax</code> is greater than the bandwidth).</li><li><code>slope</code>: if non-zero, the integration will be performed along a piecewise-linear path in the complex plane <code>(-ωmax, -ωmax/2 * (1+slope*im), 0, ωmax/2 * (1+slope*im), ωmax)</code>, taking advantage of the holomorphic integrand <code>f(ω) j(ω)</code> and the Cauchy Integral Theorem for faster convergence.</li><li><code>post</code>: function to apply to the result of <code>∫ dω f(ω) j(ω)</code> to obtain the result, <code>post = real</code> by default.</li><li><code>atol</code>: absolute integration tolerance. The default <code>1e-7</code> is chosen to avoid excessive integration times when the current is actually zero.</li><li><code>quadgk_opts</code> : extra keyword arguments (other than <code>atol</code>) to pass on to the function <code>QuadGK.quadgk</code> that is used for the integration.</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; glead = LP.square() |&gt; hamiltonian(onsite(0.0005 * SA[0 1; 1 0]) + hopping(SA[1 0; 0 -1]), orbitals = 2) |&gt; supercell((1,0), region = r-&gt;-2&lt;r[2]&lt;2) |&gt; greenfunction(GS.Schur(boundary = 0));

julia&gt; g0 = LP.square() |&gt; hamiltonian(hopping(SA[1 0; 0 -1]), orbitals = 2) |&gt; supercell(region = r-&gt;-2&lt;r[2]&lt;2 &amp;&amp; r[1]≈0) |&gt; attach(glead, reverse = true) |&gt; attach(glead) |&gt; greenfunction;

julia&gt; J = josephson(g0[1], 4; phases = subdiv(0, pi, 10))
Integrator: Complex-plane integrator
  Integration path    : (-4.0 + 1.4901161193847656e-8im, -2.0 + 2.000000014901161im, 0.0 + 1.4901161193847656e-8im)
  Integration options : (atol = 1.0e-7,)
  Integrand:          :
  JosephsonDensity{Float64} : Equilibrium (dc) Josephson current observable before integration over energy
    kBT                     : 0.0
    Contact                 : 1
    Number of phase shifts  : 10

julia&gt; J()
10-element Vector{Float64}:
 -8.240920080846876e-16
  0.0016315088241543722
  0.003213820056116566
  0.004699191781509914
  0.006042752632291697
  0.007203835441100842
  0.008147188939637184
  0.008844017741697798
  0.009272686486294741
  9.310666393245707e-13</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`greenfunction`,`ldos`, `current`, `conductance`, `transmission`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL1796-L1855">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.lattice" href="#Quantica.lattice"><code>Quantica.lattice</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lattice(sublats::Sublat...; bravais = (), dim, type, names)
lattice(sublats::AbstractVector{&lt;:Sublat}; bravais = (), dim, type, names)</code></pre><p>Create a <code>Lattice{T,E,L}</code> from sublattices <code>sublats</code>, where <code>L</code> is the number of Bravais vectors given by <code>bravais</code>, <code>T = type</code> is the <code>AbstractFloat</code> type of spatial site coordinates, and <code>dim = E</code> is the spatial embedding dimension.</p><pre><code class="nohighlight hljs">lattice(lat::Lattice; bravais = missing, dim = missing, type = missing, names = missing)</code></pre><p>Create a new lattice by applying any non-missing keywords to <code>lat</code>.</p><pre><code class="nohighlight hljs">lattice(x)</code></pre><p>Return the parent lattice of object <code>x</code>, of type e.g. <code>LatticeSlice</code>, <code>Hamiltonian</code>, etc.</p><p><strong>Keywords</strong></p><ul><li><code>bravais</code>: a collection of one or more Bravais vectors of type NTuple{E} or SVector{E}. It can also be an <code>AbstractMatrix</code> of dimension <code>E×L</code>. The default <code>bravais = ()</code> corresponds to a bounded lattice with no Bravais vectors.</li><li><code>names</code>: a collection of Symbols. Can be used to rename <code>sublats</code>. Any repeated names will be replaced if necessary by <code>:A</code>, <code>:B</code> etc. to ensure that all sublattice names are unique.</li></ul><p><strong>Indexing</strong></p><pre><code class="nohighlight hljs">lat[kw...]</code></pre><p>Indexing into a lattice <code>lat</code> with keywords returns <code>LatticeSlice</code> representing a finite collection of sites selected by <code>siteselector(; kw...)</code>. See <code>siteselector</code> for details on possible <code>kw</code>, and <code>sites</code> to obtain site positions.</p><pre><code class="nohighlight hljs">lat[]</code></pre><p>Special case equivalent to <code>lat[cells = (0,...)]</code> that returns a <code>LatticeSlice</code> of the zero-th unitcell.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; lat = lattice(sublat((0, 0)), sublat((0, 1)); bravais = (1, 0), type = Float32, dim = 3, names = (:up, :down))
Lattice{Float32,3,1} : 1D lattice in 3D space
  Bravais vectors : Vector{Float32}[[1.0, 0.0, 0.0]]
  Sublattices     : 2
    Names         : (:up, :down)
    Sites         : (1, 1) --&gt; 2 total per unit cell

julia&gt; lattice(lat; type = Float64, names = (:A, :B), dim = 2)
Lattice{Float64,2,1} : 1D lattice in 2D space
  Bravais vectors : [[1.0, 0.0]]
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (1, 1) --&gt; 2 total per unit cell</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`LatticePresets`, `sublat`, `sites`, `supercell`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL147-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.ldos" href="#Quantica.ldos"><code>Quantica.ldos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ldos(gs::GreenSlice; kernel = I)</code></pre><p>Build <code>ρs::LocalSpectralDensitySlice</code>, a partially evaluated object representing the local density of states <code>ρᵢ(ω)</code> at specific sites <code>i</code> but at arbitrary energy <code>ω</code>.</p><pre><code class="nohighlight hljs">ldos(gω::GreenSolution; kernel = I)</code></pre><p>Build <code>ρω::LocalSpectralDensitySolution</code>, as above, but for <code>ρᵢ(ω)</code> at a fixed <code>ω</code> and arbitrary sites <code>i</code>. See also <code>greenfunction</code> for details on building a <code>GreenSlice</code> and <code>GreenSolution</code>.</p><p>The local density of states is defined here as <span>$ρᵢ(ω) = -Tr(gᵢᵢ(ω))/π$</span>, where <code>gᵢᵢ(ω)</code> is the retarded Green function at a given site <code>i</code>.</p><p><strong>Keywords</strong></p><ul><li><code>kernel</code> : for multiorbital sites, <code>kernel</code> allows to compute a generalized <code>ldos</code> <code>ρᵢ(ω) = -Tr(gᵢᵢ(ω) * kernel)/π</code>, where <code>gᵢᵢ(ω)</code> is the retarded Green function at site <code>i</code> and energy <code>ω</code>. If <code>kernel = missing</code>, the complete, orbital-resolved <code>ldos</code> is returned.</li></ul><p><strong>Full evaluation</strong></p><pre><code class="nohighlight hljs">ρω[sites...]
ρs(ω; params...)</code></pre><p>Given a partially evaluated <code>ρω::LocalSpectralDensitySolution</code> or <code>ρs::LocalSpectralDensitySlice</code>, build a vector <code>[ρ₁(ω), ρ₂(ω)...]</code> of fully evaluated local densities of states.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; g = HP.graphene(a0 = 1, t0 = 1) |&gt; supercell(region = RP.circle(20)) |&gt; attach(nothing, region = RP.circle(1)) |&gt; greenfunction(GS.KPM(order = 300, bandrange = (-3.1, 3.1)))
GreenFunction{Float64,2,0}: Green function of a Hamiltonian{Float64,2,0}
  Solver          : AppliedKPMGreenSolver
  Contacts        : 1
  Contact solvers : (SelfEnergyEmptySolver,)
  Contact sizes   : (6,)
  Hamiltonian{Float64,2,0}: Hamiltonian on a 0D Lattice in 2D space
    Bloch harmonics  : 1
    Harmonic size    : 2898 × 2898
    Orbitals         : [1, 1]
    Element type     : scalar (ComplexF64)
    Onsites          : 0
    Hoppings         : 8522
    Coordination     : 2.94065

julia&gt; ldos(g(0.2))[1]
6-element Vector{Float64}:
 0.036802204179316955
 0.034933055722650375
 0.03493305572265026
 0.03493305572265034
 0.03493305572265045
 0.036802204179317045

julia&gt; ldos(g(0.2))[1] == -imag.(g[diagonal(1; kernel = I)](0.2)) ./ π
true</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`greenfunction`, `diagonal`, `current`, `conductance`, `josephson`, `transmission`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL1574-L1635">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.neighbors" href="#Quantica.neighbors"><code>Quantica.neighbors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">neighbors(n::Int)</code></pre><p>Create a <code>Neighbors(n)</code> object that represents a hopping range to distances corresponding to the n-th nearest neighbors in a given lattice, irrespective of their sublattice. Neighbors at equal distance do not count towards <code>n</code>.</p><pre><code class="nohighlight hljs">neighbors(n::Int, lat::Lattice)</code></pre><p>Obtain the actual nth-nearest-neighbot distance between sites in lattice <code>lat</code>.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`hopping`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL525-L538">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.onsite" href="#Quantica.onsite"><code>Quantica.onsite</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">onsite(o; sites...)
onsite(r -&gt; o(r); sites...)</code></pre><p>Build a <code>TighbindingModel</code> representing a uniform or a position-dependent onsite potential, respectively, on sites selected by <code>siteselector(; sites...)</code> (see <code>siteselector</code> for details).</p><p>Site positions are <code>r::SVector{E}</code>, where <code>E</code> is the embedding dimension of the lattice. The onsite potential <code>o</code> can be a <code>Number</code> (for single-orbital sites), a <code>UniformScaling</code> (e.g. <code>2I</code>) or an <code>AbstractMatrix</code> (use <code>SMatrix</code> for performance) of dimensions matching the number of orbitals in the selected sites. Models may be applied to a lattice <code>lat</code> to produce a <code>Hamiltonian</code> with <code>hamiltonian(lat, model; ...)</code>, see <code>hamiltonian</code>. Position dependent models are forced to preserve the periodicity of the lattice.</p><pre><code class="nohighlight hljs">onsite(m::{TighbindingModel,ParametricModel}; sites...)</code></pre><p>Convert <code>m</code> into a new model with just onsite terms acting on <code>sites</code>.</p><p><strong>Model algebra</strong></p><p>Models can be combined using <code>+</code>, <code>-</code> and <code>*</code>, or conjugated with <code>&#39;</code>, e.g. <code>onsite(1) - 2 * hopping(1)&#39;</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = onsite(r -&gt; norm(r) * SA[0 1; 1 0]; sublats = :A) - hopping(I; range = 2)
TightbindingModel: model with 2 terms
  OnsiteTerm{Function}:
    Region            : any
    Sublattices       : A
    Cells             : any
    Coefficient       : 1
  HoppingTerm{LinearAlgebra.UniformScaling{Bool}}:
    Region            : any
    Sublattice pairs  : any
    Cell distances    : any
    Hopping range     : 2.0
    Reverse hops      : false
    Coefficient       : -1

julia&gt; LP.cubic() |&gt; supercell(4) |&gt; hamiltonian(model, orbitals = 2)
Hamiltonian{Float64,3,3}: Hamiltonian on a 3D Lattice in 3D space
  Bloch harmonics  : 27
  Harmonic size    : 64 × 64
  Orbitals         : [2]
  Element type     : 2 × 2 blocks (ComplexF64)
  Onsites          : 64
  Hoppings         : 2048
  Coordination     : 32.0</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`hopping`, `@onsite`, `@hopping`, `@onsite!`, `@hopping!`, `hamiltonian`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL641-L695">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.plusadjoint" href="#Quantica.plusadjoint"><code>Quantica.plusadjoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plusadjoint(t::Model)</code></pre><p>Returns a model <code>t + t&#39;</code>. This is a convenience function analogous to the <code>+ h.c.</code> notation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = hopping(im, sublats = :A =&gt; :B) |&gt; plusadjoint
TightbindingModel: model with 2 terms
  HoppingTerm{Complex{Bool}}:
    Region            : any
    Sublattice pairs  : :A =&gt; :B
    Cell distances    : any
    Hopping range     : Neighbors(1)
    Reverse hops      : false
    Coefficient       : 1
  HoppingTerm{Complex{Int64}}:
    Region            : any
    Sublattice pairs  : :A =&gt; :B
    Cell distances    : any
    Hopping range     : Neighbors(1)
    Reverse hops      : true
    Coefficient       : 1

julia&gt; h = hamiltonian(LP.honeycomb(), model)
Hamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5
  Harmonic size    : 2 × 2
  Orbitals         : [1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 3.0

julia&gt; h((0,0))
2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:
     ⋅      0.0-3.0im
 0.0+3.0im      ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL977-L1017">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.sites" href="#Quantica.sites"><code>Quantica.sites</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sites(lat::Lattice[, sublat])</code></pre><p>Return a collection of site positions in the unit cell of lattice <code>lat</code>. If a <code>sublat::Symbol</code> or <code>sublat::Int</code> is specified, only sites for the specified sublattice are returned.</p><pre><code class="nohighlight hljs">sites(ls::LatticeSlice)</code></pre><p>Return a collection of positions of a LatticeSlice, generally obtained by indexing a lattice <code>lat[sel...]</code> with some <code>siteselector</code> keywords <code>sel</code>. See also <code>lattice</code>.</p><p>Note: the returned collections can be of different types (vectors, generators, views...)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sites(LatticePresets.honeycomb(), :A)
1-element view(::Vector{SVector{2, Float64}}, 1:1) with eltype SVector{2, Float64}:
 [0.0, -0.2886751345948129]</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`lattice`, `siteselector`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL204-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.siteselector" href="#Quantica.siteselector"><code>Quantica.siteselector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">siteselector(; region = missing, sublats = missing, cells = missing)</code></pre><p>Return a <code>SiteSelector</code> object that can be used to select a finite set of sites in a lattice. Sites at position <code>r::SVector{E}</code>, belonging to a cell of index <code>n::SVector{L,Int}</code> and to a sublattice with name <code>s::Symbol</code> will be selected only if</p><pre><code class="nohighlight hljs">`region(r) &amp;&amp; s in sublats &amp;&amp; n in cells`</code></pre><p>Any missing <code>region</code>, <code>sublat</code> or <code>cells</code> will not be used to constraint the selection.</p><p><strong>Generalization</strong></p><p>While <code>sublats</code> and <code>cells</code> are usually collections of <code>Symbol</code>s and <code>SVector</code>s, respectively, they also admit other possibilities:</p><ul><li>If either <code>cells</code> or <code>sublats</code> are a single cell or sublattice, they will be treated as single-element collections</li><li>If <code>sublat</code> is a collection of <code>Integer</code>s, it will refer to sublattice numbers.</li><li>If <code>cells</code> is an <code>i::Integer</code>, it will be converted to an <code>SVector{1}</code></li><li>If <code>cells</code> is a collection, each element will be converted to an <code>SVector</code>.</li><li>If <code>cells</code> is a boolean function, <code>n in cells</code> will be the result of <code>cells(n)</code></li></ul><p><strong>Usage</strong></p><p>Although the constructor <code>siteselector(; kw...)</code> is exported, the end user does not usually need to call it directly. Instead, the keywords <code>kw</code> are input into different functions that allow filtering sites, which themselves call <code>siteselector</code> internally as needed. Some of these functions are</p><ul><li>getindex(lat::Lattice; kw...) : return a LatticeSlice with sites specified by <code>kw</code> (also <code>lat[kw...]</code>)</li><li>supercell(lat::Lattice; kw...) : returns a bounded lattice with the sites specified by <code>kw</code></li><li>onsite(...; kw...) : onsite model term to be applied to sites specified by <code>kw</code></li><li>@onsite!(...; kw...) : onsite modifier to be applied to sites specified by <code>kw</code></li></ul><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`hopselector`, `lattice`, `supercell`, `onsite`, `@onsite`, `@onsite!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL412-L448">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.spectrum" href="#Quantica.spectrum"><code>Quantica.spectrum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spectrum(h::AbstractHamiltonian, ϕs; solver = EigenSolvers.LinearAlgebra(), transform = missing, params...)</code></pre><p>Compute the <code>Spectrum</code> of the Bloch matrix <code>h(ϕs; params...)</code> using the specified eigensolver, with <code>transform</code> applied to the resulting eigenenergies, if not <code>missing</code>. Eigenpairs are sorted by the real part of their energy. See <code>EigenSolvers</code> for available solvers and their options.</p><pre><code class="nohighlight hljs">spectrum(h::AbstractHamiltonian; kw...)</code></pre><p>For a 0D <code>h</code>, equivalent to <code>spectrum(h, (); kw...)</code></p><pre><code class="nohighlight hljs">spectrum(m::AbstractMatrix; solver = EigenSolvers.LinearAlgebra()], transform = missing)</code></pre><p>Compute the <code>Spectrum</code> of matrix <code>m</code> using <code>solver</code> and <code>transform</code>.</p><pre><code class="nohighlight hljs">spectrum(b::Bandstructure, ϕs)</code></pre><p>Compute the <code>Spectrum</code> corresponding to slicing the bandstructure <code>b</code> at point <code>ϕs</code> of its base mesh (see <code>bands</code> for details).</p><p><strong>Indexing and destructuring</strong></p><p>Eigenenergies <code>ϵs::Tuple</code> and eigenstates <code>ψs::Matrix</code> can be extracted from a spectrum <code>sp</code> using any of the following</p><pre><code class="nohighlight hljs">ϵs, ψs = sp
ϵs = first(sp)
ϵs = energies(sp)
ψs = last(sp)
ψs = states(sp)</code></pre><p>In addition, one can extract the <code>n</code> eigenpairs closest (in real energy) to a given energy <code>ϵ₀</code> with</p><pre><code class="nohighlight hljs">ϵs, ψs = sp[1:n, around = ϵ₀]</code></pre><p>More generally, <code>sp[inds, around = ϵ₀]</code> will take the eigenpairs at position given by <code>inds</code> after sorting by increasing distance to <code>ϵ₀</code>, or the closest eigenpair in <code>inds</code> is missing. If <code>around</code> is omitted, the ordering in <code>sp</code> is used.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = HP.graphene(t0 = 1); spectrum(h, (0,0))
Spectrum{Float64,ComplexF64} :
Energies:
2-element Vector{ComplexF64}:
 -2.9999999999999982 + 0.0im
  2.9999999999999982 + 0.0im
States:
2×2 Matrix{ComplexF64}:
 -0.707107+0.0im  0.707107+0.0im
  0.707107+0.0im  0.707107+0.0im</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`EigenSolvers`, `bands`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL1122-L1180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.states" href="#Quantica.states"><code>Quantica.states</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">states(sp::Spectrum)</code></pre><p>Returns the eigenstates in <code>sp</code> as columns of a matrix. Equivalent to <code>last(sp)</code>.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`spectrum`, `bands`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL1193-L1200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.subdiv" href="#Quantica.subdiv"><code>Quantica.subdiv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subdiv((x₁, x₂, ..., xₙ), (p₁, p₂, ..., pₙ₋₁))</code></pre><p>Build a vector of values between <code>x₁</code> and <code>xₙ</code> containing all <code>xᵢ</code> such that in each interval <code>[xᵢ, xᵢ₊₁]</code> there are <code>pᵢ</code> equally space values.</p><pre><code class="nohighlight hljs">subdiv((x₁, x₂, ..., xₙ), p)</code></pre><p>Same as above with all <code>pᵢ = p</code></p><pre><code class="nohighlight hljs">subdiv(x₁, x₂, p)</code></pre><p>Equivalent to <code>subdiv((x₁, x₂), p) == collect(range(x₁, x₂, length = p))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL1303-L1316">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.sublat" href="#Quantica.sublat"><code>Quantica.sublat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sublat(sites...; name::Symbol = :A)
sublat(sites::AbstractVector; name::Symbol = :A)</code></pre><p>Create a <code>Sublat{E,T}</code> that adds a sublattice, of name <code>name</code>, with sites at positions <code>sites</code> in <code>E</code> dimensional space. Sites positions can be entered as <code>Tuple</code>s or <code>SVector</code>s.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sublat((0.0, 0), (1, 1), (1, -1), name = :A)
Sublat{2,Float64} : sublattice of Float64-typed sites in 2D space
  Sites    : 3
  Name     : :A</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL105-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.supercell" href="#Quantica.supercell"><code>Quantica.supercell</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">supercell(lat::Lattice{E,L}, v::NTuple{L,Integer}...; seed = missing, kw...)
supercell(lat::Lattice{E,L}, uc::SMatrix{L,L´,Int}; seed = missing, kw...)</code></pre><p>Generate a new <code>Lattice</code> from an <code>L</code>-dimensional lattice <code>lat</code> with a larger unit cell, such that its Bravais vectors are <code>br´= br * uc</code>. Here <code>uc::SMatrix{L,L´,Int}</code> is the integer supercell matrix, with the <code>L´</code> vectors <code>v</code>s as its columns. If no <code>v</code> are given, the new lattice will have no Bravais vectors (i.e. it will be bounded, with its shape determined by keywords <code>kw...</code>). Likewise, if <code>L´ &lt; L</code>, the resulting lattice will be bounded along <code>L´ - L</code> directions, as dictated by <code>kw...</code>.</p><p>Only sites selected by <code>siteselector(; kw...)</code> will be included in the supercell (see <code>siteselector</code> for details on the available keywords <code>kw</code>). If no keyword <code>region</code> is given in <code>kw</code>, a single Bravais unit cell perpendicular to the <code>v</code> axes will be selected along the <code>L-L´</code> bounded directions.</p><pre><code class="nohighlight hljs">supercell(lattice::Lattice{E,L}, factors::Integer...; seed = missing, kw...)</code></pre><p>Call <code>supercell</code> with different scaling along each Bravais vector, so that supercell matrix <code>uc</code> is <code>Diagonal(factors)</code>. If a single <code>factor</code> is given, <code>uc = SMatrix{L,L}(factor * I)</code></p><pre><code class="nohighlight hljs">supercell(h::Hamiltonian, v...; mincoordination = 0, seed = missing, kw...)</code></pre><p>Transform the <code>Lattice</code> of <code>h</code> to have a larger unit cell, while expanding the Hamiltonian accordingly.</p><p><strong>Keywords</strong></p><ul><li><code>seed::NTuple{L,Integer}</code>: starting cell index to perform search of included sites. By default <code>seed = missing</code>, which makes search start from the zero-th cell.</li><li><code>mincoordination::Integer</code>: minimum number of nonzero hopping neighbors required for sites to be included in the supercell. Sites with less coordination will be removed recursively, until all remaining sites satisfy <code>mincoordination</code>.</li></ul><p><strong>Currying</strong></p><pre><code class="nohighlight hljs">lat_or_h |&gt; supercell(v...; kw...)</code></pre><p>Curried syntax, equivalent to <code>supercell(lat_or_h, v...; kw...)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LatticePresets.square() |&gt; supercell((1, 1), region = r -&gt; 0 &lt; r[1] &lt; 5)
Lattice{Float64,2,1} : 1D lattice in 2D space
  Bravais vectors : [[1.0, 1.0]]
  Sublattices     : 1
    Names         : (:A,)
    Sites         : (8,) --&gt; 8 total per unit cell

julia&gt; LatticePresets.honeycomb() |&gt; supercell(3)
Lattice{Float64,2,2} : 2D lattice in 2D space
  Bravais vectors : [[1.5, 2.598076], [-1.5, 2.598076]]
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (9, 9) --&gt; 18 total per unit cell</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`supercell`, `siteselector`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL230-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.transform" href="#Quantica.transform"><code>Quantica.transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform(lat_or_h::Union{Lattice,AbstractHamiltonian}, f::Function)</code></pre><p>Build a new lattice or hamiltonian transforming each site positions <code>r</code> into <code>f(r)</code>.</p><p><strong>Currying</strong></p><pre><code class="nohighlight hljs">x |&gt; transform(f::Function)</code></pre><p>Curried version of <code>transform</code>, equivalent to <code>transform(f, x)</code></p><p>Note: Unexported <code>Quantica.transform!</code> is also available for in-place transforms. Use with care, as aliasing (i.e. several objects sharing the modified one) can produce unexpected results.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LatticePresets.square() |&gt; transform(r -&gt; 3r)
Lattice{Float64,2,2} : 2D lattice in 2D space
  Bravais vectors : [[3.0, 0.0], [0.0, 3.0]]
  Sublattices     : 1
    Names         : (:A,)
    Sites         : (1,) --&gt; 1 total per unit cell</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`translate`, `reverse`, `reverse!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL310-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.translate" href="#Quantica.translate"><code>Quantica.translate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">translate(lat::Lattice, δr)</code></pre><p>Build a new lattice translating each site positions from <code>r</code> to <code>r + δr</code>, where <code>δr</code> can be a <code>NTuple</code> or an <code>SVector</code> in embedding space.</p><p><strong>Currying</strong></p><pre><code class="nohighlight hljs">x |&gt; translate(δr)</code></pre><p>Curried version of <code>translate</code>, equivalent to <code>translate(x, δr)</code></p><p>Note: Unexported <code>Quantica.translate!</code> is also available for in-place translations. Use with care, as aliasing (i.e. several objects sharing the modified one) can produce unexpected results.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LatticePresets.square() |&gt; translate((3,3)) |&gt; sites
1-element Vector{SVector{2, Float64}}:
 [3.0, 3.0]
</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`transform`, `reverse`, `reverse!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL341-L369">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.transmission" href="#Quantica.transmission"><code>Quantica.transmission</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transmission(gs::GreenSlice)</code></pre><p>Given a slice <code>gs = g[i::Integer, j::Integer]</code> of a <code>g::GreenFunction</code>, build a partially evaluated object <code>T::Transmission</code> representing the normal transmission probability <code>Tᵢⱼ(ω)</code> from contact <code>j</code> to <code>i</code> at energy <code>ω</code>. It can be written as <span>$Tᵢⱼ = Tr{gʳΓⁱgᵃΓʲ}$</span>. Here <code>gʳ = g(ω)</code> and <code>gᵃ = (gʳ)&#39; = g(ω&#39;)</code> are the retarded and advanced Green function of the system, and <code>Γⁱ = im * (Σⁱ - Σⁱ&#39;)</code> is the decay rate at contact <code>i</code></p><p><strong>Full evaluation</strong></p><pre><code class="nohighlight hljs">T(ω; params...)</code></pre><p>Compute the transmission <code>Tᵢⱼ(ω)</code> at a given <code>ω</code> and for the specified <code>params</code> of <code>g</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # A central system g0 with two 1D leads and transparent contacts

julia&gt; glead = LP.square() |&gt; hamiltonian(hopping(1)) |&gt; supercell((1,0), region = r-&gt;-2&lt;r[2]&lt;2) |&gt; greenfunction(GS.Schur(boundary = 0));

julia&gt; g0 = LP.square() |&gt; hamiltonian(hopping(1)) |&gt; supercell(region = r-&gt;-2&lt;r[2]&lt;2 &amp;&amp; r[1]≈0) |&gt; attach(glead, reverse = true) |&gt; attach(glead) |&gt; greenfunction;

julia&gt; T = transmission(g0[2, 1])
Transmission: total transmission between two different contacts
  From contact  : 1
  To contact    : 2

julia&gt; T(0.2) ≈ 3   # The difference from 3 is due to the automatic `im*sqrt(eps(Float64))` added to `ω`
false

julia&gt; T(0.2 + 1e-10im) ≈ 3
true</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`greenfunction`, `conductance`, `ldos`, `current`, `josephson`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL1754-L1793">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.unflat" href="#Quantica.unflat"><code>Quantica.unflat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unflat(dn)</code></pre><p>Construct an <code>u::Unflat</code> object wrapping some indices <code>dn</code>. This object is meant to be used to index into a <code>h::AbstractHamiltonian</code> as <code>h[u]</code>, which returns an non-flattened version of the Bloch harmonic <code>h[dn]</code>. Each element in the matrix <code>h[u]</code> is an <code>SMatrix</code> block representing onsite or hoppings between whole sites, in contrast to <code>h[dn]</code> where they are scalars representing single orbitals. This is only relevant for multi-orbital Hamiltonians <code>h</code>.</p><pre><code class="nohighlight hljs">unflat()</code></pre><p>Equivalent to <code>unflat(())</code></p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; h = HP.graphene(orbitals = 2); h[unflat(0,0)]
2×2 SparseArrays.SparseMatrixCSC{SMatrix{2, 2, ComplexF64, 4}, Int64} with 2 stored entries:
                     ⋅                       [2.7+0.0im 0.0+0.0im; 0.0+0.0im 2.7+0.0im]
 [2.7+0.0im 0.0+0.0im; 0.0+0.0im 2.7+0.0im]                      ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL1061-L1083">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.wrap" href="#Quantica.wrap"><code>Quantica.wrap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wrap(h::AbstractHamiltonian, (ϕ₁, ϕ₂,...))</code></pre><p>For an <code>h</code> of lattice dimension <code>L</code> and a set of <code>L</code> Bloch phases <code>ϕ = (ϕ₁, ϕ₂,...)</code>, contruct a new zero-dimensional <code>h´::AbstractHamiltonian</code> for all Bravais vectors have been eliminated by wrapping the lattice onto itself along the corresponding Bravais vector. Intercell hoppings along wrapped directions will pick up a Bloch phase <code>exp(-iϕ⋅dn)</code>.</p><p>If a number <code>L´</code> of phases <code>ϕᵢ</code> are <code>:</code> instead of numbers, the corresponding Bravais vectors will not be wrapped, and the resulting <code>h´</code> will have a finite lattice dimension <code>L´</code>.</p><p><strong>Currying</strong></p><pre><code class="nohighlight hljs">h |&gt; wrap((ϕ₁, ϕ₂,...))</code></pre><p>Currying syntax equivalent to <code>wrap(h, (ϕ₁, ϕ₂,...))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h2D = HP.graphene(); h1D = wrap(h2D, (:, 0.2))
Hamiltonian{Float64,2,1}: Hamiltonian on a 1D Lattice in 2D space
  Bloch harmonics  : 3
  Harmonic size    : 2 × 2
  Orbitals         : [1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 4
  Coordination     : 2.0

julia&gt; h2D((0.3, 0.2)) ≈ h1D(0.3)
true</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`hamiltonian`, `supercell`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL1020-L1058">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.@hopping" href="#Quantica.@hopping"><code>Quantica.@hopping</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@hopping((; params...) -&gt; t(; params...); hops...)
@hopping((r, dr; params...) -&gt; t(r; params...); hops...)</code></pre><p>Build a <code>ParametricModel</code> representing a uniform or a position-dependent hopping amplitude, respectively, on hops selected by <code>hopselector(; hops...)</code> (see <code>hopselector</code> for details).</p><p>Hops from a site at position <code>r₁</code> to another at <code>r₂</code> are described using the hop center <code>r = (r₁ + r₂)/2</code> and the hop vector <code>dr = r₂ - r₁</code>. Hopping amplitudes <code>t</code> can be a <code>Number</code> (for hops between single-orbital sites), a <code>UniformScaling</code> (e.g. <code>2I</code>) or an <code>AbstractMatrix</code> (use <code>SMatrix</code> for performance) of dimensions matching the number of site orbitals in the selected sites. Parametric models may be applied to a lattice <code>lat</code> to produce a <code>ParametricHamiltonian</code> with <code>hamiltonian(lat, model; ...)</code>, see <code>hamiltonian</code>. Position dependent models are forced to preserve the periodicity of the lattice.</p><p>The difference between regular and parametric tight-binding models (see <code>onsite</code> and <code>hopping</code>) is that parametric models may depend on arbitrary parameters, specified by the <code>params</code> keyword arguments. These are inherited by <code>h::ParametricHamiltonian</code>, which can then be evaluated very efficiently for different parameter values by callling <code>h(; params...)</code>, to obtain a regular <code>Hamiltonian</code> without reconstructing it from scratch.</p><pre><code class="nohighlight hljs">@hopping((ω; params...) -&gt; Σᵢⱼ(ω; params...); hops...)
@hopping((ω, r, dr; params...) -&gt; Σᵢⱼ(ω, r, dr; params...); hops...)</code></pre><p>Special form of a parametric hopping amplitude meant to model a self-energy (see <code>attach</code>).</p><p><strong>Model algebra</strong></p><p>Parametric models can be combined using <code>+</code>, <code>-</code> and <code>*</code>, or conjugated with <code>&#39;</code>, e.g. <code>@onsite((; o=1) -&gt; o) - 2 * hopping(1)&#39;</code>. The combined parametric models can share parameters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = @hopping((r, dr; t = 1, A = Returns(SA[0,0])) -&gt; t * cis(-dr&#39; * A(r)))
ParametricModel: model with 1 term
  ParametricHoppingTerm{ParametricFunction{2}}
    Region            : any
    Sublattice pairs  : any
    Cell distances    : any
    Hopping range     : Neighbors(1)
    Reverse hops      : false
    Coefficient       : 1
    Parameters        : [:t, :A]

julia&gt; LP.honeycomb() |&gt; supercell(2) |&gt; hamiltonian(model)
ParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5
  Harmonic size    : 8 × 8
  Orbitals         : [1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 24
  Coordination     : 3.0
  Parameters       : [:A, :t]</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`onsite`, `hopping`, `@onsite`, `@onsite!`, `@hopping!`, `attach`, `hamiltonian`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL822-L881">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.@hopping!" href="#Quantica.@hopping!"><code>Quantica.@hopping!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@hopping!((t; params...) -&gt; t´(t; params...); hops...)
@hopping!((t, r, dr; params...) -&gt; t´(t, r, dr; params...); hops...)</code></pre><p>Build a uniform or position-dependent hopping term modifier, respectively, acting on hops selected by <code>hopselector(; hops...)</code> (see <code>hopselector</code> for details).</p><p>Hops from a site at position <code>r₁</code> to another at <code>r₂</code> are described using the hop center <code>r = (r₁ + r₂)/2</code> and the hop vector <code>dr = r₂ - r₁</code>. The original hopping amplitude is <code>t</code>, and the modified hopping is <code>t´</code>, which is a function of <code>t</code> and possibly <code>r, dr</code>. It may optionally also depend on parameters, enconded in <code>params</code>.</p><p>Modifiers are meant to be applied to an <code>h:AbstractHamiltonian</code> to obtain a <code>ParametricHamiltonian</code> (with <code>hamiltonian(h, modifiers...)</code> or <code>hamiltonian(lat, model, modifiers...)</code>, see <code>hamiltonian</code>). Modifiers will affect only pre-existing model terms. In particular, if no onsite model has been applied to a specific site, its onsite potential will be zero, and will not be modified by any <code>@onsite!</code> modifier. Conversely, if an onsite model has been applied, <code>@onsite!</code> may modify the onsite potential even if it is zero. The same applies to <code>@hopping!</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = hopping(1); peierls = @hopping!((t, r, dr; A = r -&gt; SA[0,0]) -&gt; t * cis(-dr&#39; * A(r)))
HoppingModifier{ParametricFunction{3}}:
  Region            : any
  Sublattice pairs  : any
  Cell distances    : any
  Hopping range     : Inf
  Reverse hops      : false
  Parameters        : [:A]

julia&gt; LP.honeycomb() |&gt; hamiltonian(model) |&gt; supercell(10) |&gt; hamiltonian(peierls)
ParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5
  Harmonic size    : 200 × 200
  Orbitals         : [1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 600
  Coordination     : 3.0
  Parameters       : [:A]</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`onsite`, `hopping`, `@onsite`, `@hopping`, `@onsite!`, `hamiltonian`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL929-L974">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.@onsite" href="#Quantica.@onsite"><code>Quantica.@onsite</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@onsite((; params...) -&gt; o(; params...); sites...)
@onsite((r; params...) -&gt; o(r; params...); sites...)</code></pre><p>Build a <code>ParametricModel</code> representing a uniform or a position-dependent onsite potential, respectively, on sites selected by <code>siteselector(; sites...)</code> (see <code>siteselector</code> for details).</p><p>Site positions are <code>r::SVector{E}</code>, where <code>E</code> is the embedding dimension of the lattice. The onsite potential <code>o</code> can be a <code>Number</code> (for single-orbital sites), a <code>UniformScaling</code> (e.g. <code>2I</code>) or an <code>AbstractMatrix</code> (use <code>SMatrix</code> for performance) of dimensions matching the number of orbitals in the selected sites. Parametric models may be applied to a lattice <code>lat</code> to produce a <code>ParametricHamiltonian</code> with <code>hamiltonian(lat, model; ...)</code>, see <code>hamiltonian</code>. Position dependent models are forced to preserve the periodicity of the lattice.</p><p>The difference between regular and parametric tight-binding models (see <code>onsite</code> and <code>hopping</code>) is that parametric models may depend on arbitrary parameters, specified by the <code>params</code> keyword arguments. These are inherited by <code>h::ParametricHamiltonian</code>, which can then be evaluated very efficiently for different parameter values by callling <code>h(; params...)</code>, to obtain a regular <code>Hamiltonian</code> without reconstructing it from scratch.</p><pre><code class="nohighlight hljs">@onsite((ω; params...) -&gt; Σᵢᵢ(ω; params...); sites...)
@onsite((ω, r; params...) -&gt; Σᵢᵢ(ω, r; params...); sites...)</code></pre><p>Special form of a parametric onsite potential meant to model a self-energy (see <code>attach</code>).</p><p><strong>Model algebra</strong></p><p>Parametric models can be combined using <code>+</code>, <code>-</code> and <code>*</code>, or conjugated with <code>&#39;</code>, e.g. <code>@onsite((; o=1) -&gt; o) - 2 * hopping(1)&#39;</code>. The combined parametric models can share parameters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = @onsite((r; dμ = 0) -&gt; (r[1] + dμ) * I; sublats = :A) + @onsite((; dμ = 0) -&gt; - dμ * I; sublats = :B)
ParametricModel: model with 2 terms
  ParametricOnsiteTerm{ParametricFunction{1}}
    Region            : any
    Sublattices       : A
    Cells             : any
    Coefficient       : 1
    Parameters        : [:dμ]
  ParametricOnsiteTerm{ParametricFunction{0}}
    Region            : any
    Sublattices       : B
    Cells             : any
    Coefficient       : 1
    Parameters        : [:dμ]

julia&gt; LP.honeycomb() |&gt; supercell(2) |&gt; hamiltonian(model, orbitals = 2)
ParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 1
  Harmonic size    : 8 × 8
  Orbitals         : [2, 2]
  Element type     : 2 × 2 blocks (ComplexF64)
  Onsites          : 8
  Hoppings         : 0
  Coordination     : 0.0
  Parameters       : [:dμ]</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`onsite`, `hopping`, `@hopping`, `@onsite!`, `@hopping!`, `attach`, `hamiltonian`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL755-L819">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.@onsite!" href="#Quantica.@onsite!"><code>Quantica.@onsite!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@onsite!((o; params...) -&gt; o´(o; params...); sites...)
@onsite!((o, r; params...) -&gt; o´(o, r; params...); sites...)</code></pre><p>Build a uniform or position-dependent onsite term modifier, respectively, acting on sites selected by <code>siteselector(; sites...)</code> (see <code>siteselector</code> for details).</p><p>Site positions are <code>r::SVector{E}</code>, where <code>E</code> is the embedding dimension of the lattice. The original onsite potential is <code>o</code>, and the modified potential is <code>o´</code>, which is a function of <code>o</code> and possibly <code>r</code>. It may optionally also depend on parameters, enconded in <code>params</code>.</p><p>Modifiers are meant to be applied to an <code>h:AbstractHamiltonian</code> to obtain a <code>ParametricHamiltonian</code> (with <code>hamiltonian(h, modifiers...)</code> or <code>hamiltonian(lat, model, modifiers...)</code>, see <code>hamiltonian</code>). Modifiers will affect only pre-existing model terms. In particular, if no onsite model has been applied to a specific site, its onsite potential will be zero, and will not be modified by any <code>@onsite!</code> modifier. Conversely, if an onsite model has been applied, <code>@onsite!</code> may modify the onsite potential even if it is zero. The same applies to <code>@hopping!</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = onsite(0); disorder = @onsite!((o; W = 0) -&gt; o + W * rand())
OnsiteModifier{ParametricFunction{1}}:
  Region            : any
  Sublattices       : any
  Cells             : any
  Parameters        : [:W]

julia&gt; LP.honeycomb() |&gt; hamiltonian(model) |&gt; supercell(10) |&gt; hamiltonian(disorder)
ParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 1
  Harmonic size    : 200 × 200
  Orbitals         : [1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 200
  Hoppings         : 0
  Coordination     : 0.0
  Parameters       : [:W]</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`onsite`, `hopping`, `@onsite`, `@hopping`, `@hopping!`, `hamiltonian`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/1613b41d63d1c65bc8b0a4560e8793c7ddd66a60/src/docstrings.jl#LL884-L926">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.1 on <span class="colophon-date" title="Friday 20 October 2023 22:04">Friday 20 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
