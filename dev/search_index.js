var documenterSearchIndex = {"docs":
[{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = Quantica","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Quantica]","category":"page"},{"location":"reference/#Quantica.Quantica","page":"Reference","title":"Quantica.Quantica","text":"Quantica.jl\n\n(Image: Stable) (Image: Dev) (Image: DOI) (Image: Build Status) (Image: Coverage) (Image: GitHub commits since last release)\n\nThe Quantica.jl package provides an expressive API to build arbitrary quantum systems on a discrete lattice, and to compute a number of their properties.\n\nSome current features\n\nBuild Hamiltonians on discrete lattices of arbitrary dimensions, using tight-binding models with arbitrary number of orbitals\nCompute band structures of periodic systems and extract individual bands by interpolation\nCompute electronic structures and expectation values using Kernel Polynomial methods\n\nExported API\n\nlattice, sublat: build lattices\nhopping, onsite, siteselector, hopselector, nrange, not: build tightbinding models\nhamiltonian: build a Hamiltonian from tightbinding model and a lattice\nbloch, bloch!, similarmatrix: build the Bloch matrix of a Hamiltonian\nparametric, @onsite!, @hopping!, parameters: build a parametric Hamiltonian\ndims, sitepositions, siteindices, bravais: inspect lattices and Hamiltonians\nsupercell, unitcell, wrap, transform!, combine: build derived lattices or Hamiltonians\nket, randomkets: define ket models for use in e.g. KPM routines\nflatten, unflatten, orbitalstructure: operate with multiorbital Hamiltonian, Kets or Subspaces\ncuboid: build a bandstructure discretization mesh\nbandstructure, spectrum, diagonalizer: compute the generalized bandstructure of a Hamiltonian or a ParametricHamiltonian\nbands, energies, states: inspect spectrum and bandstructure objects\nmomentaKPM, dosKPM, averageKPM, densityKPM, bandrangeKPM: Kernel Polynomial Method (KPM)\ngreens, greensolver: build Green's functions of a Hamiltonian\n\nSome of this functionality require loading one or more third-party packages, which include the following:\n\nKPM: FFTW, ArnoldiMethod\nBandstructures: Arpack, ArnoldiMethod, KrylovKit\n\nThe user is told when this is needed. We do this to reduce dependencies and launch time with packages whose functionality is not essential for the use of Quantica.jl\n\nOther functions become available after loading specific third-party packages:\n\nMakie: enables plot(::Hamiltonian) and plot(::Bandstructure) (for 1D and 2D bandstructures)\nVegaLite: enables vlplot(::Hamiltonian) and vlplot(::Bandstructure) (for 1D bandstructures)\n\nFunding\n\nThis work has been partly funded by the Spanish Ministry of Economy and Competitiveness under Grant Nos. FIS2015-65706-P, PCI2018-093026, and the CSIC Intramural Project 201760I086.\n\n\n\n\n\n","category":"module"},{"location":"reference/#Quantica.BoxIterator","page":"Reference","title":"Quantica.BoxIterator","text":"BoxIterator(seed::SVector{N,Int}; maxiterations = missing)\n\nCartesian iterator iter over SVector{N,Int}s (cells) that starts at seed and grows outwards in the form of a box of increasing sides (not necesarily equal) until it encompasses a certain N-dimensional region. To signal that a cell is in the desired region the user calls acceptcell!(iter, cell).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Quantica.EffectiveMatrix","page":"Reference","title":"Quantica.EffectiveMatrix","text":"EffectiveMatrix\n\nA dense matrix of the form matrix = [ZaL(ω) L' 0; L*ZaR(ω) I*ω-H R*ZrL(ω); 0 R' ZrR(ω)], where H, L and R are given at construction, while ω, φL, φR are given at runtime.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Quantica.Schur1D","page":"Reference","title":"Quantica.Schur1D","text":"Schur1D()\n\nReturn a Greens function solver using the generalized eigenvalue approach, whereby given the energy ω, the eigenmodes of the infinite 1D Hamiltonian, and the corresponding infinite and semi-infinite Greens function can be computed by solving the generalized eigenvalue equation\n\nA⋅φχ = λ B⋅φχ\nA = [0 I; -h₊ ω-h₀]\nB = [I 0; 0 h₋]\n\nThis is the matrix form of the problem λ(ω-h₀)φ - h₊φ - λ²h₋φ = 0, where φχ = [φ; λφ], and φ are ω-energy eigenmodes, with (possibly complex) momentum q, and eigenvalues are λ = exp(-iqa₀). The algorithm assumes the Hamiltonian has only dn = (0,) and dn = (±1, ) Bloch harmonics (h₀, h₊ and h₋), and will error otherwise instructing the user to grow the unit cell. Bound states in the spectrum will yield delta functions in the density of states that can be resolved by adding a broadening in the form of a small positive imaginary part to ω. If ω::Real, a small imaginary part will be added automatically.\n\nFor performace, the eigenvalue equation may be deflated' andstabilized', i.e. singular solutions λ=0,∞ will be removed, and an inverse-free algorithm is used to preserve precision even in the presence of singularities.\n\nExamples\n\njulia> using LinearAlgebra\n\njulia> h = LP.honeycomb() |> hamiltonian(hopping(1)) |> unitcell((1,-1), (10,10)) |> wrap(2);\n\njulia> g = greens(h, Schur1D(), boundaries = (0,))\nGreensFunction{Schur1DGreensSolver}: Green's function using the Schur1D method\n  Flat matrix size      : 40 × 40\n  Flat deflated size    : 20 × 20\n  Original element type : scalar (ComplexF64)\n  Boundaries            : (0,)\n\njulia> tr(g(0.3, 1=>1))\n-32.193416071797216 - 3.4400038418349084im\n\nSee also\n\n`greens`\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.:&-Tuple{Quantica.Hamiltonian{#s40,L,M,A,H,O} where O<:Quantica.OrbitalStructure where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s40<:Quantica.Superlattice,Quantica.Hamiltonian{#s39,L,M,A,H,O} where O<:Quantica.OrbitalStructure where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s39<:Quantica.Superlattice}","page":"Reference","title":"Base.:&","text":"&(h1::Hamiltonian{<:Superlattice}, h2::Hamiltonian{<:Superlattice})\n\nConstruct a new Hamiltonian{<:Superlattice} using an and boolean mask, i.e. with a supercell that contains cells that are both in the supercell of h1 and h2\n\n&(s1::Superlattice, s2::Superlattice}\n\nEquivalent of the above for Superlattices\n\nSee also\n\n`|`, `xor`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:|-Tuple{Quantica.Hamiltonian{#s40,L,M,A,H,O} where O<:Quantica.OrbitalStructure where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s40<:Quantica.Superlattice,Quantica.Hamiltonian{#s39,L,M,A,H,O} where O<:Quantica.OrbitalStructure where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s39<:Quantica.Superlattice}","page":"Reference","title":"Base.:|","text":"|(h1::Hamiltonian{<:Superlattice}, h2::Hamiltonian{<:Superlattice})\n\nConstruct a new Hamiltonian{<:Superlattice} using an or boolean mask, i.e. with a supercell that contains cells that are either in the supercell of h1 or h2\n\n|(s1::Superlattice, s2::Superlattice}\n\nEquivalent of the above for Superlattices\n\nSee also\n\n`&`, `xor`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.xor-Tuple{Quantica.Hamiltonian{#s40,L,M,A,H,O} where O<:Quantica.OrbitalStructure where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s40<:Quantica.Superlattice,Quantica.Hamiltonian{#s39,L,M,A,H,O} where O<:Quantica.OrbitalStructure where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s39<:Quantica.Superlattice}","page":"Reference","title":"Base.xor","text":"xor(h1::Hamiltonian{<:Superlattice}, h2::Hamiltonian{<:Superlattice})\n\nConstruct a new Hamiltonian{<:Superlattice} using a xor boolean mask, i.e. with a supercell that contains cells that are either in the supercell of h1 or h2 but not in both\n\nxor(s1::Superlattice, s2::Superlattice}\n\nEquivalent of the above for Superlattices\n\nSee also\n\n`&`, `|`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.averageKPM-Tuple{Any,Any}","page":"Reference","title":"Quantica.averageKPM","text":"averageKPM(h::Hamiltonian, A; kBT = 0, Ef = 0, kw...)\n\nCompute, using the Kernel Polynomial Method (KPM), the thermal expectation value ⟨A⟩ = Σ_k f(E_k) ⟨k|A|k⟩ = ∫dE f(E) Tr [A δ(E-H)]/N₀ = Tr [A f(H)]/N₀ for a given hermitian operator A and a zero-dimensional hamiltonian h with a total of N₀ orbitals (see momentaKPM and its options kw for further details). f(E) is the Fermi-Dirac distribution function, |k⟩ are h eigenstates with energy E_k, kBTis the temperature in energy units andEf` the Fermi energy.\n\naverageKPM(μ::MomentaKPM, A; kBT = 0, Ef = 0)\n\nSame as above with the KPM momenta as input (see momentaKPM).\n\nSee also\n\n`dosKPM`, `momentaKPM`, `averageKPM`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.bands-Tuple{Quantica.Bandstructure}","page":"Reference","title":"Quantica.bands","text":"bands(bs::Bandstructure[, i])\n\nReturn a bands::Vector{Band} of all the bands in bs, or bands[i] if i is given.\n\nSee also\n\n`bandstructure`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.bandstructure-Tuple","page":"Reference","title":"Quantica.bandstructure","text":"bandstructure(h::Hamiltonian; subticks = 13, kw...)\n\nCompute bandstructure(h, cuboid((-π,π)...; subticks = subticks); kw...) using a base mesh (of type CuboidMesh) over h's full Brillouin zone with the specified subticks along each [-π,π] reciprocal axis.\n\nbandstructure(h::Hamiltonian, nodes...; subticks = 13, kw...)\n\nCreate a linecut of a bandstructure of h along a polygonal line connecting two or more nodes. Each node is either a Tuple or SVector of Bloch phases, or a symbolic name for a Brillouin zone point (:Γ,:K, :K´, :M, :X, :Y or :Z). Each segment in the polygon has the specified number of subticks. Different subticks per segments can be specified with subticks = (p1, p2...).\n\nbandstructure(h::Hamiltonian, mesh::CuboidMesh; mapping = missing, kw...)\n\nCompute the bandstructure bandstructure(h, mesh; kw...) of Bloch Hamiltonian bloch(h, ϕ), with ϕ = v taken on each vertex v of the base mesh (or ϕ = mapping(v...) if a mapping function is provided).\n\nbandstructure(ph::ParametricHamiltonian, ...; kw...)\n\nCompute the bandstructure of a ph. Unless all parameters have default values, a mapping is required between mesh vertices and Bloch/parameters for ph, see details on mapping below.\n\nbandstructure(matrixf::Function, mesh::CuboidMesh; kw...)\n\nCompute the bandstructure of the Hamiltonian matrix m = matrixf(ϕ), with ϕ evaluated on the vertices v of the mesh. Note that ϕ in matrixf(ϕ) is an unsplatted container. Hence, i.e. matrixf(x) = ... or matrixf(x, y) = ... will not work. Use matrixf((x,)) = ..., matrixf((x, y)) = ... or matrixf(s::SVector) = ...` instead.\n\nh |> bandstructure([mesh,]; kw...)\n\nCurried form of the above equivalent to bandstructure(h[, mesh]; kw...).\n\nOptions\n\nThe default options are\n\n(mapping = missing, method = LinearAlgebraPackage(), transform = missing, splitbands = true, showprogress = true)\n\nmapping: when not missing, mapping = v -> p is a function that map base mesh vertices v to Bloch phases and/or parameters p. The structure of p is whatever is accepted by bloch(h, p, ...) (see bloch). For h::Hamiltonian, p = ϕs::Union{Tuple,SVector} are Bloch phases. For h::ParametricHamiltonian, p = (ϕs..., (; ps)) or p = (ϕs, (; ps)) combine Bloch phases ϕs and keyword parameters ps of ph. This allows to compute a bandstructure along a cut in the Brillouin zone/parameter space of ph, see examples below.\n\nmethod: it is chosen automatically if unspecified, and can be one of the following\n\nmethod                     diagonalization function\n--------------------------------------------------------------\nLinearAlgebraPackage()     LinearAlgebra.eigen!\nArpackPackage()            Arpack.eigs (must be `using Arpack`)\n\nOptions passed to the method will be forwarded to the diagonalization function. For example, method = ArpackPackage(nev = 8, sigma = 1im) will use Arpack.eigs(matrix; nev = 8, sigma = 1im) to compute the bandstructure.\n\ntransform: the option transform = ε -> fε(ε) allows to transform eigenvalues by fε in the returned bandstructure (useful for performing shifts or other postprocessing). We can also do transform -> (fφ, fε) to transform also mesh vertices with fφ. Additionally, transform -> isometric or transform -> (isometric, fε) will transform mesh vertices into momenta, assuming they represent Bloch phases. This works both in full bandstructures and linecuts.\n\nsplitbands: split all bands into disconnected subbands. See also splitbands!\n\nshowprogress: indicate whether progress bars are displayed during the calculation\n\nIndexing\n\nThe bands in a bs::Bandstructure object can be accessed with bands, while the indexing syntax bs[(φs...)] gives access to one or more sub::Subspace objects, contructed by linear interpolation of each band at base-mesh coordinates φs.\n\nbs[(φs...), 1]                  : first interpolated subspaces at base mesh coordinates `φs`, ordered by energy\nbs[(φs...), 1:3]                : interpolated subspaces 1 to 3 at base mesh coordinates `φs`, ordered by energy\nbs[(φs...)]                     : interpolated subspaces at base mesh coordinates `φs` in any band\nbs[(φs...), around = 0.2]       : the single interpolated subspaces at `φs` with energies closest to 0.2\nbs[(φs...), around = (0.2, 10)] : the ten interpolated subspaces at `φs` with energies closest to 0.2\n\nThe eigenenergy ε and subspace basis ψs of a sub::Subspace can themselves be obtained via destructuring, ε, ψs = sub, or ε = first(sub), ψs = last(sub).\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |> hamiltonian(hopping(-1)) |> unitcell(3);\n\njulia> bandstructure(h; subticks = 25, method = LinearAlgebraPackage())\nBandstructure{2}: collection of 2D bands\n  Bands        : 8\n  Element type : scalar (Complex{Float64})\n  Band{2}: mesh of a 2-dimensional manifold\n    Vertices   : 625\n    Edges      : 1776\n\njulia> bandstructure(h, :Γ, :X, :Y, :Γ; subticks = (10,15,10))\nBandstructure{2}: collection of 1D bands\n  Bands        : 18\n  Element type : scalar (Complex{Float64})\n  Band{1}: mesh of a 1-dimensional manifold\n    Vertices   : 33\n    Edges      : 32\n\njulia> bandstructure(h, mesh((0, 2π); subticks = 13); mapping = φ -> (φ, 0))\n       # Equivalent to bandstructure(h, :Γ, :X; subticks = 13)\nBandstructure{2}: collection of 1D bands\n  Bands        : 18\n  Element type : scalar (Complex{Float64})\n  Band{1}: mesh of a 1-dimensional manifold\n    Vertices   : 11\n    Edges      : 10\n\njulia> ph = parametric(h, @hopping!((t; α) -> t * α));\n\njulia> bandstructure(ph, mesh((0, 2π); subticks = 13); mapping = φ -> (φ, 0, (; α = 2φ)))\nBandstructure{2}: collection of 1D bands\n  Bands        : 18\n  Element type : scalar (Complex{Float64})\n  Band{1}: mesh of a 1-dimensional manifold\n    Vertices   : 11\n    Edges      : 10\n\nSee also\n\n`cuboid`, `diagonalizer`, `bloch`, `parametric`, `splitbands!`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.bloch","page":"Reference","title":"Quantica.bloch","text":"bloch(h::Hamiltonian{<:Lattice}, ϕs)\n\nBuild the Bloch Hamiltonian matrix of h, for Bloch phases ϕs = (ϕ₁, ϕ₂,...) (or an SVector(ϕs...)). In terms of Bloch wavevector k, ϕs = k * bravais(h), it is defined as H(ϕs) = ∑exp(-im * ϕs' * dn) h_dn where h_dn are Bloch harmonics connecting unit cells at a distance dR = bravais(h) * dn.\n\nbloch(h::Hamiltonian{<:Lattice})\n\nBuild the intra-cell Hamiltonian matrix of h, without adding any Bloch harmonics.\n\nbloch(h::Hamiltonian{<:Lattice}, ϕs, axis::Int)\n\nA nonzero axis produces the derivative of the Bloch matrix respect to ϕs[axis] (i.e. the velocity operator along this axis), ∂H(ϕs) = ∑ -im * dn[axis] * exp(-im * ϕs' * dn) h_dn\n\nbloch(matrix, h::Hamiltonian{<:Lattice}, ϕs::NTuple{L,Real}, dnfunc::Function)\n\nGeneralization that applies a prefactor dnfunc(dn) * exp(im * ϕs' * dn) to the dn harmonic.\n\nbloch(ph::ParametricHamiltonian, [pϕs, [axis]])\n\nBuild the Bloch matrix for ph. pϕs = (ϕs, (;kw...)) or pϕs = (ϕs..., (;kw...)) specifies both Bloch phases ϕs and the parameters kw passed to ph(; kw...). If there are no ϕs, the syntax pϕs = (;kw...) is also allowed, which is in that case equivalent to bloch(ph(; kw...)). Similarly, bloch(ph) is equivalent to bloch(ph()).\n\nh |> bloch(ϕs, ...)\nph |> bloch(pϕs, ...)\n\nCurried forms of bloch, equivalent to bloch(h, ϕs, ...) and bloch(ph, pϕs, ...)\n\nNotes\n\nbloch allocates a new matrix on each call. For a non-allocating version of bloch, see bloch!.\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |> hamiltonian(onsite(1) + hopping(2)) |> bloch((0, 0))\n2×2 SparseMatrixCSC{Complex{Float64},Int64} with 4 stored entries:\n  [1, 1]  =  1.0+0.0im\n  [2, 1]  =  6.0+0.0im\n  [1, 2]  =  6.0+0.0im\n  [2, 2]  =  1.0+0.0im\n\nSee also\n\n`bloch!`, `similarmatrix`\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.bloch!","page":"Reference","title":"Quantica.bloch!","text":"bloch!(matrix, h::Hamiltonian, [ϕs, [axis]])\n\nIn-place version of bloch. Overwrite matrix with the Bloch Hamiltonian matrix of h for the specified Bloch phases ϕs = (ϕ₁,ϕ₂,...) (see bloch for definition and API). A conventient way to obtain a matrix is to use similarmatrix(h,matrix_type), which will return an AbstractMatrix of the same type as the Hamiltonian's. Note, however, that matrix need not be of the same type (e.g. it can be dense with Number eltype for a sparse h with SMatrix block eltype).\n\nbloch!(matrix, ph::ParametricHamiltonian, [pϕs, [axis]])\n\nSame as above but with pϕs = (ϕs, (;kw...)), pϕs = (ϕs..., (;kw...)) or pϕs = (;kw...) (see bloch for details).\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |> hamiltonian(hopping(2I), orbitals = (Val(2), Val(1)));\n\njulia> bloch!(similarmatrix(h), h, (0, 0))\n2×2 SparseMatrixCSC{StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4},Int64} with 2 stored entries:\n  [2, 1]  =  [6.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]\n  [1, 2]  =  [6.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]\n\njulia> bloch!(similarmatrix(h, flatten), h, (0, 0))\n3×3 SparseMatrixCSC{Complex{Float64},Int64} with 9 stored entries:\n  [1, 1]  =  0.0+0.0im\n  [2, 1]  =  0.0+0.0im\n  [3, 1]  =  6.0+0.0im\n  [1, 2]  =  0.0+0.0im\n  [2, 2]  =  0.0+0.0im\n  [3, 2]  =  0.0+0.0im\n  [1, 3]  =  6.0+0.0im\n  [2, 3]  =  0.0+0.0im\n  [3, 3]  =  0.0+0.0im\n\njulia> ph = parametric(h, @hopping!((t; α, β = 0) -> α * t + β));\n\njulia> bloch!(similarmatrix(ph, flatten), ph, (0, 0, (; α = 2)))\n3×3 SparseMatrixCSC{Complex{Float64},Int64} with 9 stored entries:\n  [1, 1]  =  0.0+0.0im\n  [2, 1]  =  0.0+0.0im\n  [3, 1]  =  12.0+0.0im\n  [1, 2]  =  0.0+0.0im\n  [2, 2]  =  0.0+0.0im\n  [3, 2]  =  0.0+0.0im\n  [1, 3]  =  12.0+0.0im\n  [2, 3]  =  0.0+0.0im\n  [3, 3]  =  0.0+0.0im\n\nSee also\n\n`bloch`, `similarmatrix`\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.bravais-Tuple{Quantica.AbstractLattice}","page":"Reference","title":"Quantica.bravais","text":"bravais(lat::Lattice)\nbravais(h::Hamiltonian)\n\nObtain the Bravais matrix of lattice lat or Hamiltonian h\n\nExamples\n\njulia> bravais((1.0, 2), (3, 4))\nBravais{2,2,Float64} : set of 2 Bravais vectors in 2D space.\n  Vectors     : ((1.0, 2.0), (3.0, 4.0))\n  Matrix      : [1.0 3.0; 2.0 4.0]\n\nSee also\n\n`lattice`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.combine-Tuple{Vararg{Quantica.Hamiltonian,N} where N}","page":"Reference","title":"Quantica.combine","text":"combine(hams::Hamiltonian...; coupling = missing)\n\nBuild a new Hamiltonian h that combines all hams as diagonal blocks, and applies coupling::Model, if provided, to build the off-diagonal couplings. Note that the diagonal blocks are not modified by the coupling model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.combine-Tuple{Vararg{Quantica.Lattice,N} where N}","page":"Reference","title":"Quantica.combine","text":"combine(lats::Lattice...)\n\nIf all lats have compatible Bravais vectors, combine them into a single lattice. Sublattice names are renamed to be unique if necessary.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.cuboid-Union{Tuple{Vararg{Tuple,L}}, Tuple{L}} where L","page":"Reference","title":"Quantica.cuboid","text":"cuboid(ticks...; subticks = 13)\n\nCreate a CuboidMesh of L-dimensional marching-tetrahedra over a cuboid aligned with the Cartesian axes. The dimension L is given by the number of ticks, each of the form (x₁, x₂,...). The interval between xⱼ and xⱼ₊₁ ticks in axis i are further subdivided to have a number of subticks including endpoints. The number is subticks if subticks is an Integer, subticks[i] if subticks = (s₁, s₂,...) or subticks[i][j] if subticks = ((s₁₁, s₁₂,...), (s₂₁, s₂₂,...), ...).\n\nExamples\n\njulia> cuboid((-π, π), (0, 2π); subticks = 25)\n\njulia> cuboid((-π, π), (0, 2π); subticks = (10, 10))\n\nExternal links\n\nMarching tetrahedra (https://en.wikipedia.org/wiki/Marching_tetrahedra) in Wikipedia\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.degeneracy-Tuple{Quantica.Subspace}","page":"Reference","title":"Quantica.degeneracy","text":"degeneracy(s::Subspace)\n\nReturn the degeneracy of a given energy subspace. It is equal to size(s.basis, 2).\n\nSee also\n\n`spectrum`, `bandstructure`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.densityKPM-Tuple{Any,Any}","page":"Reference","title":"Quantica.densityKPM","text":"densityKPM(h::Hamiltonian, A; resolution = 2, ket = randomkets(1), kw...)\n\nCompute, using the Kernel Polynomial Method (KPM), the spectral density of A, ρᴬₖ(ϵ) = ⟨k|A δ(ϵ-h)|k⟩ for the ket |k⟩ produced by ket(ket::KetModel, h). The result is a tuple of energy points ϵᵢ::Vector spanning the band range, and real ρᴬₖ(ϵᵢ)::Vector values. The number of energy points ϵᵢ is order * resolution, rounded to the closest integer.\n\nIf ket is not a single KetModel, but a collection of them, the sum ∑ₖρᴬₖ(ε) over all models will be computed. In the case of the default ket = randomkets(n), this results in an estimate of the average spectral density per orbital, computed through an stochastic trace, ρᴬ(ϵ) = ∑ₖ⟨k|δ(ϵ-h)A|k⟩/n ≈ Tr[δ(ϵ-h)A]/N₀, where N₀ is the total number of orbitals in the unit cell.\n\ndensityKPM(μ::MomentaKPM; resolution = 2)\n\nSame as above with KPM momenta μ as input.\n\nSee also\n\n`dosKPM`, `momentaKPM`, `averageKPM`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.diagonalizer-Tuple{Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian}}","page":"Reference","title":"Quantica.diagonalizer","text":"diagonalizer(h::Union{Hamiltonian,ParametricHamiltonian}; method = LinearAlgebraPackage(), mapping = missing)\n\nBuild a d::Diagonalizer object that, when called as d(φs) , uses the specified diagonalization method to produce the sorted eigenpairs (εs, ψs) of h at Bloch phases/parameters given by mapping. See bandstructure for further details.\n\nA 0D Hamiltonian h also supports d = diagonalizer(h). In this case d can be called with no arguments and gives the same information as spectrum, d() == Tuple(spectrum(h)).\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |> hamiltonian(hopping(1));\n\njulia> d = diagonalizer(h)\nDiagonalizer with method : LinearAlgebraPackage{NamedTuple{(),Tuple{}}}\n\njulia> d((0, 0)) |> first\n2-element Array{Float64,1}:\n -3.0\n  3.0\n\njulia> h = wrap(h); d = diagonalizer(h);\n\njulia> d() == Tuple(spectrum(h))\ntrue\n\nSee also\n\n`bandstructure`, `spectrum`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.dims-Union{Tuple{Quantica.AbstractLattice{E,L,T} where T}, Tuple{L}, Tuple{E}} where L where E","page":"Reference","title":"Quantica.dims","text":"dims(lh::Union{Hamiltonian,AbstractLattice}) -> (E, L)\n\nReturn a tuple (E, L) of the embedding E and lattice dimensions L of AbstractLattice or Hamiltonian lh\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.dosKPM-Tuple{Any}","page":"Reference","title":"Quantica.dosKPM","text":"dosKPM(h::Hamiltonian; resolution = 2, ket = randomkets(1), kw...)\n\nCompute, using the Kernel Polynomial Method (KPM), the local density of states ρₖ(ϵ) = ⟨k|δ(ϵ-h)|k⟩ for the ket |k⟩ produced by ket(ket::KetModel, h). The result is a tuple of energy points ϵᵢ::Vector spanning the band range, and real ρₖ(ϵᵢ)::Vector values (any residual imaginary part in ρₖ is dropped). The number of energy points ϵᵢ is order * resolution, rounded to the closest integer.\n\nIf ket is not a single KetModel, but a collection of them, the sum ∑ₖρₖ(ε) over all models will be computed. In the case of the default ket = randomkets(n), this results in an estimate of the total density of states per orbital, computed through an stochastic trace, ρ(ϵ) = ∑ₖ⟨k|δ(ϵ-h)|k⟩/n ≈ Tr[δ(ϵ-h)]/N₀, where N₀ is the total number of orbitals in the unit cell.\n\ndosKPM is a particular case of densityKPM for an operator A = I and with any residual imaginary parts dropped\n\ndosKPM(μ::MomentaKPM; resolution = 2)\n\nSame as above with KPM momenta μ as input.\n\nSee also\n\n`momentaKPM`, `densityKPM`, `averageKPM`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.flatten-Tuple{}","page":"Reference","title":"Quantica.flatten","text":"flatten(h::Hamiltonian)\n\nFlatten a multiorbital Hamiltonian h into one with a single orbital per site. The associated lattice is flattened also, so that there is one site per orbital for each initial site (all at the same position). Note that in the case of sparse Hamiltonians, zeros in hopping/onsite matrices are preserved as structural zeros upon flattening.\n\nflatten(k::Ket)\n\nFlattens a multiorbital Ket to have a scalar eltype, instead of SVector.\n\nflatten(s::Subspace)\n\nRebuild s by flattening its basis to have a scalar eltype.\n\nx |> flatten()\n\nCurried form equivalent to flatten(x) or x |> flatten (included for consistency with the rest of the API).\n\nflatten(x, o::OrbitalStructure)\n\nFlatten object x, if applicable, using the orbital structure o, as obtained from a Hamiltonian h with orbitalstructure(h). x here is typically an AbstractArray of non-scalar eltype.\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |>\n           hamiltonian(hopping(@SMatrix[1; 2], range = 1/√3, sublats = :A =>:B),\n           orbitals = (Val(1), Val(2)))\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 × 2\n  Orbitals         : ((:a,), (:a, :a))\n  Element type     : 2 × 2 blocks (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 3\n  Coordination     : 1.5\n\njulia> flatten(h)\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)\n  Harmonic size    : 3 × 3\n  Orbitals         : ((:flat,), (:flat,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 2.0\n\nSee also\n\n`unflatten`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.greens-Union{Tuple{L}, Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O<:Quantica.OrbitalStructure where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where #s38,Any}} where L","page":"Reference","title":"Quantica.greens","text":"greens(h::Hamiltonian, solveobject; boundaries::NTuple{L,Integer} = missing)\n\nConstruct the Green's function g::GreensFunction of L-dimensional Hamiltonian h using the provided solveobject. Currently valid solveobjects are\n\nSchur1D() (single-shot generalized eigenvalue approach for 1D Hamiltonians)\n\nIf a boundaries = (n₁, n₂, ...) is provided, a reflecting boundary is assumed for each non-missing nᵢ perpendicular to Bravais vector i at a cell distance nᵢ from the origin.\n\nh |> greens(h -> solveobject(h), args...)\n\nCurried form equivalent to the above, giving greens(h, solveobject(h), args...).\n\ng(ω, cells::Pair)\ng(ω)[cells::Pair]\n\nFrom a constructed g::GreensFunction, obtain the retarded Green's function matrix at frequency ω between unit cells src and dst, where src, dst are ::NTuple{L,Int} or SVector{L,Int}. If allowed by the used solveobject, g0=g(ω) builds an solution object that can efficiently produce the Greens function between different cells at fixed ω with g0[cells] without repeating cell-independent parts of the computation.\n\nExamples\n\njulia> g = LatticePresets.square() |> hamiltonian(hopping(-1)) |> unitcell((1,0), region = r->0<r[2]<3) |> greens(Schur1D())\nGreensFunction{Schur1DGreensSolver}: Green's function using the Schur1D method\n  Flat matrix size      : 2 × 2\n  Flat deflated size    : 2 × 2\n  Original element type : scalar (ComplexF64)\n  Boundaries            : (missing,)\n\njulia> g(0.2, 3=>2) ≈ g(0.2)[3=>2]\ntrue\n\nSee also\n\n`Schur1D`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.hamiltonian-Tuple{Quantica.AbstractLattice,Vararg{Any,N} where N}","page":"Reference","title":"Quantica.hamiltonian","text":"hamiltonian(lat, model; orbitals, orbtype)\n\nCreate a Hamiltonian by applying model::TighbindingModel to the lattice lat (see hopping and onsite for details on building tightbinding models).\n\nlat |> hamiltonian(model; kw...)\n\nCurried form of hamiltonian equivalent to hamiltonian(lat, model; kw...).\n\nKeywords\n\nThe number of orbitals on each sublattice can be specified by the keyword orbitals (otherwise all sublattices have one orbital by default). The following, and obvious combinations, are possible formats for the orbitals keyword:\n\norbitals = :a                # all sublattices have 1 orbital named :a\norbitals = (:a,)             # same as above\norbitals = (:a, :b, 3)       # all sublattices have 3 orbitals named :a and :b and :3\norbitals = ((:a, :b), (:c,)) # first sublattice has 2 orbitals, second has one\norbitals = ((:a, :b), :c)    # same as above\norbitals = (Val(2), Val(1))  # same as above, with automatic names\norbitals = (:A => (:a, :b), :D => :c) # sublattice :A has two orbitals, :D and rest have one\norbitals = :D => Val(4)      # sublattice :D has four orbitals, rest have one\n\nThe matrix sizes of tightbinding model must match the orbitals specified. Internally, we define a block size N = max(num_orbitals). If N = 1 (all sublattices with one orbital) the Hamiltonian element type is orbtype. Otherwise it is SMatrix{N,N,orbtype} blocks, padded with the necessary zeros as required. Keyword orbtype is Complex{T} by default, where T is the number type of lat.\n\nIndexing\n\nIndexing into a Hamiltonian h works as follows. Access the HamiltonianHarmonic matrix at a given dn::NTuple{L,Int} with h[dn], or alternatively with h[] if L=0. Assign v into element (i,j) of said matrix with h[dn][i,j] = v or h[dn, i, j] = v. Broadcasting with vectors of indices is and js is supported, h[dn][is, js] = v_matrix.\n\nTo add an empty harmonic with a given dn::NTuple{L,Int}, do push!(h, dn). To delete it, do deleteat!(h, dn).\n\nExamples\n\njulia> h = hamiltonian(LatticePresets.honeycomb(), hopping(@SMatrix[1 2; 3 4], range = 1/√3), orbitals = Val(2))\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 × 2\n  Orbitals         : ((:a, :a), (:a, :a))\n  Element type     : 2 × 2 blocks (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 3.0\n\njulia> push!(h, (3,3)) # Adding a new Hamiltonian harmonic (if not already present)\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 6 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 × 2\n  Orbitals         : ((:a, :a), (:a, :a))\n  Element type     : 2 × 2 blocks (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 3.0\n\njulia> h[(3,3)][1,1] = @SMatrix[1 2; 2 1]; h[(3,3)] # element assignment\n2×2 SparseMatrixCSC{StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4},Int64} with 1 stored entry:\n  [1, 1]  =  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]\n\njulia> h[(3,3)][[1,2],[1,2]] .= Ref(@SMatrix[1 2; 2 1])\n2×2 view(::SparseMatrixCSC{StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4},Int64}, [1, 2], [1, 2]) with eltype StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4}:\n [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]\n [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]\n\nSee also\n\n`onsite`, `hopping`, `bloch`, `bloch!`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.hopping-Tuple{Any}","page":"Reference","title":"Quantica.hopping","text":"hopping(t; range = nrange(1), dn = missing, sublats = missing, indices = missing, region = missing, plusadjoint = false)\n\nCreate an TightbindingModel with a single HoppingTerm that applies a hopping t to a Lattice when creating a Hamiltonian with hamiltonian.\n\nThe hopping amplitude t can be a number, an SMatrix, a UniformScaling (e.g. 3*I) or a function of the form (r, dr) -> ... for a position-dependent hopping (r is the bond center, and dr the bond vector). If sublats is specified as a sublattice name pair, or tuple thereof, hopping is only applied between sublattices with said names.\n\nThe dimension of t::AbstractMatrix must match the orbital dimension of applicable sublattices (see also orbitals option for hamiltonian). If t::UniformScaling it will be converted to a (possibly rectangular) identity matrix of the appropriate size when applied to multiorbital sublattices. Similarly, if t::SMatrix it will be truncated or padded to the appropriate size.\n\nOnsiteTerms and HoppingTerms created with onsite or hopping can be added or substracted together to build more complicated TightbindingModels.\n\nhopping(model::TightbindingModel; kw...)\n\nReturn a TightbindingModel with only the hopping terms of model. Any non-missing kw is applied to all such terms.\n\nKeyword arguments\n\nMost keywords are the same as for hopselector. Only hoppings between two sites at positions r₁ = r - dr/2 and r₂ = r + dr, belonging to unit cells at integer distance dn´ and to sublattices s₁ and s₂ will be selected if: region(r, dr) && s in sublats && dn´ in dn && norm(dr) <= range. If any of these is missing it will not be used to constraint the selection.\n\nThe keyword range admits the following possibilities\n\nmax_range                   # i.e. `norm(dr) <= max_range`\n(min_range, max_range)      # i.e. `min_range <= norm(dr) <= max_range`\n\nBoth max_range and min_range can be a Real or a NeighborRange created with nrange(n). The latter represents the distance of n-th nearest neighbors. Note that the range default for hopping (unlike for the more general hopselector) is nrange(1), i.e. first-nearest-neighbors.\n\nThe keyword dn can be a Tuple/Vector/SVector of Ints, or a tuple thereof. The keyword sublats allows the following formats:\n\nsublats = :A => :B                 # Hopping from :A to :B sublattices\nsublats = (:A => :B,)              # Same as above\nsublats = (:A => :B, :C => :D)     # Hopping from :A to :B or :C to :D\nsublats = (:A, :C) .=> (:B, :D)    # Broadcasted pairs, same as above\nsublats = (:A, :C) => (:B, :D)     # Direct product, (:A=>:B, :A=:D, :C=>:B, :C=>D)\n\nThe keyword plusadjoint produces a model with the input hopping term plus its adjoint. Note that this substitution is made before multiplying by any coefficient, so that im*hopping(..., plusadjoint = true) == im*(hopping(...) + hopping(...)').\n\nCombining models\n\nOnsiteTerms and HoppingTerms created with onsite or hopping can added or substracted together or be multiplied by scalars to build more complicated TightbindingModels, e.g. onsite(1) - 3 * hopping(2)\n\nExamples\n\njulia> model = 3 * onsite(1) - hopping(2, dn = ((1,2), (0,0)), sublats = :A=>:B)\nTightbindingModel{2}: model with 2 terms\n  OnsiteTerm{Int64}:\n    Sublattices      : any\n    Coefficient      : 3\n  HoppingTerm{Int64}:\n    Sublattice pairs : (:A => :B,)\n    dn cell distance : ([1, 2], [0, 0])\n    Hopping range    : 1.0\n    Coefficient      : -1\n\njulia> newmodel = onsite(model) + hopping(model, range = 2)\nTightbindingModel{2}: model with 2 terms\n  OnsiteTerm{Int64}:\n    Sublattices      : any\n    Coefficient      : 3\n  HoppingTerm{Int64}:\n    Sublattice pairs : (:A => :B,)\n    dn cell distance : ([1, 2], [0, 0])\n    Hopping range    : 2.0\n    Coefficient      : -1\n\njulia> LatticePresets.honeycomb() |> hamiltonian(hopping((r,dr) -> cos(r[1]), sublats = (:A,:B) => (:A,:B)))\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 7 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 × 2\n  Orbitals         : ((:a,), (:a,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 18\n  Coordination     : 9.0\n\nSee also\n\n`onsite`, `nrange`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.hopselector-Tuple{}","page":"Reference","title":"Quantica.hopselector","text":"hopselector(; range = missing, dn = missing, sublats = missing, indices = missing, region = missing)\n\nReturn a HopSelector object that can be used to select hops between two sites in a lattice. Only hops between two sites, with indices ipair = src => dst, at positions r₁ = r - dr/2 and r₂ = r + dr, belonging to unit cells at integer distance dn´ and to sublattices s₁ and s₂ will be selected if:\n\n`region(r, dr) && s in sublats && dn´ in dn && norm(dr) <= range && ipair in indices`\n\nIf any of these is missing it will not be used to constraint the selection.\n\nThe keyword range admits the following possibilities\n\nmax_range                   # i.e. `norm(dr) <= max_range`\n(min_range, max_range)      # i.e. `min_range <= norm(dr) <= max_range`\n\nBoth max_range and min_range can be a Real or a NeighborRange created with nrange(n). The latter represents the distance of n-th nearest neighbors.\n\nThe keyword dn can be a Tuple/Vector/SVector of Ints, or a tuple thereof.\n\nThe keyword sublats allows the following formats:\n\nsublats = :A => :B                  # Hopping from :A to :B sublattices, but not from :B to :A\nsublats = (:A => :B,)               # Same as above\nsublats = (:A => :B, :C => :D)      # Hopping from :A to :B or :C to :D\nsublats = (:A, :C) .=> (:B, :D)     # Broadcasted pairs, same as above\nsublats = (:A, :C) => (:B, :D)      # Direct product, (:A=>:B, :A=:D, :C=>:B, :C=>D)\n\nThe keyword indices accepts a single src => dest pair or a collection thereof. Any src == dest will be neglected. Possible combinations:\n\nindices = 1 => 2                    # Hopping from site 1 to 2, but not from 2 to 1\nindices = (1 => 2, 2 => 1)          # Hoppings from 1 to 2 or from 2 to 1\nindices = [1 => 2, 2 => 1]          # Same as above\nindices = [(1, 2) .=> (2, 1)]       # Broadcasted pairs, same as above\nindices = [1:10 => 20:25, 3 => 30]  # Direct product, any hopping from sites 1:10 to sites 20:25, or from 3 to 30\n\nAdditionally, indices or sublattices can be wrapped in not to exclude them (see not):\n\nsublats = not(:A => :B, :B => :A)   # Any sublat pairs different from :A => :B or :B => :A\nsublats = not(:A) => :B             # Any sublat pair s1 => s2 with s1 different from :A and s2 equal to :B\nindices = not(8 => 9)               # Any site indices different from 8 => 9\nindices = 1 => not(3:4)             # Any site pair 1 => s with s different from 3, 4\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.ket-Tuple{AbstractArray{T,1} where T,Quantica.OrbitalStructure}","page":"Reference","title":"Quantica.ket","text":"ket(m::AbstractArray, o::OrbitalStructure)\nket(m::AbstractArray, h::Hamiltonian)\n\nConstruct a Ket |k⟩ with amplitudes ⟨i|k⟩ = m[i], which can be scalars or SVectors depending on the number of orbitals on site i. If m is an AbstractMatrix instead of an AbstractVector, the Ket represents a multi-column ket |kⱼ⟩, such that ⟨i|kⱼ⟩ = m[i,j]. The orbitals per sublattice are encoded in o = orbitalstructure(h).\n\nket(km::KetModel, h::Hamiltonian)\n\nConstruct a Ket by applying model km to Hamiltonian h (see also ketmodel for details).\n\nket(h::Hamiltonian)\n\nConstruct a zero ket, equivalent to ket(0, h; maporbitals = true, normalization = missing)\n\nSee also\n\n`ketmodel`, `ket!`, `onsite`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.ketmodel-Tuple{Any}","page":"Reference","title":"Quantica.ketmodel","text":"ketmodel(a; region = missing, sublats = missing, normalization = 1, maporbitals = false)\n\nCreate an KetModel of amplitude a on the specified region and sublats. For single-column kets, the amplitude a can be a Number, an AbstractVector, or for a position-dependent amplitude a function of the form r -> ... returning either. For multi-column kets, make a an AbstractMatrix{<:Number} or a function returning one, which will be sliced into each ket column as appropriate. An error will be thrown if the slicing is impossible.\n\nKeyword arguments\n\nIf keyword normalization is not missing, each column of the ket will be rescaled to have norm normalization when the KetModel is applied to a specific Hamiltonian. If a ket column iszero, however, it will not be normalized.\n\nIf keyword maporbitals == true and amplitude a is a scalar or a scalar function, a will be applied to each orbital independently. This is particularly useful in multiorbital systems with random amplitudes, e.g. a = randn. If a is not a scalar, an error will be thrown.\n\nKeywords region and sublats are the same as for siteselector. Only sites at position r in sublattice with name s::NameType will be selected if region(r) && s in sublats is true. Any missing region or sublat will not be used to constraint the selection.\n\nThe keyword sublats allows the following formats:\n\nsublats = :A           # Onsite on sublat :A only\nsublats = (:A,)        # Same as above\nsublats = (:A, :B)     # Onsite on sublat :A and :B\n\nKet algebra\n\nKetModels created with ket can added or substracted together or be multiplied by scalars to build more elaborate KetModels, e.g. ket(1) - 3 * ket(2, region = r -> norm(r) < 10)\n\nExamples\n\njulia> k = ket(1, sublats=:A) - ket(1, sublats=:B)\nKetModel{2}: model with 2 terms\n  Normalized : false\n  OnsiteTerm{Int64}:\n    Sublattices      : (:A,)\n    Coefficient      : 1\n  OnsiteTerm{Int64}:\n    Sublattices      : (:B,)\n    Coefficient      : -1\n\nSee also\n\n`ket`, `onsite`, `orbitalstructure`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.lattice-Tuple{Vararg{Quantica.Sublat,N} where N}","page":"Reference","title":"Quantica.lattice","text":"lattice(sublats::Sublat...; bravais = (), dim::Val{E}, type::T, names = missing)\n\nCreate a Lattice{E,L,T} with Bravais vectors bravais and sublattices sublats converted to a common  E-dimensional embedding space and type T. To override the embedding  dimension E, use keyword dim = Val(E). Similarly, override type T with type = T.\n\nThe keyword bravais indicates one or more Bravais vectors in the form of tuples or other iterables. It can also be an AbstractMatrix of dimension E×L. The default bravais = () corresponds to a bounded lattice with no Bravais vectors.\n\nA keyword names can be used to rename sublats. Given names can be replaced to ensure that all sublattice names are unique.\n\nlattice(lat::AbstractLattice; bravais = missing, dim = missing, type = missing, names = missing)\n\nCreate a new lattice by applying any non-missing kw to lat. For performance, allocations will be avoided if possible (depends on kw), so the result can share memory of lat. To avoid that, do lattice(copy(lat); kw...).\n\nSee also LatticePresets for built-in lattices.\n\nExamples\n\njulia> lattice(sublat((0, 0)), sublat((0, Float32(1))); bravais = (1, 0), dim = Val(3))\nLattice{3,1,Float32} : 1D lattice in 3D space\n  Bravais vectors : ((1.0f0, 0.0f0, 0.0f0),)\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (1, 1) --> 2 total per unit cell\n\njulia> LatticePresets.honeycomb(names = (:C, :D))\nLattice{2,2,Float64} : 2D lattice in 2D space\n  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))\n  Sublattices     : 2\n    Names         : (:C, :D)\n    Sites         : (1, 1) --> 2 total per unit cell\n\njulia> LatticePresets.cubic(bravais = ((1, 0), (0, 2)))\nLattice{3,2,Float64} : 2D lattice in 3D space\n  Bravais vectors : ((1.0, 0.0, 0.0), (0.0, 2.0, 0.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (1) --> 1 total per unit cell\n\nSee also\n\n`LatticePresets`, `bravais`, `sublat`, `supercell`, `intracell`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.momentaKPM","page":"Reference","title":"Quantica.momentaKPM","text":"momentaKPM(h::Hamiltonian, A = I; ket = randomkets(1), order = 10, bandrange = missing, flat = Val(true))\n\nCompute the Kernel Polynomial Method (KPM) momenta μₙ = ⟨k|Tₙ(h) A|k⟩, where k = ket(ket::KetModel, h), A is an observable (Hamiltonian or AbstractMatrix) and Tₙ(h) is the order-n Chebyshev polynomial of the Hamiltonian h.\n\nket can be a single KetModel or Ket, or a collection of them, as in the default ket = randomkets(n). In the latter case, μₙ is summed over all models/kets. The default is useful to estimate momenta of normalized traces using the stochastic trace approach, whereby μ_n = Tr[A T_n(h)]/N₀ ≈ ∑ₖ⟨k|A T_n(h)|k⟩. Here the |k⟩s are n random kets of norm 1/√n and N₀ is the total number of orbitals per unit cell of h (see randomkets).\n\nThe order of the Chebyshev expansion is order. The bandbrange = (ϵmin, ϵmax) should completely encompass the full bandwidth of hamiltonian. If missing it is computed automatically using ArnoldiMethod (must be loaded using ArnoldiMethod). flat indicates whether, in the case of multiorbital systems, the internal computations are to be performed using flattened arrays, typically increasing performace by making use of external linear algebra libraries (e.g. MKL or OpenBLAS).\n\nExamples\n\njulia> h = LatticePresets.cubic() |> hamiltonian(hopping(1)) |> unitcell(region = RegionPresets.sphere(10));\n\njulia> momentaKPM(h, bandrange = (-6,6)).mulist |> length\n11\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.not-Tuple{Any}","page":"Reference","title":"Quantica.not","text":"not(i)\n\nWrapper indicating the negation or complement of i, typically used to encode excluded site indices. See siteselector and hopselector for applications.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.nrange-Tuple{Int64}","page":"Reference","title":"Quantica.nrange","text":"nrange(n::Int)\n\nCreate a NeighborRange that represents a hopping range to distances corresponding to the n-th nearest neighbors in a given lattice. Such distance is obtained by finding the n-th closest pairs of sites in a lattice, irrespective of their sublattice.\n\nnrange(n::Int, lat::AbstractLattice)\n\nObtain the actual nth-nearest-neighbot distance between sites in lattice lat.\n\nSee also\n\n`hopping`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.offdiagonal-Tuple{Quantica.TightbindingModel,Any,Any}","page":"Reference","title":"Quantica.offdiagonal","text":"offdiagonal(model, lat, nsublats::NTuple{N,Int})\n\nBuild a restricted version of model that applies only to off-diagonal blocks formed by sublattice groups of size nsublats.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.onsite-Tuple{Any}","page":"Reference","title":"Quantica.onsite","text":"onsite(o; region = missing, sublats = missing)\n\nCreate an TightbindingModel with a single OnsiteTerm that applies an onsite energy o to a Lattice when creating a Hamiltonian with hamiltonian.\n\nThe onsite energy o can be a number, an SMatrix, a UniformScaling (e.g. 3*I) or a function of the form r -> ... for a position-dependent onsite energy.\n\nThe dimension of o::AbstractMatrix must match the orbital dimension of applicable sublattices (see also orbitals option for hamiltonian). If o::UniformScaling it will be converted to an identity matrix of the appropriate size when applied to multiorbital sublattices. Similarly, if o::SMatrix it will be truncated or padded to the appropriate size.\n\nonsite(model::TightbindingModel; kw...)\n\nReturn a TightbindingModel with only the onsite terms of model. Any non-missing kw is applied to all such terms.\n\nKeyword arguments\n\nKeywords are the same as for siteselector. Only sites at position r in sublattice with name s::NameType will be selected if region(r) && s in sublats is true. Any missing region or sublat will not be used to constraint the selection.\n\nThe keyword sublats allows the following formats:\n\nsublats = :A           # Onsite on sublat :A only\nsublats = (:A,)        # Same as above\nsublats = (:A, :B)     # Onsite on sublat :A and :B\n\nCombining models\n\nOnsiteTerms and HoppingTerms created with onsite or hopping can added or substracted together or be multiplied by scalars to build more complicated TightbindingModels, e.g. onsite(1) - 3 * hopping(2)\n\nExamples\n\njulia> model = onsite(1, sublats = (:A,:B)) - 2 * hopping(2, sublats = :A=>:A)\nTightbindingModel{2}: model with 2 terms\n  OnsiteTerm{Int64}:\n    Sublattices      : (:A, :B)\n    Coefficient      : 1\n  HoppingTerm{Int64}:\n    Sublattice pairs : (:A => :A,)\n    dn cell distance : any\n    Hopping range    : 1.0\n    Coefficient      : -2\n\njulia> newmodel = onsite(model; sublats = :A) + hopping(model)\nTightbindingModel{2}: model with 2 terms\n  OnsiteTerm{Int64}:\n    Sublattices      : (:A,)\n    Coefficient      : 1\n  HoppingTerm{Int64}:\n    Sublattice pairs : (:A => :A,)\n    dn cell distance : any\n    Hopping range    : 1.0\n    Coefficient      : -2\n\njulia> LatticePresets.honeycomb() |> hamiltonian(onsite(r -> @SMatrix[1 2; 3 4]), orbitals = Val(2))\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 1 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 × 2\n  Orbitals         : ((:a, :a), (:a, :a))\n  Element type     : 2 × 2 blocks (Complex{Float64})\n  Onsites          : 2\n  Hoppings         : 0\n  Coordination     : 0.0\n\nSee also\n\n`hopping`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.orbitalstructure-Tuple{Quantica.Hamiltonian}","page":"Reference","title":"Quantica.orbitalstructure","text":"orbitalstructure(x::Union{Hamiltonian,ParametricHamiltonian})\norbitalstructure(x::Subspace)\n\nReturn an OrbitalStructure containing information about the orbital structure of x\n\nExamples\n\njulia> sp = spectrum(LP.honeycomb() |> hamiltonian(hopping(I), orbitals = (:up,:down)) |> unitcell);\n\njulia> sp[around = -1] |> orbitalstructure\nOrbitalStructure: orbital structure of Hamiltonian\n  Orbital Type  : SVector{2, ComplexF64}\n  Orbitals      : ((:up, :down), (:up, :down))\n  Sublattices   : 2\n  Dimensions    : 2\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.parameters-Tuple{Quantica.ParametricHamiltonian}","page":"Reference","title":"Quantica.parameters","text":"parameters(ph::ParametricHamiltonian)\n\nReturn the names of the parameter that ph depends on\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.parameters-Tuple{Vararg{Quantica.ElementModifier,N} where N}","page":"Reference","title":"Quantica.parameters","text":"parameters(p::ElementModifier...)\n\nReturn the parameter names for one or several  ElementModifier created with @onsite! or @hopping!\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.parametric-Tuple{Quantica.Hamiltonian,Vararg{Quantica.ElementModifier,N} where N}","page":"Reference","title":"Quantica.parametric","text":"parametric(h::Hamiltonian, modifiers::ElementModifier...)\n\nBuilds a ParametricHamiltonian that can be used to efficiently apply modifiers to h. modifiers can be any number of @onsite!(args -> body; kw...) and @hopping!(args -> body; kw...) transformations, each with a set of parameters ps given as keyword arguments of functions f = (...; ps...) -> body.\n\nFor sparse h (the default), parametric only modifies existing onsites and hoppings in h, so be sure to add zero onsites and/or hoppings to h if they are originally not present but you need to apply modifiers to them.\n\nph(; ps...)\n\nFor a ph::ParametricHamiltonian, return the corresponding Hamiltonian with parameters ps applied.\n\nh |> parametric(modifiers::ElementModifier...)\n\nFunction form of parametric, equivalent to parametric(h, modifiers...).\n\nExamples\n\njulia> ph = LatticePresets.honeycomb() |> hamiltonian(onsite(0) + hopping(1, range = 1/√3)) |>\n       unitcell(10) |> parametric(@onsite!((o; μ) -> o - μ))\nParametricHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)\n  Harmonic size    : 200 × 200\n  Orbitals         : ((:a,), (:a,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 600\n  Coordination     : 3.0\n  Parameters       : (:μ,)\n\njulia> ph(μ = 2)\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)\n  Harmonic size    : 200 × 200\n  Orbitals         : ((:a,), (:a,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 200\n  Hoppings         : 600\n  Coordination     : 3.0\n\nSee also\n\n`@onsite!`, `@hopping!`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.randomkets","page":"Reference","title":"Quantica.randomkets","text":"randomkets(n, a = r -> cis(2pi*rand()); kw...)\n\nCreate a lazy collection of n KetModels of amplitude a, and normalization = 1/√n. Other keyword arguments are forwarded to ketmodel.\n\nThis type of ket model is useful e.g. in stochastic trace evaluation of KPM methods, where the amplitude is chosen as a random function with ⟨a⟩ = 0, ⟨aa⟩ = 0 and ⟨a'a⟩ = 1. The default a is a uniform random phase on each site, which satisties these conditions. Then, the normalized trace of an operator A can be estimated with Tr[A]/N₀ ≈ ∑⟨ket|A|ket⟩, where the sum is taken over the n random kets |ket⟩ of norm 1/√n produced by randomkets, and N₀ is the total number of orbitals in the full unit cell.\n\nTo apply it to a multiorbital system with a maximum of N orbitals per site, a must in general be adapted to produce the desired random SVector{N} (unless maporbitals = true), with the above statistical properties for each orbital. Example: to have independent, complex, normally-distributed random components of two orbitals use randomkets(n, r -> randn(SVector{2,ComplexF64})), or alternatively randomkets(n, r -> randn(ComplexF64), maporbitals = true).\n\nSee also\n\n`ket`\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.similarmatrix","page":"Reference","title":"Quantica.similarmatrix","text":"similarmatrix(h::Hamiltonian)\n\nCreate an uninitialized matrix of the same type and size of the Hamiltonian's matrix.\n\nsimilarmatrix(h::Hamiltonian, T::Type{<:AbstractMatrix})\n\nMake the matrix of type B<:T. Can be used to specify a different eltype from h's, (e.g. T=SparseMatrixCSC{Float64} with a multiorbital h)\n\nsimilarmatrix(h::Hamiltonian, flatten)\n\nCreate an unitialized matrix of the same type as a flattened version of h's, i.e. with a scalar eltype as in the example above.\n\nsimilarmatrix(h::Hamiltonian, T::AbstractDiagonalizeMethod)\n\nAdapts the type of the matrix (e.g. dense/sparse) to the specified method\n\nsimilarmatrix(x::Union{ParametricHamiltonian, GreensFunction}, ...)\n\nEquivalent to the above, but adapted to the more general type of x.\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |> hamiltonian(hopping(I), orbitals = Val(2))\n\njulia> similarmatrix(h) |> summary\n\"2×2 SparseMatrixCSC{StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4},Int64}\"\n\njulia> similarmatrix(h, Matrix{Int}) |> summary\n\"4×4 Array{Int64,2}\"\n\njulia> similarmatrix(h, flatten) |> summary\n\"4×4 SparseMatrixCSC{Complex{Float64},Int64}\"\n\njulia> similarmatrix(h, LinearAlgebraPackage()) |> summary\n\"4×4 Array{Complex{Float64},2}\"\n\nSee also\n\n`bloch!`\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.siteindices-Tuple{Quantica.AbstractLattice}","page":"Reference","title":"Quantica.siteindices","text":"siteindices(lat::AbstractLattice; kw...)\nsiteindices(lat::Hamiltonian; kw...)\n\nBuild a generator of the unique indices of sites in the lattice unitcell. Only sites specified by siteselector(kw...) are selected, see siteselector for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.sitepositions-Tuple{Quantica.AbstractLattice}","page":"Reference","title":"Quantica.sitepositions","text":"sitepositions(lat::AbstractLattice; kw...)\nsitepositions(h::Hamiltonian; kw...)\n\nBuild a generator of the positions of sites in the lattice unitcell. Only sites specified by siteselector(kw...) are selected, see siteselector for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.siteselector-Tuple{}","page":"Reference","title":"Quantica.siteselector","text":"siteselector(; region = missing, sublats = missing, indices = missing)\n\nReturn a SiteSelector object that can be used to select sites in a lattice contained within the specified region and sublattices. Only sites with index i, at position r and belonging to a sublattice with name s::NameType will be selected if\n\n`region(r) && s in sublats && i in indices`\n\nAny missing region, sublat or indices will not be used to constraint the selection.\n\nThe keyword sublats allows the following formats:\n\nsublats = :A                    # Sites on sublat :A only\nsublats = (:A,)                 # Same as above\nsublats = (:A, :B)              # Sites on sublat :A and :B\n\nThe keyword indices accepts a single integer, or a collection thereof. If several collections are given, they are flattened into a single one. Possible combinations:\n\nindices = 1                     # Site 1 only\nindices = (1, )                 # Same as above\nindices = (1, 2, 3)             # Sites 1, 2 or 3\nindices = [1, 2, 3]             # Same as above\nindices = 1:3                   # Same as above\nindices = (1:3, 7, 8)           # Sites 1, 2, 3, 7 or 8\n\nAdditionally, indices or sublattices can be wrapped in not to exclude them (see not):\n\nsublats = not(:A)               # Any sublat different from :A\nsublats = not(:A, :B)           # Any sublat different from :A and :B\nindices = not(8)                # Any site index different from 8\nindices = not(1, 3:4)           # Any site index different from 1, 3 or 4\nindices = (not(3:4), 4:6)       # Any site different from 3 and 4, *or* equal to 4, 5 or 6\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.spectrum-Tuple{Any}","page":"Reference","title":"Quantica.spectrum","text":"spectrum(h; method = LinearAlgebraPackage(), transform = missing)\n\nCompute the spectrum of a 0D Hamiltonian h (or alternatively of the bounded unit cell of a finite dimensional h) using one of the following methods\n\nmethod                    diagonalization function\n--------------------------------------------------------------\nLinearAlgebraPackage()     LinearAlgebra.eigen!\nArpackPackage()            Arpack.eigs (must be `using Arpack`)\n\nThe option transform = ε -> f(ε) allows to transform eigenvalues by f in the returned spectrum (useful for performing shifts or other postprocessing).\n\nIndexing\n\nThe eigenenergies εv::Vector and eigenstates ψm::Matrix in a s::Spectrum object can be accessed via destructuring, εv, ψm = sp, or εv, ψm = Tuple(sp), or εv = first(sp) = sp.energies, ψm = last(sp) = sp.states. Any degenerate energies appear repeated in εv. Alternatively, one can access one or more complete sub::Subspaces (eigenenergy together with its eigenstates, including all degenerates) via the indexing syntax,\n\ns[1]                   : first `Subspace`\ns[2:4]                 : subspaces 2, 3 and 4\ns[[2,5,6]]             : subspaces 2, 5 and 6\ns[around = 0.2]        : single subspace with energy closest to 0.2\ns[around = (0.2, 10)]  : the ten subspaces with energies closest to 0.2\n\nThe eigenenergy ε and subspace basis ψs of a sub::Subspace can be obtained via destructuring, ε, ψs = sub, or ε = first(sub) = sub.energy, ψs = last(sub) = sub.basis. For performance reasons ψs is a SubArray view of the appropriate columns of ψm, not an independent copy.\n\nSee also\n\n`bandstructure`, `diagonalizer`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.splitbands-Tuple{Quantica.Bandstructure}","page":"Reference","title":"Quantica.splitbands","text":"splitbands(bs::Bandstructure)\n\nSplits the bands in bs into disconnected subbands that share no vertices. See also splitbands option in bandstructure.\n\nSee also\n\n`bandstructure`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.sublat-Tuple{AbstractArray{#s38,1} where #s38<:(StaticArrays.SArray{Tuple{S},T,1,S} where T where S)}","page":"Reference","title":"Quantica.sublat","text":"sublat(sites...; name::Symbol)\nsublat(sites::Vector{<:SVector}; name::Symbol)\n\nCreate a Sublat{E,T,D} that adds a sublattice, of name name, with sites at positions sites in E dimensional space. Sites can be entered as tuples or SVectors.\n\nExamples\n\njulia> sublat((0.0, 0), (1, 1), (1, -1), name = :A)\nSublat{2,Float64} : sublattice of Float64-typed sites in 2D space\n  Sites    : 3\n  Name     : :A\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.supercell-Tuple","page":"Reference","title":"Quantica.supercell","text":"supercell(lat::AbstractLattice{E,L}, v::NTuple{L,Integer}...; seed = missing, kw...)\nsupercell(lat::AbstractLattice{E,L}, sc::SMatrix{L,L´,Int}; seed = missing, kw...)\n\nGenerates a Superlattice from an L-dimensional lattice lat with Bravais vectors br´= br * sc, where sc::SMatrix{L,L´,Int} is the integer supercell matrix with the L´ vectors vs as columns. If no v are given, the superlattice will be bounded.\n\nOnly sites selected by siteselector(; kw...) will be included in the supercell (see siteselector for details on the available keywords kw). The search for included sites will start from point seed::Union{Tuple,SVector}, or the origin if seed = missing. If no keyword region is given in kw, a Bravais unit cell perpendicular to the v axes will be selected for the L-L´ non-periodic directions.\n\nsupercell(lattice::AbstractLattice{E,L}, factor::Integer; kw...)\n\nCalls supercell with a uniformly scaled sc = SMatrix{L,L}(factor * I)\n\nsupercell(lattice::AbstractLattice, factors::Integer...; kw...)\n\nCalls supercell with different scaling along each Bravais vector (diagonal supercell with factors along the diagonal)\n\nlat |> supercell(v...; kw...)\n\nCurried syntax, equivalent to `supercell(lat, v...; kw...)\n\nsupercell(h::Hamiltonian, v...; kw...)\n\nPromotes the Lattice of h to a Superlattice without changing the Hamiltonian itself, which always refers to the unitcell of the lattice.\n\nExamples\n\njulia> supercell(LatticePresets.honeycomb(), region = RegionPresets.circle(300))\nSuperlattice{2,2,Float64,0} : 2D lattice in 2D space, filling a 0D supercell\n  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (1, 1) --> 2 total per unit cell\n  Supercell{2,0} for 0D superlattice of the base 2D lattice\n    Supervectors  : ()\n    Supersites    : 652966\n\njulia> supercell(LatticePresets.triangular(), (1,1), (1, -1))\nSuperlattice{2,2,Float64,2} : 2D lattice in 2D space, filling a 2D supercell\n  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (1) --> 1 total per unit cell\n  Supercell{2,2} for 2D superlattice of the base 2D lattice\n    Supervectors  : ((1, 1), (1, -1))\n    Supersites    : 2\n\njulia> LatticePresets.square() |> supercell(3)\nSuperlattice{2,2,Float64,2} : 2D lattice in 2D space, filling a 2D supercell\n  Bravais vectors : ((1.0, 0.0), (0.0, 1.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (1) --> 1 total per unit cell\n  Supercell{2,2} for 2D superlattice of the base 2D lattice\n    Supervectors  : ((3, 0), (0, 3))\n    Supersites    : 9\n\nSee also\n\n`unitcell`, `siteselector`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.transform!-Tuple{Any,Quantica.Bandstructure}","page":"Reference","title":"Quantica.transform!","text":"transform!(f::Function, b::Bandstructure)\n\nTransform the energies of all bands in b by applying f to them in place.\n\ntransform!((fk, fε), b::Bandstructure)\n\nTransform Bloch phases and energies of all bands in b by applying fk and fε to them in place, respectively. If any of them is missing, it will be ignored.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.transform!-Tuple{Any,Quantica.Hamiltonian}","page":"Reference","title":"Quantica.transform!","text":"transform!(f::Function, h::Hamiltonian)\n\nTransform the site positions of the Hamiltonian's lattice in place without modifying the Hamiltonian harmonics.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.transform!-Tuple{Any,Quantica.Spectrum}","page":"Reference","title":"Quantica.transform!","text":"transform!(f::Function, s::Spectrum)\n\nTransform the energies of s by applying f to them in place.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.transform!-Tuple{Function}","page":"Reference","title":"Quantica.transform!","text":"x |> transform!(f::Function)\n\nCurried version of transform!, equivalent to transform!(f, x)\n\ntransform!(f::Function, lat::Lattice)\n\nTransform the site positions of lat by applying f to them in place.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.unflatten","page":"Reference","title":"Quantica.unflatten","text":"unflatten(x, o::OrbitalStructure)\n\nRebuild object x performing the inverse of flatten(x) or flatten(x, o). The target o is required.\n\nExamples\n\njulia> h = LP.honeycomb() |> hamiltonian(hopping(I), orbitals = (:up,:down)) |> unitcell;\n\njulia> psi = spectrum(h)[around = -1]\nSubspace{0}: eigenenergy subspace on a 0D manifold\n  Energy       : -0.9999999999999989\n  Degeneracy   : 2\n  Bloch/params : Float64[]\n  Basis eltype : SVector{2, ComplexF64}\n\njulia> psiflat = flatten(psi)\nSubspace{0}: eigenenergy subspace on a 0D manifold\n  Energy       : -0.9999999999999989\n  Degeneracy   : 2\n  Bloch/params : Float64[]\n  Basis eltype : ComplexF64\n\njulia> unflatten(psiflat, orbitalstructure(psi))\nSubspace{0}: eigenenergy subspace on a 0D manifold\n  Energy       : -0.9999999999999989\n  Degeneracy   : 2\n  Bloch/params : Float64[]\n  Basis eltype : SVector{2, ComplexF64}\n\nSee also\n\n`flatten`, `orbitalstructure`\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.unitcell-Tuple{Vararg{Union{Integer, Tuple, StaticArrays.SArray{Tuple{S},T,1,S} where T where S, StaticArrays.SArray{Tuple{S1,S2},T,2,L} where L where T where S2 where S1},N} where N}","page":"Reference","title":"Quantica.unitcell","text":"unitcell(lat::Lattice{E,L}, v::NTuple{L,Integer}...; seed = missing, kw...)\nunitcell(lat::Lattice{E,L}, uc::SMatrix{L,L´,Int}; seed = missing, kw...)\n\nGenerates a Lattice from an L-dimensional lattice lat and a larger unit cell, such that its Bravais vectors are br´= br * uc. Here uc::SMatrix{L,L´,Int} is the integer unitcell matrix, with the L´ vectors vs as columns. If no v are given, the new lattice will be bounded.\n\nOnly sites selected by siteselector(; kw...) will be included in the supercell (see siteselector for details on the available keywords kw). The search for included sites will start from point seed::Union{Tuple,SVector}, or the origin if seed = missing. If no keyword region is given in kw, a Bravais unit cell perpendicular to the v axes will be selected for the L-L´ non-periodic directions.\n\nunitcell(lattice::Lattice{E,L}, factor::Integer; kw...)\n\nCalls unitcell with a uniformly scaled uc = SMatrix{L,L}(factor * I)\n\nunitcell(lattice::Lattice{E,L}, factors::Integer...; kw...)\n\nCalls unitcell with different scaling along each Bravais vector (diagonal supercell with factors along the diagonal)\n\nunitcell(slat::Superlattice)\n\nConvert Superlattice slat into a lattice with its unit cell matching slat's supercell.\n\nunitcell(h::Hamiltonian, v...; mincoordination, modifiers = (), kw...)\n\nTransforms the Lattice of h to have a larger unitcell, while expanding the Hamiltonian accordingly.\n\nA nonzero mincoordination indicates a minimum number of nonzero hopping neighbors required for sites to be included in the resulting unit cell. Sites with inferior coordination will be removed recursively, until all remaining satisfy mincoordination.\n\nThe modifiers (a tuple of ElementModifiers, either @onsite! or @hopping! with no free parameters) will be applied to onsite and hoppings as the hamiltonian is expanded. See @onsite! and @hopping! for details.\n\nNote: for performance reasons, in sparse hamiltonians only the stored onsites and hoppings will be transformed by ElementModifiers, so you might want to add zero onsites or hoppings when building h to have a modifier applied to them later.\n\nlat_or_h |> unitcell(v...; kw...)\n\nCurried syntax, equivalent to unitcell(lat_or_h, v...; kw...)\n\nExamples\n\njulia> unitcell(LatticePresets.honeycomb(), region = RegionPresets.circle(300))\nLattice{2,0,Float64} : 0D lattice in 2D space\n  Bravais vectors : ()\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (326483, 326483) --> 652966 total per unit cell\n\njulia> unitcell(LatticePresets.triangular(), (1,1), (1, -1))\nLattice{2,2,Float64} : 2D lattice in 2D space\n  Bravais vectors : ((0.0, 1.732051), (1.0, 0.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (2) --> 2 total per unit cell\n\njulia> LatticePresets.square() |> unitcell(3)\nLattice{2,2,Float64} : 2D lattice in 2D space\n  Bravais vectors : ((3.0, 0.0), (0.0, 3.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (9) --> 9 total per unit cell\n\njulia> supercell(LatticePresets.square(), 3) |> unitcell\nLattice{2,2,Float64} : 2D lattice in 2D space\n  Bravais vectors : ((3.0, 0.0), (0.0, 3.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (9) --> 9 total per unit cell\n\nSee also\n\n`supercell`, `siteselector`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.vertices-Tuple{Quantica.Bandstructure,Any}","page":"Reference","title":"Quantica.vertices","text":"vertices(bs::Bandstructure, i)\n\nReturn the vertices (k..., ϵ) of the i-th band in bs, in the form of a Vector{SVector{L+1}}, where L is the lattice dimension.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.wrap-Tuple{Quantica.Hamiltonian,Int64}","page":"Reference","title":"Quantica.wrap","text":"wrap(h::Hamiltonian, axes; phases = missing)\n\nBuild a new Hamiltonian from h reducing its dimensions from L to L - length(axes) by wrapping the specified Bravais axes into a loop. axes can be an integer ∈ 1:L or a tuple of such integers. If phases are given (with length(axes) == length(phases)), the wrapped hoppings at a cell distance dn along axes will be multiplied by a factor cis(-dot(phases, dn)). This is useful, for example, to represent a flux Φ through a loop, using a single axes = 1 and phases = 2π * Φ/Φ₀.\n\nwrap(h::Hamiltonian; kw...)\n\nWrap all axes of h, yielding a compactified zero-dimensional Hamiltonian.\n\nh |> wrap(axes; kw...)\n\nCurried form equivalent to wrap(h, axes; kw...).\n\nExamples\n\njulia> LatticePresets.honeycomb() |> hamiltonian(hopping(1, range = 1/√3)) |>\n       unitcell((1,-1), (10, 10)) |> wrap(2)\nHamiltonian{<:Lattice} : Hamiltonian on a 1D Lattice in 2D space\n  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)\n  Harmonic size    : 40 × 40\n  Orbitals         : ((:a,), (:a,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 120\n  Coordination     : 3.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.@hopping!-Tuple{Any,Any}","page":"Reference","title":"Quantica.@hopping!","text":"@hopping!(args -> body; kw...)\n\nCreate an ElementModifier, to be used with parametric, that applies f = args -> body to hoppings energies specified by kw (see hopping for details on possible kws). The form of args -> body may be (t; params...) -> ... or (t, r, dr; params...) -> ... if the modification is position (r, dr) dependent. Keyword arguments params are optional, and include any parameters that body depends on that the user may want to tune.\n\nNote: unlike onsite and hopping, ElementModifiers cannot be combined (i.e. you cannot do @onsite!(...) + @hopping!(...)). ElementModifiers are not model terms but transformations of an existing Hamiltonian that are meant to be applied sequentially (the order of application usually matters).\n\nSee also\n\n`@onsite!`, `parametric`\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Quantica.@onsite!-Tuple{Any,Any}","page":"Reference","title":"Quantica.@onsite!","text":"@onsite!(args -> body; kw...)\n\nCreate an ElementModifier, to be used with parametric, that applies f = args -> body to onsite energies specified by kw (see onsite for details  on possible kws). The form of args -> body may be (o; params...) -> ... or (o, r; params...) -> ... if the modification is position (r) dependent. Keyword arguments params are optional, and include any parameters that body depends on that the user may want to tune.\n\nNote: unlike onsite and hopping, ElementModifiers cannot be combined (i.e. you cannot do @onsite!(...) + @hopping!(...)). ElementModifiers are not model terms but transformations of an existing Hamiltonian that are meant to be applied sequentially (the order of application usually matters).\n\nSee also\n\n`@hopping!`, `parametric`\n\n\n\n\n\n","category":"macro"},{"location":"#Quantica.jl","page":"Home","title":"Quantica.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Quantica.jl is a Julia package for building generic tight-binding models and computing various spectral and transport properties.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Important information\nThis package supersedes Elsa.jl, which will soon be deprecated.","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"tutorial.md\",\n    \"examples.md\",\n    \"reference.md\",\n]\nDepth = 1","category":"page"},{"location":"#Current-functionality","page":"Home","title":"Current functionality","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Build arbitrary lattices (periodic or bounded in any dimension and with any unit cell)\nDefine generic model Hamiltonians by applying a model onto a lattice\nUse models with arbitrary orbital structure, spatial dependence and coordination (e.g. normal/superconducting, spin-orbit coupling, etc.)\nDefine parametric Hamiltonians that efficiently implement external parameters dependencies\nEfficiently compute the Bloch Hamiltonian matrix at arbitrary wave vector\nCompute the band structure or spectrum of a Hamiltonian, using advanced meshing and co-diagonalization techniques to resolve degeneracies and extract subbands\nUse Order-N Kernel polynomial methods to compute spectral and transport properties efficiently","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Funding\nThis work has been partly funded by the Spanish Ministry of Economy and Competitiveness under Grant Nos. FIS2015-65706-P, PCI2018-093026, and the CSIC Intramural Project 201760I086.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"}]
}
