var documenterSearchIndex = {"docs":
[{"location":"tutorial/greenfunctions/#GreenFunctions","page":"GreenFunctions","title":"GreenFunctions","text":"","category":"section"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"Up to now we have seen how to define Lattices, Models, Hamiltonians and Bandstructures. Most problems require the computation of different physical observables for these objects, e.g. the local density of states or various transport coefficients. We reduce this general problem to the computation of the retarded Green function","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"G^r_ij(omega) = langle i(omega-H-Sigma(omega))^-1jrangle","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"where i, j are orbitals, H is the (possibly infinite) Hamiltonian matrix, and Σ(ω) is the self-energy coming from any coupling to other systems (typically described by their own AbstractHamiltonian).","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"We split the problem of computing Gʳᵢⱼ(ω) of a given h::AbstractHamiltonian into four steps:","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"Attach self-energies to h using the command oh = attach(h, args...). This produces a new object oh::OpenHamiltonian with a number of Contacts, numbered 1 to N\nUse g = greenfunction(oh, solver) to build a g::GreenFunction representing Gʳ (at arbitrary ω and i,j), where oh::OpenHamiltonian and solver::GreenSolver (see GreenSolvers below for available solvers)\nEvaluate gω = g(ω; params...) at fixed energy ω and model parameters, which produces a gω::GreenSolution\nSlice gω[sᵢ, sⱼ] or gω[sᵢ] == gω[sᵢ, sᵢ] to obtain Gʳᵢⱼ(ω) as a flat matrix, where sᵢ, sⱼ are either site selectors over sites spanning orbitals i,j, integers denoting contacts, 1 to N, or : denoting all contacts merged together.","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"tip: GreenSlice vs. GreenSolution\nThe two last steps can be interchanged, by first obtaining a gs::GreenSlice with gs = g[sᵢ, sⱼ] and then obtaining the Gʳᵢⱼ(ω) matrix with gs(ω; params...).","category":"page"},{"location":"tutorial/greenfunctions/#A-simple-example","page":"GreenFunctions","title":"A simple example","text":"","category":"section"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"Here is a simple example of the Green function of a 1D lead with two sites per unit cell, a boundary at cell = 0, and with no attached self-energies for simplicity","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"julia> hlead = LP.square() |> supercell((1,0), region = r -> 0 <= r[2] < 2) |> hopping(1);\n\njulia> glead = greenfunction(hlead, GreenSolvers.Schur(boundary = 0))\nGreenFunction{Float64,2,1}: Green function of a Hamiltonian{Float64,2,1}\n  Solver          : AppliedSchurGreenSolver\n  Contacts        : 0\n  Contact solvers : ()\n  Contact sizes   : ()\n  Hamiltonian{Float64,2,1}: Hamiltonian on a 1D Lattice in 2D space\n    Bloch harmonics  : 3\n    Harmonic size    : 2 × 2\n    Orbitals         : [1]\n    Element type     : scalar (ComplexF64)\n    Onsites          : 0\n    Hoppings         : 6\n    Coordination     : 3.0\n\njulia> gω = glead(0.2)  # we first fix energy to ω = 0.2\nGreenSolution{Float64,2,1}: Green function at arbitrary positions, but at a fixed energy\n\njulia> gω[cells = 1:2]  # we now ask for the Green function between orbitals in the first two unit cells to the righht of the boundary\n4×4 Matrix{ComplexF64}:\n   0.1-0.858258im    -0.5-0.0582576im  -0.48-0.113394im   -0.2+0.846606im\n  -0.5-0.0582576im    0.1-0.858258im    -0.2+0.846606im  -0.48-0.113394im\n -0.48-0.113394im    -0.2+0.846606im   0.104-0.869285im   0.44+0.282715im\n  -0.2+0.846606im   -0.48-0.113394im    0.44+0.282715im  0.104-0.869285im","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"Note that the result is a 4 x 4 matrix, because there are 2 orbitals (one per site) in each of the two unit cells. Note also that the Schur GreenSolver used here allows us to compute the Green function between distant cells with little overhead","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"julia> @time gω[cells = 1:2];\n  0.000067 seconds (70 allocations: 6.844 KiB)\n\njulia> @time gω[cells = (SA[10], SA[100000])];\n  0.000098 seconds (229 allocations: 26.891 KiB)","category":"page"},{"location":"tutorial/greenfunctions/#GreenSolvers","page":"GreenFunctions","title":"GreenSolvers","text":"","category":"section"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"The currently implemented GreenSolvers (abbreviated as GS) are the following","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"GS.SparseLU()\nFor bounded (L=0) AbstractHamiltonians. Default for L=0.\nUses a sparse LU factorization to compute the ⟨i|(ω - H - Σ(ω))⁻¹|j⟩ inverse.","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"GS.KPM(order = 100, bandrange = missing, kernel = I)\nFor bounded (L=0) Hamiltonians, and restricted to sites belonging to contacts (see the section on Contacts).\nIt precomputes the Chebyshev momenta","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"GS.Schur(boundary = Inf)\nFor 1D (L=1) AbstractHamiltonians with only nearest-cell coupling. Default for L=1.\nUses a deflating Generalized Schur (QZ) factorization of the generalized eigenvalue problem to compute the unit-cell self energies. The Dyson equation then yields the Green function between arbitrary unit cells, which is further dressed using a T-matrix approach if the lead has any attached self-energy.\nGS.Bands(bandsargs...; boundary = missing, bandskw...)\nFor unbounded (L>0) Hamiltonians.\nIt precomputes a bandstructure b = bands(h, bandsargs...; kw..., split = false) and then uses analytic expressions for the contribution of each subband simplex to the GreenSolution. If boundary = dir => cell_pos, it takes into account the reflections on an infinite boundary perpendicular to Bravais vector number dir, so that all sites with cell index c[dir] <= cell_pos are removed.\nTo retrieve the bands from a g::GreenFunction that used the GS.Bands solver, we may use bands(g).","category":"page"},{"location":"tutorial/greenfunctions/#Attaching-Contacts","page":"GreenFunctions","title":"Attaching Contacts","text":"","category":"section"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"A self energy Σ(ω) acting of a finite set of sites of h (i.e. on a LatticeSlice of lat = lattice(h)) can be incorporated using the attach command. This defines a new Contact in h. The general syntax is oh = attach(h, args...; sites...), where the sites directives define the Contact LatticeSlice (lat[siteselector(; sites...)]), and args can take a number of forms.","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"The supported attach forms are the following","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"Generic self-energy\nattach(h, gs::GreenSlice, coupling::AbstractModel; sites...)\nThis is the generic form of attach, which couples some sites i of a g::Greenfunction (defined by the slice gs = g[i]), to sites of h using a coupling model. This results in a self-energy Σ(ω) = V´⋅gs(ω)⋅V on h sites, where V and V´ are couplings matrices given by coupling.","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"Dummy self-energy\nattach(h, nothing; sites...)\nThis form merely defines a new contact on the specified sites, but  adds no actual self-energy to it. It is meant as a way to refer to some sites of interest using the g[i::Integer] slicing syntax for GreenFunctions, where i is the contact index.","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"Model self-energy\nattach(h, model::AbstractModel; sites...)\nThis form defines a self-energy Σᵢⱼ(ω) in terms of model, which must be composed purely of parametric terms (@onsite and @hopping) that have ω as first argument, as in e.g. @onsite((ω, r) -> Σᵢᵢ(ω, r)) or @hopping((ω, r, dr) -> Σᵢⱼ(ω, r, dr)). This is a modellistic approach, wherein the self-energy is not computed from the properties of another AbstractHamiltonian, but rather has an arbitrary form defined by the user.","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"Matched lead self-energy\nattach(h, glead::GreenFunction; reverse = false, transform = identity, sites...)\nHere glead is a GreenFunction of a 1D lead, possibly with a boundary.\nWith this syntax sites must select a number of sites in h whose position match (after applying transform to them and modulo an arbitrary displacement) the sites in the unit cell of glead. Then, the coupling between these and the first unit cell of glead on the positive side of the boundary will be the same as between glead unitcells, i.e. V = hlead[(1,)], where hlead = hamiltonian(glead).\nIf reverse == true, the lead is reversed before being attached, so that h is coupled through V = hlead[(-1,)] to the first unitcell on the negative side of the boundary. If there is no boundary, the cell = 0 unitcell of the glead is used.","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"Generic lead self-energy\nattach(h, glead::GreenFunction, model::AbstractModel; reverse = false, transform = identity, sites...)\nThe same as above, but without any restriction on sites. The coupling between these and the first unit cell of glead (transformed by transform) is constructed using model::TightbindingModel. The \"first unit cell\" is defined as above.","category":"page"},{"location":"tutorial/greenfunctions/#A-more-advanced-example","page":"GreenFunctions","title":"A more advanced example","text":"","category":"section"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"Let us define the classical example of a multiterminal mesoscopic junction. We choose a square lattice, and a circular central region of radius 10, with four leads of width 5 coupled to it at right angles.","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"We first define a single lead Greenfunction and the central Hamiltonian","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"julia> glead = LP.square() |> onsite(4) - hopping(1) |> supercell((1, 0), region = r -> abs(r[2]) <= 5/2) |> greenfunction(GS.Schur(boundary = 0));\n\njulia> hcentral = LP.square() |> onsite(4) - hopping(1) |> supercell(region = RP.circle(10) | RP.rectangle((22, 5)) | RP.rectangle((5, 22)))","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"The two rectangles overlayed on the circle above create the stubs where the leads will be attached:","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"<img src=\"../../assets/central.png\" alt=\"Central region with stubs\" width=\"250\" class=\"center\"/>","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"We now attach glead four times using the Matched lead syntax","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"julia> Rot = r -> SA[0 -1; 1 0] * r;  # 90º rotation function\n\njulia> g = hcentral |>\n    attach(glead, region = r -> r[1] ==  11) |>\n    attach(glead, region = r -> r[1] == -11, reverse = true) |>\n    attach(glead, region = r -> r[2] ==  11, transform = Rot) |>\n    attach(glead, region = r -> r[2] == -11, reverse = true, transform = Rot) |>\n    greenfunction\nGreenFunction{Float64,2,0}: Green function of a Hamiltonian{Float64,2,0}\n  Solver          : AppliedSparseLUGreenSolver\n  Contacts        : 4\n  Contact solvers : (SelfEnergySchurSolver, SelfEnergySchurSolver, SelfEnergySchurSolver, SelfEnergySchurSolver)\n  Contact sizes   : (5, 5, 5, 5)\n  Hamiltonian{Float64,2,0}: Hamiltonian on a 0D Lattice in 2D space\n    Bloch harmonics  : 1\n    Harmonic size    : 353 × 353\n    Orbitals         : [1]\n    Element type     : scalar (ComplexF64)\n    Onsites          : 0\n    Hoppings         : 1320\n    Coordination     : 3.73938\n\njulia> qplot(g, children = (; selector = siteselector(; cells = 1:5), sitecolor = :blue))","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"<img src=\"../../assets/multiterminal.png\" alt=\"Multiterminal system\" width=\"300\" class=\"center\"/>","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"Note that since we did not specify the solver in greenfunction, the L=0 default GS.SparseLU() was taken.","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"tip: The GreenFunction <-> AbstractHamiltonian relation\nIts important un appreciate that a g::GreenFunction represents the retarded Green function between sites in a given AbstractHamiltonian, but not on sites of the coupled AbstractHamiltonians of its attached self-energies. Therefore, gcentral above cannot yield observables in the leads (blue sites above), only on the red sites. To obtain observables in a given lead, its GreenFunction must be constructed, with an attached self-energy coming from the central region plus the other three leads.","category":"page"},{"location":"tutorial/greenfunctions/#Slicing-and-evaluation","page":"GreenFunctions","title":"Slicing and evaluation","text":"","category":"section"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"As explained above, a g::GreenFunction represents a Green function of an OpenHamiltonian (i.e. AbstractHamiltonian with zero or more self-energies), but it does so for any energy ω or lattice sites.     - To specify ω (plus any parameters params in the underlying AbstractHamiltonian) we use the syntax g(ω; params...), which yields an gω::GreenSolution     - To specify source (sⱼ) and drain (sᵢ) sites we use the syntax g[sᵢ, sⱼ] or g[sᵢ] == g[sᵢ,sᵢ], which yields a gs::GreenSlice. sᵢ and sⱼ can be SiteSelectors(; sites...), or an integer denoting a specific contact (i.e. sites with an attached self-energy) or : denoting all contacts merged together.     - If we specify both of the above we get the Green function between the orbitals of the specified sites at the specified energy, in the form of a Matrix","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"Let us see this in action using the example from the previous section","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"julia> g[1, 3]\nGreenSlice{Float64,2,0}: Green function at arbitrary energy, but at a fixed lattice positions\n\njulia> g(0.2)\nGreenSolution{Float64,2,0}: Green function at arbitrary positions, but at a fixed energy\n\njulia> g(0.2)[1, 3]\n5×5 Matrix{ComplexF64}:\n -0.370342-0.0778282im   0.0575525-0.211484im   0.0245456-0.129385im     0.174425-0.155446im       0.100593+0.0134301im\n 0.0575525-0.211484im   -0.0619157+0.0480224im   0.156603+0.256013im    -0.342883+0.0760708im    -0.0414971+0.0510385im\n 0.0245456-0.129385im     0.156603+0.256013im    -0.13008-0.156987im     0.129202-0.139979im       0.155843-0.0597696im\n  0.174425-0.155446im    -0.342883+0.0760708im   0.129202-0.139979im   -0.0515859+0.000612582im   0.0298279+0.109486im\n  0.100593+0.0134301im  -0.0414971+0.0510385im   0.155843-0.0597696im   0.0298279+0.109486im     0.00445114+0.0242172im\n\n  julia> g(0.2)[siteselector(region = RP.circle(1, (0.5, 0))), 3]\n2×5 Matrix{ComplexF64}:\n -0.0051739-0.0122979im  0.258992+0.388052im   0.01413-0.192581im  0.258992+0.388052im   -0.0051739-0.0122979im\n   0.265667+0.296249im   0.171343-0.022414im  0.285251+0.348008im  0.171247+0.0229456im   0.0532086+0.24404im","category":"page"},{"location":"tutorial/greenfunctions/#Diagonal-slices","page":"GreenFunctions","title":"Diagonal slices","text":"","category":"section"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"There is a special form of slicing that requests just the diagonal of a given g[sᵢ] == g[sᵢ,sᵢ]. It uses the syntax g[diagonal(sᵢ)]. Let us see it in action in a multiorbital example in 2D","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"julia> g = HP.graphene(a0 = 1, t0 = 1, orbitals = 2) |> greenfunction\nGreenFunction{Float64,2,2}: Green function of a Hamiltonian{Float64,2,2}\n  Solver          : AppliedBandsGreenSolver\n  Contacts        : 0\n  Contact solvers : ()\n  Contact sizes   : ()\n  Hamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space\n    Bloch harmonics  : 5\n    Harmonic size    : 2 × 2\n    Orbitals         : [2, 2]\n    Element type     : 2 × 2 blocks (ComplexF64)\n    Onsites          : 0\n    Hoppings         : 6\n    Coordination     : 3.0\n\njulia> g(0.5)[diagonal(cells = (0, 0))]\n4-element Vector{ComplexF64}:\n -0.34973634684887517 - 0.3118358260293383im\n  -0.3497363468428337 - 0.3118358260293383im\n   -0.349736346839396 - 0.31183582602933824im\n -0.34973634684543714 - 0.3118358260293383im","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"Note that we get a vector, which is equal to the diagonal diag(g(0.5)[cells = (0, 0)]). Like the g Matrix, this vector is resolved in orbitals, of which there are two per site and four per unit cell in this case. Using diagonal(sᵢ; kernel = K) we can collect all the orbitals of different sites, and compute tr(g[site, site] * K) for a given matrix K. This is useful to obtain spectral densities. In the above example, and interpreting the two orbitals per site as the electron spin, we could obtain the spin density along the x axis, say, using σx = SA[0 1; 1 0] as kernel,","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"julia> g(0.5)[diagonal(cells = (0, 0), kernel = SA[0 1; 1 0])]\n2-element Vector{ComplexF64}:\n -1.1268039540527714e-11 - 2.3843717644870095e-17im\n   1.126802874880133e-11 + 1.9120152589671175e-17im","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"which is zero in this spin-degenerate case","category":"page"},{"location":"tutorial/greenfunctions/#Visualizing-a-Green-function","page":"GreenFunctions","title":"Visualizing a Green function","text":"","category":"section"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"We can use qplot to visualize a GreenSolution in space. Here we define a bounded square lattice with an interesting shape, and attach a model self-energy to the right. Then we compute the Green function from each orbital in the contact to any other site in the lattice, and compute the norm over contact sites. The resulting vector is used as a shader for the color and radius of sites when plotting the system","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"julia> h = LP.square() |> onsite(4) - hopping(1) |> supercell(region = r -> norm(r) < 40*(1+0.2*cos(5*atan(r[2],r[1]))));\n\njulia> g = h |> attach(@onsite(ω -> -im), region = r -> r[1] ≈ 47) |> greenfunction;\n\njulia> gx1 = sum(abs2, g(0.1)[siteselector(), 1], dims = 2);\n\njulia> qplot(h, hide = :hops, sitecolor = (i, r) -> gx1[i], siteradius = (i, r) -> gx1[i], minmaxsiteradius = (0, 2), sitecolormap = :balance)","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"<img src=\"../../assets/star_shape.png\" alt=\"Green function from a contact on the right\" width=\"400\" class=\"center\"/>","category":"page"},{"location":"tutorial/greenfunctions/","page":"GreenFunctions","title":"GreenFunctions","text":"warning: Caveat for multiorbital systems\nSince, currently, g(ω)[sᵢ, sⱼ] yields a Matrix over orbitals (instead of over sites), the above example requires single-orbital sites to work. In the future we will probably introduce a way to slice a GreenSolution over sites, similar to the way diagonal works. For the moment, one can use observables like ldos for visualization (see next section), which are all site-based by default.","category":"page"},{"location":"tutorial/lattices/#Lattices","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"tutorial/lattices/#Constructing-a-Lattice-from-scratch","page":"Lattices","title":"Constructing a Lattice from scratch","text":"","category":"section"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"Consider a lattice like graphene's. It has two sublattices, A and B, forming a 2D honeycomb pattern in space. The position of site A and B inside the unitcell are [0, -a0/(2√3)] and [0, a0/(2√3)], respectively. The Bravais vectors are A₁, A₂ = a0 * [± cos(π/3), sin(π/3)]. If we set the lattice constant to a0 = √3 (so the carbon-carbon distance is 1), one way to build this lattice in Quantica.jl would be","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"julia> A₁, A₂ = √3 .* (cos(π/3), sin(π/3)),\n                √3 .* (-cos(π/3), sin(π/3));\n\njulia> sA, sB = sublat((0, -1/2), name = :A),\n                sublat((0,  1/2), name = :B);\n\njulia> lattice(sA, sB, bravais = (A₁, A₂))\nLattice{Float64,2,2} : 2D lattice in 2D space\n  Bravais vectors : [[0.866025, 1.5], [-0.866025, 1.5]]\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (1, 1) --> 2 total per unit cell","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"tip: Tuple, SVector and SMatrix\nNote that we have used Tuples, such as (0, 1/2) instead of Vectors, like [0, 1/2]. In Julia small-length Tuples are much more efficient as containers than Vectors, since their length is known and fixed at compile time. Static vectors (SVector) and matrices (SMatrix) are also available to Quantica, which are just as efficient as Tuples, and they also implement linear algebra operations. They be entered as e.g. SA[0, 1/2] and SA[1 0; 0 1], respectively. For efficiency, always use Tuple, SVector and SMatrix in Quantica.jl where possible.","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"If we don't plan to address the two sublattices individually, we could also fuse them into one, like","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"julia> lat = lattice(sublat((0, 1/2), (0, -1/2)), bravais = (A₁, A₂))\nLattice{Float64,2,2} : 2D lattice in 2D space\n  Bravais vectors : [[0.866025, 1.5], [-0.866025, 1.5]]\n  Sublattices     : 1\n    Names         : (:A,)\n    Sites         : (2,) --> 2 total per unit cell","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"This lattice has type Lattice{T,E,L}, with T = Float64 the numeric type of position coordinates, E = 2 the dimension of embedding space, and L = 2 the number of Bravais vectors (i.e. the lattice dimension). Both T and E, and even the Sublat names can be overridden when creating a lattice. One can also provide the Bravais vectors as a matrix, with each Aᵢ as a column.","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"julia> Amat = √3 * SA[-cos(π/3) cos(π/3); sin(π/3) sin(π/3)];\n\njulia> lat´ = lattice(sA, sB, bravais = Amat, type = Float32, dim = 3, names = (:C, :D))\nLattice{Float32,3,2} : 2D lattice in 3D space\n  Bravais vectors : Vector{Float32}[[-0.866025, 1.5, 0.0], [0.866025, 1.5, 0.0]]\n  Sublattices     : 2\n    Names         : (:C, :D)\n    Sites         : (1, 1) --> 2 total per unit cell","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"tip: Advanced: `dim = Val(E)` vs. `dim = E`\nFor the dim keyword above we can alternatively use dim = Val(3), which is slightly more efficient, because the value is encoded as a type. This is a \"Julia thing\" (related to the concept of type stability), and can be ignored upon a first contact with Quantica.jl.","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"One can also convert an existing lattice like the above to have a different type, embedding dimension, Bravais vectors and Sublat names with lattice(lat; kw...). For example","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"julia> lat´´ = lattice(lat´, type = Float16, dim = 2, names = (:Boron, :Nitrogen))\nLattice{Float16,2,2} : 2D lattice in 2D space\n  Bravais vectors : Vector{Float16}[[-0.866, 1.5], [0.866, 1.5]]\n  Sublattices     : 2\n    Names         : (:Boron, :Nitrogen)\n    Sites         : (1, 1) --> 2 total per unit cell","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"A list of site positions in a lattice lat can be obtained with sites(lat), or sites(lat, sublat) to restrict to a specific sublattice","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"julia> sites(lat´´)\n2-element Vector{SVector{2, Float16}}:\n [0.0, -0.5]\n [0.0, 0.5]\n\njulia> sites(lat´´, :Nitrogen)\n1-element view(::Vector{SVector{2, Float16}}, 2:2) with eltype SVector{2, Float16}:\n [0.0, 0.5]","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"Similarly, the Bravais matrix of a lat can be obtained with bravais_matrix(lat).","category":"page"},{"location":"tutorial/lattices/#Lattice-presets","page":"Lattices","title":"Lattice presets","text":"","category":"section"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"Quantica.jl provides a range of presets. A preset is a pre-built object of some type. In particular we have Lattice presets, defined in the submodule LatticePresets (also called LP for convenience), that include a number of classical lattices in different dimensions:","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"LP.linear: linear 1D lattice\nLP.square: square 2D lattice\nLP.honeycomb: honeycomb 2D lattice\nLP.cubic: cubic 3D lattice\nLP.bcc: body-centered cubic 3D lattice\nLP.fcc: face-centered cubic 3D lattice","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"To obtain a lattice from a preset one simply calls it, e.g. LP.honecyomb(; kw...). One can modify any of these LatticePresets by passing a bravais, type, dim or names keyword. One can also use a new keyword a0 for the lattice constant (a0 = 1 by default). The lattice lat´´ above can thus be also obtained with","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"julia> lat´´ = LP.honeycomb(a0 = √3, type = Float16, names = (:Boron, :Nitrogen))\nLattice{Float16,2,2} : 2D lattice in 2D space\n  Bravais vectors : Vector{Float16}[[0.866, 1.5], [-0.866, 1.5]]\n  Sublattices     : 2\n    Names         : (:Boron, :Nitrogen)\n    Sites         : (1, 1) --> 2 total per unit cell","category":"page"},{"location":"tutorial/lattices/#Visualization","page":"Lattices","title":"Visualization","text":"","category":"section"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"To produce an interactive visualization of Lattices or other Quantica.jl object you need to load GLMakie.jl, CairoMakie.jl or some other plotting backend from the Makie repository (i.e. do using GLMakie, see also Installation). Then, a number of new plotting functions will become available. The main one is qplot. A Lattice is represented, by default, as the sites in a unitcell plus the Bravais vectors.","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"julia> using GLMakie\n\njulia> lat = LP.honeycomb()\n\njulia> qplot(lat, hide = nothing)","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"<img src=\"../../assets/honeycomb_lat.png\" alt=\"Honeycomb lattice\" width=\"250\" class=\"center\"/>","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"qplot accepts a large number of keywords to customize your plot. In the case of lattice, most of these are passed over to the function plotlattice, specific to Lattices and Hamiltonians. In the case above, hide = nothing means \"don't hide any element of the plot\". See the qplot and plotlattice docstrings for details.","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"tip: GLMakie.jl vs CairoMakie.jl\nGLMakie.jl is optimized for interactive GPU-accelerated, rasterized plots. If you need to export to PDF for publications or display plots inside a Jupyter notebook, use CairoMakie.jl instead, which in general renders non-interactive, but vector-based plots.","category":"page"},{"location":"tutorial/lattices/#siteselectors","page":"Lattices","title":"SiteSelectors","text":"","category":"section"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"A central concept in Quantica.jl is that of a \"selector\". There are two types of selectors, SiteSelectors and HopSelectors. SiteSelectors are a set of directives or rules that define a subset of its sites. SiteSelector rules are defined through three keywords:","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"region: a boolean function of allowed site positions r.\nsublats: allowed sublattices of selected sites\ncells: allowed cell indices of selected sites","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"Similarly, HopSelectors can be used to select a number of site pairs, and will be used later to define hoppings in tight-binding models (see further below).","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"As an example, let us define a SiteSelector that picks all sites belonging to the :B sublattice of a given lattice within a circle of radius 10","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"julia> s = siteselector(region = r -> norm(r) <= 10, sublats = :B)\nSiteSelector: a rule that defines a finite collection of sites in a lattice\n  Region            : Function\n  Sublattices       : B\n  Cells             : any","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"Note that this selector is defined independently of the lattice. To apply it to a lattice lat we do lat[s], which results in a LatticeSlice (i.e. a finite portion, or slice, of lat)","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"julia> lat = LP.honeycomb(); lat[s]\nLatticeSlice{Float64,2,2} : collection of subcells for a 2D lattice in 2D space\n  Cells       : 363\n  Cell range  : ([-11, -11], [11, 11])\n  Total sites : 363","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"The Cell range above are the corners of a bounding box in cell-index space that contains all unit cell indices with at least one selected site.","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"Let's plot it","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"julia> qplot(lat[s], hide = ())","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"<img src=\"../../assets/latslice.png\" alt=\"A LatticeSlice\" width=\"400\" class=\"center\"/>","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"tip: qplot selector\nThe above qplot(lat[s]) can also be written as qplot(lat, selector = s), which will be useful when plotting AbstractHamiltonians.","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"tip: Sites of a LatticeSlice\nCollect the site positions of a LatticeSlice into a vector with collect(sites(ls)). If you do sites(ls) instead, you will get a lazy generator that can be used to iterate efficiently among site positions without allocating them in memory.","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"Apart from region and sublats we can also restrict the unitcells by their cell index. For example, to select all sites in unit cells within the above bounding box we can do","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"julia> s´ = siteselector(cells = CartesianIndices((-11:11, -11:11)))\nSiteSelector: a rule that defines a finite collection of sites in a lattice\n  Region            : any\n  Sublattices       : any\n  Cells             : CartesianIndices((-11:11, -11:11))\n\njulia> lat[s´]\nLatticeSlice{Float64,2,2} : collection of subcells for a 2D lattice in 2D space\n  Cells       : 529\n  Cell range  : ([-11, -11], [11, 11])\n  Total sites : 1058","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"We can often omit constructing the SiteSelector altogether by using the keywords directly","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"julia> ls = lat[cells = n -> 0 <= n[1] <= 2 && abs(n[2]) < 3, sublats = :A]\nLatticeSlice{Float64,2,2} : collection of subcells for a 2D lattice in 2D space\n  Cells       : 15\n  Cell range  : ([0, -2], [2, 2])\n  Total sites : 15","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"Selectors are very expressive and powerful. Do check siteselector and hopselector docstrings for more details.","category":"page"},{"location":"tutorial/lattices/#Transforming-lattices","page":"Lattices","title":"Transforming lattices","text":"","category":"section"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"We can transform lattices using supercell, reverse, transform, translate.","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"As a periodic structure, the choice of the unitcell in an unbounded lattice is, to an extent, arbitrary. Given a lattice lat we can obtain another with a unit cell 3 times larger with supercell(lat, 3)","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"julia> lat = supercell(LP.honeycomb(), 3)\nLattice{Float64,2,2} : 2D lattice in 2D space\n  Bravais vectors : [[1.5, 2.598076], [-1.5, 2.598076]]\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (9, 9) --> 18 total per unit cell","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"More generally, given a lattice lat with Bravais matrix Amat = bravais_matrix(lat), we can obtain a larger one with Bravais matrix Amat´ = Amat * S, where S is a square matrix of integers. In the example above, S = SA[3 0; 0 3]. The columns of S represent the coordinates of the new Bravais vectors in the basis of the old Bravais vectors. A more general example with e.g. S = SA[3 1; -1 2] can be written either in terms of S or of its columns","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"julia> supercell(lat, SA[3 1; -1 2]) == supercell(lat, (3, -1), (1, 2))\ntrue","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"We can also use supercell to reduce the number of Bravais vectors, and hence the lattice dimensionality. To construct a new lattice with a single Bravais vector A₁´ = 3A₁ - A₂, just omit the second one","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"julia> supercell(lat, (3, -1))\nLattice{Float64,2,1} : 1D lattice in 2D space\n  Bravais vectors : [[6.0, 5.196152]]\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (27, 27) --> 54 total per unit cell","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"Its important to note that the lattice will be bounded along directions different from the specified Bravais vectors. With the syntax above, the new unitcell will be minimal. We may however define how many sites to include in the new unitcell by adding a SiteSelector directive to be applied in the non-periodic directions. For example, to create a 10 * a0 wide, honeycomb nanoribbon we can do","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"julia> lat = supercell(LP.honeycomb(), (1,-1), region = r -> -5 <= r[2] <= 5)\nLattice{Float64,2,1} : 1D lattice in 2D space\n  Bravais vectors : [[1.0, 0.0]]\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (12, 12) --> 24 total per unit cell\n\njulia> qplot(lat[cells = -7:7])","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"<img src=\"../../assets/nanoribbon_lat.png\" alt=\"Honeycomb nanoribbon\" width=\"350\" class=\"center\"/>","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"tip: No need to build selectors explicitly\nNote that we we didn't build a siteselector(region = ...) object to pass it to supercell. Instead, as shown above, we passed the corresponding keywords directly to supercell, which then takes care to build the selector internally.","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"To simply reverse the direction of the Bravais vectors of a lattice, while leaving the site positions unchanged, use reverse (or reverse! to do it in-place)","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"julia> reverse(LP.square())\nLattice{Float64,2,2} : 2D lattice in 2D space\n  Bravais vectors : [[-1.0, -0.0], [-0.0, -1.0]]\n  Sublattices     : 1\n    Names         : (:A,)\n    Sites         : (1,) --> 1 total per unit cell","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"To transform a lattice, so that site positions r become f(r) use transform","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"julia> f(r) = SA[0 1; 1 0] * r\nf (generic function with 1 method)\n\njulia> rotated_honeycomb = transform(LP.honeycomb(a0 = √3), f)\nLattice{Float64,2,2} : 2D lattice in 2D space\n  Bravais vectors : [[1.5, 0.866025], [1.5, -0.866025]]\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (1, 1) --> 2 total per unit cell\n\njulia> sites(rotated_honeycomb)\n2-element Vector{SVector{2, Float64}}:\n [-0.5, 0.0]\n [0.5, 0.0]","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"To translate a lattice by a displacement vector δr use translate","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"julia> δr = SA[0, 1];\n\njulia> sites(translate(rotated_honeycomb, δr))\n2-element Vector{SVector{2, Float64}}:\n [-0.5, 1.0]\n [0.5, 1.0]","category":"page"},{"location":"tutorial/lattices/#Currying:-chaining-transformations-with-the-operator","page":"Lattices","title":"Currying: chaining transformations with the |> operator","text":"","category":"section"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"Many functions in Quantica.jl have a \"curried\" version that allows them to be chained together using the pipe operator |>.","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"note: Definition of currying\nThe curried version of a function f(x1, x2...) is f´ = x1 -> f(x2...), so that the curried form of f(x1, x2...) is x2 |> f´(x2...), or f´(x2...)(x1). This gives the first argument x1 a privileged role. Users of object-oriented languages such as Python may find this use of the |> operator somewhat similar to the way the dot operator works there (i.e. x1.f(x2...)).","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"The last example above can then be written as","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"julia> LP.honeycomb(a0 = √3) |> transform(f) |> translate(δr) |> sites\n2-element Vector{SVector{2, Float64}}:\n [-0.5, 1.0]\n [0.5, 1.0]","category":"page"},{"location":"tutorial/lattices/","page":"Lattices","title":"Lattices","text":"This type of curried syntax is natural in Quantica, and will be used extensively in this tutorial.","category":"page"},{"location":"tutorial/glossary/#Glossary","page":"Glossary","title":"Glossary","text":"","category":"section"},{"location":"tutorial/glossary/","page":"Glossary","title":"Glossary","text":"This is a summary of the type of objects you will be studying.","category":"page"},{"location":"tutorial/glossary/","page":"Glossary","title":"Glossary","text":"Sublat: a sublattice, representing a number of identical sites within the unit cell of a bounded or unbounded lattice. Each site has a position in an E-dimensional space (E is called the embedding dimension). All sites in a given Sublat will be able to hold the same number of orbitals, and they can be thought of as identical atoms. Each Sublat in a Lattice can be given a unique name, by default :A, :B, etc.\nLattice: a collection of Sublats plus a collection of L Bravais vectors that define the periodicity of the lattice. A bounded lattice has L=0, and no Bravais vectors. A Lattice with L > 0 can be understood as a periodic (unbounded) collection of unit cells, each containing a set of sites, each of which belongs to a different sublattice.\nSiteSelector: a rule that defines a subset of sites in a Lattice (not necessarily restricted to a single unit cell)\nHopSelector: a rule that defines a subset of site pairs in a Lattice (not necessarily restricted to the same unit cell)\nLatticeSlice: a finite subset of sites in a Lattice, defined by their cell index (an L-dimensional integer vector, usually denoted by n or cell) and their site index within the unit cell (an integer). A LatticeSlice an be constructed by combining a Lattice and a (bounded) SiteSelector.\nAbstractModel: either a TightBindingModel or a ParametricModel\nTightBindingModel: a set of HoppingTerms and OnsiteTerms\nOnsiteTerm: a rule that, applied to a single site, produces a scalar or a (square) matrix that represents the intra-site Hamiltonian elements (single or multi-orbital)\nHoppingTerm: a rule that, applied to a pair of sites, produces a scalar or a matrix that represents the inter-site Hamiltonian elements (single or multi-orbital)\nParametricModel: a set of ParametricOnsiteTerms and ParametricHoppingTerms\nParametricOnsiteTerm: an OnsiteTerm that depends on a set of free parameters that can be adjusted, and that may or may not have a default value\nParametricHoppingTerm: a HoppingTerm that depends on parameters, like ParametricOnsiteTerm above\nAbstractHamiltonian: either a Hamiltonian or a ParametricHamiltonian\nHamiltonian: a Lattice combined with a TightBindingModel.\nIt also includes a specification of the number of orbitals in each Sublat in the Lattice. A Hamiltonian represents a tight-binding Hamiltonian sharing the same periodicity as the Lattice (it is translationally invariant under Bravais vector shifts).\nParametricHamiltonian: like the above, but using a ParametricModel, which makes it dependent on a set of free parameters that can be efficiently adjusted.\nAn h::AbstractHamiltonian can be used to produce a Bloch matrix h(ϕ; params...) of the same size as the number of orbitals per unit cell, where ϕ = [ϕᵢ...] are Bloch phases and params are values for the free parameters, if any.\nSpectrum: the set of eigenpairs (eigenvalues and corresponding eigenvectors) of a Bloch matrix. It can be computed with a number of EigenSolvers.\nBandstructure: a collection of spectra, evaluated over a discrete mesh (typically a discretization of the Brillouin zone), that is connected to its mesh neighbors into a linearly-interpolated approximation of the AbstractHamiltonian's bandstructure.\nSelfEnergy: an operator Σ(ω) defined to act on a LatticeSlice of an AbstractHamiltonian that depends on energy ω.\nOpenHamiltonian: an AbstractHamiltonian combined with a set of SelfEnergies\nGreenFunction: an OpenHamiltonian combined with a GreenSolver, which is an algorithm that can in general compute the retarded or advanced Green function at any energy between any subset of sites of the underlying lattice.\nGreenSlice: a GreenFunction evaluated on a specific set of sites, but at an unspecified energy\nGreenSolution: a GreenFunction evaluated at a specific energy, but on an unspecified set of sites\nObservable: a physical observable that can be expressed in terms of a GreenFunction.\nExamples of supported observables include local density of states, current density, transmission probability, conductance and Josephson current","category":"page"},{"location":"tutorial/hamiltonians/#Hamiltonians","page":"Hamiltonians","title":"Hamiltonians","text":"","category":"section"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"We build a Hamiltonian by combining a Lattice and a TightbindingModel, optionally specifying also the number of orbitals on each sublattice if there is more than one. A spinful graphene model (two orbitals per site in both sublattices) with nearest neighbor hopping t0 = 2.7 would be written as","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"julia> lat = LP.honeycomb(); model = hopping(2.7*I);\n\njulia> h = hamiltonian(lat, model; orbitals = 2)\nHamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5\n  Harmonic size    : 2 × 2\n  Orbitals         : [2, 2]\n  Element type     : 2 × 2 blocks (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 3.0","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"A crucial thing to remember when defining multi-orbital Hamiltonians as the above is that onsite and hopping amplitudes need to be matrices of the correct size. The symbol I in Julia represents the identity matrix of any size, which is convenient to define a spin-preserving hopping in the case above. An alternative would be to use model = hopping(2.7*SA[1 0; 0 1]).","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"tip: Models with different number of orbitals per sublattice\nNon-homogeneous multiorbital models are more advanced but are fully supported in Quantica.jl. Just use orbitals = (n₁, n₂,...) to have nᵢ orbitals in sublattice i, and make sure your model is consistent with that. As in the case of the dim keyword in lattice, you can also use Val(nᵢ) for marginally faster construction.","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Similarly to LatticePresets, we also have HamiltonianPresets, also aliased as HP. Currently, we have only HP.graphene(...) and HP.twisted_bilayer_graphene(...), but we expect to extend this library in the future (see the docstring of HP).","category":"page"},{"location":"tutorial/hamiltonians/#A-more-elaborate-example:-the-Kane-Mele-model","page":"Hamiltonians","title":"A more elaborate example: the Kane-Mele model","text":"","category":"section"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"The Kane-Mele model for graphene describes intrinsic spin-orbit coupling (SOC), in the form of an imaginary second-nearest-neighbor hopping between same-sublattice sites, with a sign that alternates depending on hop direction dr. A possible implementation in Quantica.jl would be","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"SOC(dr) = 0.05 * ifelse(iseven(round(Int, atan(dr[2], dr[1])/(pi/3))), im, -im)\n\nmodel =\n  hopping(1, range = neighbors(1)) +\n  hopping((r, dr) ->  SOC(dr); sublats = :A => :A, range = neighbors(2)) +\n  hopping((r, dr) -> -SOC(dr); sublats = :B => :B, range = neighbors(2))\n\nh = LatticePresets.honeycomb() |> model\n\nqplot(h, inspector = true)","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"<img src=\"../../assets/latticeKM.png\" alt=\"Kane-Mele lattice\" width=\"350\" class=\"center\"/>","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"The inspector = true keyword enables interactive tooltips in the visualization of h that allows to navigate each onsite and hopping amplitude graphically. Note that sites connected to the unit cell of h by some hopping are included, but are rendered with partial transparency by default.","category":"page"},{"location":"tutorial/hamiltonians/#ParametricHamiltonians","page":"Hamiltonians","title":"ParametricHamiltonians","text":"","category":"section"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"If we use a ParametricModel instead of a simple TightBindingModel we will obtain a ParametricHamiltonian instead of a simple Hamiltonian, both of which are subtypes of the AbstractHamiltonian type","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"julia> model_param = @hopping((; t = 2.7) -> t*I);\n\njulia> h_param = hamiltonian(lat, model_param; orbitals = 2)\nParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5\n  Harmonic size    : 2 × 2\n  Orbitals         : [2, 2]\n  Element type     : 2 × 2 blocks (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 3.0\n  Parameters       : [:t]","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"We can also apply Modifiers by passing them as extra arguments to hamiltonian, which results again in a ParametricHamiltonian with the parametric modifiers applied","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"julia> peierls! = @hopping!((t, r, dr; Bz = 0) -> t * cis(-Bz/2 * SA[-r[2], r[1]]' * dr));\n\njulia> h_param_mod = hamiltonian(lat, model_param, peierls!; orbitals = 2)\nParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5\n  Harmonic size    : 2 × 2\n  Orbitals         : [2, 2]\n  Element type     : 2 × 2 blocks (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 3.0\n  Parameters       : [:Bz, :t]","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Note that SA[-r[2], r[1]] above is a 2D SVector, because since the embedding dimension is E = 2, both r and dr are also 2D SVectors.","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"We can also apply modifiers to an already constructed AbstractHamiltonian. The following is equivalent to the above","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"julia> h_param_mod = hamiltonian(h_param, peierls!);","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"warning: Modifiers do not commute\nWe can add as many modifiers as we need by passing them as extra arguments to hamiltonian, and they will be applied sequentially, one by one. Beware, however, that modifiers do not necessarily commute, in the sense that the result will in general depend on their order.","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"We can obtain a plain Hamiltonian from a ParametricHamiltonian by applying specific values to its parameters. To do so, simply use the call syntax with parameters as keyword arguments","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"julia> h_param_mod(Bz = 0.1, t = 1)\nHamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5\n  Harmonic size    : 2 × 2\n  Orbitals         : [2, 2]\n  Element type     : 2 × 2 blocks (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 3.0","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"tip: Syntax `lat |> model` and `h |> modifier\nThe common cases lat |> hamiltonian(model) (or hamiltonian(lat, model)) and h |> hamiltonian(modifier) (or hamiltonian(h, modifier)) can be also written as lat |> model and h |> modifier, respectively. Hence hamiltonian(lat, model, modifier) may be written as lat |> model |> modifier. This form however does not allow to specify the number of orbitals per sublattice (it will be one, the default).","category":"page"},{"location":"tutorial/hamiltonians/#Obtaining-actual-matrices","page":"Hamiltonians","title":"Obtaining actual matrices","text":"","category":"section"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"For an L-dimensional h::AbstractHamiltonian (i.e. defined on a Lattice with L Bravais vectors), the Hamiltonian matrix between any unit cell with cell index n and another unit cell at n+dn (here known as a Hamiltonian \"harmonic\") is given by h[dn]","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"julia> h[(1,0)]\n4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:\n     ⋅          ⋅      2.7+0.0im  0.0+0.0im\n     ⋅          ⋅      0.0+0.0im  2.7+0.0im\n     ⋅          ⋅          ⋅          ⋅\n     ⋅          ⋅          ⋅          ⋅\n\njulia> h[(0,0)]\n4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:\n     ⋅          ⋅      2.7+0.0im  0.0+0.0im\n     ⋅          ⋅      0.0+0.0im  2.7+0.0im\n 2.7+0.0im  0.0+0.0im      ⋅          ⋅\n 0.0+0.0im  2.7+0.0im      ⋅          ⋅","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"tip: Cell distance indices\nWe can use Tuples or SVectors for cell distance indices dn. An empty Tuple dn = () will always return the main intra-unitcell harmonic: h[()] = h[(0,0...)] = h[SA[0,0...]].","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"note: Bounded Hamiltonians\nIf the Hamiltonian has a bounded lattice (i.e. it has L=0 Bravais vectors), we will simply use an empty tuple to obtain its matrix h[()]. This is not in conflict with the above syntax.","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Note that if h is a ParametricHamiltonian, such as h_param above, we will get zeros in place of the unspecified parametric terms, unless we actually first specify the values of the parameters","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"julia> h_param[(0,0)] # Parameter t is not specified -> it is not applied\n4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:\n     ⋅          ⋅      0.0+0.0im  0.0+0.0im\n     ⋅          ⋅      0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im      ⋅          ⋅\n 0.0+0.0im  0.0+0.0im      ⋅          ⋅\n\njulia> h_param(t=2)[(0,0)]\n4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:\n     ⋅          ⋅      2.0+0.0im  0.0+0.0im\n     ⋅          ⋅      0.0+0.0im  2.0+0.0im\n 2.0+0.0im  0.0+0.0im      ⋅          ⋅\n 0.0+0.0im  2.0+0.0im      ⋅          ⋅","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"note: ParametricHamiltonian harmonics\nThe above behavior for unspecified parameters is not set in stone and may change in future versions. Another option would be to apply their default values (which may, however, not exist).","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"We are usually not interested in the harmonics h[dn] themselves, but rather in the Bloch matrix of a Hamiltonian","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"H(phi) = sum_dn H_dn exp(-i phi * dn)","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"where H_dn are the Hamiltonian harmonics, phi = (phi_1 phi_2) = (kcdot A_1 kcdot A_2) are the Bloch phases, k is the Bloch wavevector and A_i are the Bravais vectors.","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"We obtain the Bloch matrix using the syntax h(ϕ; params...)","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"julia> h((0,0))\n4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:\n     ⋅          ⋅      8.1+0.0im  0.0+0.0im\n     ⋅          ⋅      0.0+0.0im  8.1+0.0im\n 8.1+0.0im  0.0+0.0im      ⋅          ⋅\n 0.0+0.0im  8.1+0.0im      ⋅          ⋅\n\njulia> h_param_mod((0.2, 0.3); B = 0.1)\n4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:\n         ⋅                  ⋅          7.92559-1.33431im      0.0+0.0im\n         ⋅                  ⋅              0.0+0.0im      7.92559-1.33431im\n 7.92559+1.33431im      0.0+0.0im              ⋅                  ⋅\n     0.0+0.0im      7.92559+1.33431im          ⋅                  ⋅","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Note that unspecified parameters take their default values when using the call syntax (as per the standard Julia convention). Any unspecified parameter that does not have a default value will produce an UndefKeywordError error.","category":"page"},{"location":"tutorial/hamiltonians/#Transforming-Hamiltonians","page":"Hamiltonians","title":"Transforming Hamiltonians","text":"","category":"section"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Like with lattices, we can transform an h::AbstractHamiltonians using supercell, reverse, transform and translate. All these except supercell operate only on the underlying lattice(h) of h, leaving the hoppings and onsite elements unchanged. Meanwhile, supercell acts on lattice(h) but also copies the hoppings and onsites of h onto the new sites, preserving the periodicity of the original h.","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Additionally, we can also use wrap, which makes h periodic along a number of its Bravais vectors, while leaving the rest unbounded.","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"julia> wrap(HP.graphene(), (0, :))\nHamiltonian{Float64,2,1}: Hamiltonian on a 1D Lattice in 2D space\n  Bloch harmonics  : 3\n  Harmonic size    : 2 × 2\n  Orbitals         : [1, 1]\n  Element type     : scalar (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 4\n  Coordination     : 2.0","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"The phases argument of wrap(h, phases) is a Tuple of real numbers and/or colons (:), of length equal to the lattice dimension of h. Each real number ϕᵢ corresponds to a Bravais vector along which the transformed lattice will become periodic, picking up a phase exp(iϕᵢ) in the wrapping hoppings, while each colon leaves the lattice unbounded along the corresponding Bravais vector. In a way wrap is dual to supercell, in the sense that the it applies a different boundary condition to the lattice along the eliminated Bravais vectors, periodic instead of open, as in the case of supercell. The phases ϕᵢ are also connected to Bloch phases, in the sense that e.g. wrap(h, (ϕ₁, :))(ϕ₂) == h(ϕ₁, ϕ₂)","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"warning: Caveat of the Bloch-wrap duality\nThe relation wrap(h, phases)(()) = h(phases) is quite general. However, in some cases with position-dependent models, this may not hold. This may happen when some of the rapping hoppings added by wrap are  already present in h, as in the case with hoppings at ranges equal or larger than half the size of the unit cell.","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"It's important to understand that, when transforming an h::AbstractHamiltonian, the model used to build h is not re-evaluated. Hoppings and onsite energies are merely copied so as to preserve the periodicity of the original h. As a consequence, these two constructions give different Hamiltonians","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"julia> h1 = LP.linear() |> supercell(4) |> hamiltonian(onsite(r -> r[1]));\n\njulia> h2 = LP.linear() |> hamiltonian(onsite(r -> r[1])) |> supercell(4);","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"In the case of h1 the onsite model is applied to the 4-site unitcell. Since each site has a different position, each gets a different onsite energy.","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"julia> h1[()]\n4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:\n 0.0+0.0im      ⋅          ⋅          ⋅\n     ⋅      1.0+0.0im      ⋅          ⋅\n     ⋅          ⋅      2.0+0.0im      ⋅\n     ⋅          ⋅          ⋅      3.0+0.0im","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"In contrast h2 first gets the onsite model applied with a 1-site unitcell at position r = SA[0], so all sites in the lattice get onsite energy zero. Only then it is expanded with supercell, which generates a 4-site unitcell with zero onsite energy on all its sites","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"julia> h2[()]\n4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:\n 0.0+0.0im      ⋅          ⋅          ⋅\n     ⋅      0.0+0.0im      ⋅          ⋅\n     ⋅          ⋅      0.0+0.0im      ⋅\n     ⋅          ⋅          ⋅      0.0+0.0im","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"As a consequence, h and supercell(h) represent exactly the same system, with the same observables, but with a different choice of unitcell.","category":"page"},{"location":"tutorial/hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"These two different behaviors make sense in different situations, so it is important to be aware of the order dependence of transformations. Similar considerations apply to transform, translate and wrap when models are position dependent.","category":"page"},{"location":"tutorial/tutorial/#Tutorial","page":"Welcome","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Welcome","title":"Welcome","text":"Welcome to the Quantica.jl tutorial!","category":"page"},{"location":"tutorial/tutorial/","page":"Welcome","title":"Welcome","text":"Here you will learn how to use Quantica.jl to build and compute properties of tight-binding models. This includes","category":"page"},{"location":"tutorial/tutorial/","page":"Welcome","title":"Welcome","text":"Defining general Lattices in arbitrary dimensions\nDefining generic tight-binding Models with arbitrary parameter dependences\nBuilding Hamiltonians of mono- or multiorbital systems by combining Lattices and Models\nComputing Bandstructures of Hamiltonians\nComputing GreenFunctions of Hamiltonians or OpenHamiltonians (i.e. Hamiltonians with attached self-energies from other Hamiltonians, such as leads).\nComputing Observables from Green functions, such as spectral densities, current densities, local and nonlocal conductances, Josephson currents, critical currents, transmission probabilities, etc.","category":"page"},{"location":"tutorial/tutorial/","page":"Welcome","title":"Welcome","text":"Check the menu on the left for shortcuts to the relevant sections.","category":"page"},{"location":"tutorial/tutorial/","page":"Welcome","title":"Welcome","text":"tip: Check the docstrings\nFull usage instructions on all Quantica.jl functions can be found here or within the Julia REPL by querying their docstrings. For example, to obtain details on the hamiltonian function or on the available LatticePresets, just type ?hamiltonian or ?LatticePresets.","category":"page"},{"location":"api/#api","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = Quantica","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Quantica]","category":"page"},{"location":"api/#Quantica.EigenSolvers","page":"API","title":"Quantica.EigenSolvers","text":"EigenSolvers is a Quantica submodule containing several pre-defined eigensolvers. The alias ES can be used in place of EigenSolvers. Currently supported solvers are\n\nES.LinearAlgebra(; kw...)       # Uses `eigen(mat; kw...)` from the `LinearAlgebra` package\nES.Arpack(; kw...)              # Uses `eigs(mat; kw...)` from the `Arpack` package\nES.KrylovKit(params...; kw...)  # Uses `eigsolve(mat, params...; kw...)` from the `KrylovKit` package\nES.ArnoldiMethod(; kw...)       # Uses `partialschur(mat; kw...)` from the `ArnoldiMethod` package\n\nAdditionally, to compute interior eigenvalues, we can use a shift-invert method around energy ϵ0 (uses LinearMaps and a LinearSolve.lu factorization), combined with any solver s from the list above:\n\nES.ShiftInvert(s, ϵ0)           # Perform a lu-based shift-invert with solver `s`\n\nIf the required packages are not already available, they will be automatically loaded when calling these solvers.\n\nExamples\n\njulia> h = HP.graphene(t0 = 1) |> supercell(10);\n\njulia> spectrum(h, (0,0), ES.ShiftInvert(ES.ArnoldiMethod(nev = 4), 0.0)) |> energies\n4-element Vector{ComplexF64}:\n -0.38196601125010465 + 3.686368662666227e-16im\n  -0.6180339887498938 + 6.015655020129746e-17im\n   0.6180339887498927 + 2.6478518218421853e-16im\n  0.38196601125010476 - 1.741261108320361e-16im\n\nSee also\n\n`spectrum`, `bands`\n\n\n\n\n\n","category":"module"},{"location":"api/#Quantica.GreenSolvers","page":"API","title":"Quantica.GreenSolvers","text":"GreenSolvers is a Quantica submodule containing several pre-defined Green function solvers. The alias GS can be used in place of GS. Currently supported solvers and their possible keyword arguments are\n\nGS.SparseLU() : Direct inversion solver for 0D Hamiltonians using a SparseArrays.lu(hmat) factorization\nGS.Schur(; boundary = Inf) : Solver for 1D Hamiltonians based on a deflated, generalized Schur factorization\nboundary : 1D cell index of a boundary cell, or Inf for no boundaries. Equivalent to removing that specific cell from the lattice when computing the Green function.\nGS.KPM(; order = 100, bandrange = missing, kernel = I) : Kernel polynomial method solver for 0D Hamiltonians\norder : order of the expansion in Chebyshev polynomials Tₙ(h) of the Hamiltonian h (lowest possible order is n = 0).\nbandrange : a (min_energy, max_energy)::Tuple interval that encompasses the full band of the Hamiltonian. If missing, it is computed automatically.\nkernel : generalization that computes momenta as μₙ = Tr[Tₙ(h)*kernel], so that the local density of states (see ldos) becomes the density of the kernel operator.\nThis solver does not allow arbitrary indexing of the resulting g::GreenFunction, only on contacts g[contact_ind::Integer]. If the system has none, we can add a dummy contact using attach(h, nothing; sites...), see attach.\nGS.Bands(bands_arguments; boundary = missing, bands_kw...): solver based on the integration of bandstructure simplices\nbands_arguments: positional arguments passed on to bands\nbands_kw: keyword arguments passed on to bands\nboundary: either missing (no boundary), or dir => cell_pos, where dir::Integer is the Bravais vector normal to the boundary, and cell_pos::Integer the value of cell indices cells[dir] that define the boundary (i.e. cells[dir] <= cell_pos are vaccum)\nThis solver only allows zero or one boundary. WARNING: if a boundary is used, the algorithm may become unstable for very fine band meshes.\n\n\n\n\n\n","category":"module"},{"location":"api/#Quantica.HamiltonianPresets","page":"API","title":"Quantica.HamiltonianPresets","text":"HamiltonianPresets is a Quantica submodule containing several pre-defined Hamiltonians. The alias HP can be used in place of LatticePresets. Currently supported hamiltonians are\n\nHP.graphene(; kw...)\nHP.twisted_bilayer_graphene(; kw...)\n\nFor details on the keyword arguments kw see the corresponding docstring\n\njulia> HamiltonianPresets.twisted_bilayer_graphene(twistindices = (30, 1))\nHamiltonian{Float64,3,2}: Hamiltonian on a 2D Lattice in 3D space\n  Bloch harmonics  : 7\n  Harmonic size    : 11164 × 11164\n  Orbitals         : [1, 1, 1, 1]\n  Element type     : scalar (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 315684\n  Coordination     : 28.27696\n\nSee also\n\n`LatticePresets`, `RegionPresets`\n\n\n\n\n\n","category":"module"},{"location":"api/#Quantica.LatticePresets","page":"API","title":"Quantica.LatticePresets","text":"LatticePresets is a Quantica submodule containing several pre-defined lattices. The alias LP can be used in place of LatticePresets. Currently supported lattices are\n\nLP.linear(; a0 = 1, kw...)      # linear lattice in 1D\nLP.square(; a0 = 1, kw...)      # square lattice in 2D\nLP.triangular(; a0 = 1, kw...)  # triangular lattice in 2D\nLP.honeycomb(; a0 = 1, kw...)   # honeycomb lattice in 2D\nLP.cubic(; a0 = 1, kw...)       # cubic lattice in 3D\nLP.fcc(; a0 = 1, kw...)         # face-centered-cubic lattice in 3D\nLP.bcc(; a0 = 1, kw...)         # body-centered-cubic lattice in 3D\nLP.hcp(; a0 = 1, kw...)         # hexagonal-closed-packed lattice in 3D\n\nIn all cases a0 denotes the lattice constant, and kw... are extra keywords forwarded to lattice.\n\nExamples\n\njulia> LatticePresets.honeycomb(names = (:C, :D))\nLattice{Float64,2,2} : 2D lattice in 2D space\n  Bravais vectors : [[0.5, 0.866025], [-0.5, 0.866025]]\n  Sublattices     : 2\n    Names         : (:C, :D)\n    Sites         : (1, 1) --> 2 total per unit cell\n\njulia> LatticePresets.cubic(bravais = ((1, 0), (0, 2)))\nLattice{Float64,3,2} : 2D lattice in 3D space\n  Bravais vectors : [[1.0, 0.0, 0.0], [0.0, 2.0, 0.0]]\n  Sublattices     : 1\n    Names         : (:A,)\n    Sites         : (1,) --> 1 total per unit cell\n\nSee also\n\n`RegionPresets`, `HamiltonianPresets`\n\n\n\n\n\n","category":"module"},{"location":"api/#Quantica.RegionPresets","page":"API","title":"Quantica.RegionPresets","text":"RegionPresets is a Quantica submodule containing several pre-defined regions of type Region{E}, where E is the space dimension. The alias RP can be used in place of RegionPresets. Supported regions are\n\nRP.circle(radius = 10, center = (0, 0))                         # 2D\nRP.ellipse((rx, ry) = (10, 15), center = (0, 0))                # 2D\nRP.square(side = 10, center = (0, 0))                           # 2D\nRP.rectangle((sx, sy) = (10, 15), center = (0, 0))              # 2D\nRP.sphere(radius = 10, center = (0, 0, 0))                      # 3D\nRP.spheroid((rx, ry, rz) = (10, 15, 20), center = (0, 0, 0))    # 3D\nRP.cube(side = 10, center = (0, 0, 0))                          # 3D\nRP.cuboid((sx, sy, sz) = (10, 15, 20), center = (0, 0, 0))      # 3D\n\nCalling a f::Region{E} object on a r::Tuple or r::SVector with f(r) or f(r...) returns true or false if r is inside the region or not. Note that only the first E coordinates of r will be checked. Arbitrary boolean functions can also be wrapped in Region{E} to create custom regions, e.g. f = Region{2}(r -> r[1]^2 < r[2]).\n\nBoolean combinations of Regions are supported using &, |, xor and ! operators, such as annulus = RP.circle(10) & !RP.circle(5).\n\nExamples\n\njulia> RegionPresets.circle(10)(20, 0, 0)\nfalse\n\njulia> RegionPresets.circle(10)(0, 0, 20)\ntrue\n\nSee also\n\n`LatticePresets`, `HamiltonianPresets`\n\n\n\n\n\n","category":"module"},{"location":"api/#Quantica.BoxIterator","page":"API","title":"Quantica.BoxIterator","text":"BoxIterator(seed::SVector{N,Int}; maxiterations = TOOMANYITERS)\n\nCartesian iterator iter over SVector{N,Int}s (cells) that starts at seed and grows outwards in the form of a box of increasing sides (not necesarily equal) until it encompasses a certain N-dimensional region. To signal that a cell is in the desired region the user calls acceptcell!(iter, cell).\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.reverse","page":"API","title":"Base.reverse","text":"reverse(lat_or_h::Union{Lattice,AbstractHamiltonian})\n\nBuild a new lattice or hamiltonian with the orientation of all Bravais vectors reversed.\n\nSee also\n\n`reverse!`, `transform`\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.reverse!","page":"API","title":"Base.reverse!","text":"reverse!(lat_or_h::Union{Lattice,AbstractHamiltonian})\n\nIn-place version of reverse, inverts all Bravais vectors of lat_or_h.\n\nSee also\n\n`reverse`, `transform`\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.ishermitian","page":"API","title":"LinearAlgebra.ishermitian","text":"ishermitian(h::Hamiltonian)\n\nCheck whether h is Hermitian. This is not supported for h::ParametricHamiltonian, as the result can depend of the specific values of its parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.attach","page":"API","title":"Quantica.attach","text":"attach(h::AbstractHamiltonian, args..; sites...)\nattach(h::OpenHamiltonian, args...; sites...)\n\nBuild an h´::OpenHamiltonian by attaching (adding) a Σ::SelfEnergy to a finite number of sites in h specified by siteselector(; sites...). This also defines a \"contact\" on said sites that can be referred to (with index i::Integer for the i-th attached contact) when slicing Green functions later. Self-energies are taken into account when building the Green function g(ω) = (ω - h´ - Σ(ω))⁻¹ of the resulting h´, see greenfunction.\n\nSelf-energy forms\n\nThe different forms of args yield different types of self-energies Σ. Currently supported forms are:\n\nattach(h, gs::GreenSlice, coupling::AbstractModel; sites...)\n\nAdds a generic self-energy Σ(ω) = V´⋅gs(ω)⋅V on h's sites, where V and V´ are couplings, given by coupling, between said sites and the LatticeSlice in gs. Allowed forms of gs include both g[bath_sites...] and g[contactind::Integer] where g is any GreenFunction.\n\nattach(h, model::ParametricModel; sites...)\n\nAdd self-energy Σᵢⱼ(ω) defined by a model composed of parametric terms (@onsite and @hopping) with ω as first argument, as in e.g. @onsite((ω, r) -> Σᵢᵢ(ω, r)) and @hopping((ω, r, dr) -> Σᵢⱼ(ω, r, dr))\n\nattach(h, nothing; sites...)\n\nAdd null self-energy Σᵢⱼ(ω) = 0 on selected sites, which in effect simply amounts to defining a contact on said sites, but does not lead to any dressing the Green function. This is useful for some GreenFunction solvers such as GS.KPM (see greenfunction), which need to know the sites of interest beforehand (the contact sites in this case).\n\nattach(h, g1D::GreenFunction; reverse = false, transform = identity, sites...)\n\nAdd a self-energy Σ(ω) = h₋₁⋅g1D(ω)[surface]⋅h₁ corresponding to a semi-infinite 1D lead (i.e. with a finite boundary, see greenfunction), where h₁ and h₋₁ are intercell couplings, and g1D is the lead GreenFunction. The g1D(ω) is taken at the suface unitcell, either adjacent to the boundary on its positive side (if reverse = false) or on its negative side (if reverse = true). The positions of the selected sites in h must match, modulo an arbitrary displacement, those of the lead unit cell, after applying transform to the latter. If they don't, use the attach syntax below.\n\nAdvanced: If the g1D does not have any self-energies, the produced self-energy is in fact an ExtendedSelfEnergy, which is numerically more stable than a naive implementation of RegularSelfEnergy's, since g1D(ω)[surface] is never actually computed. Conversely, if g1D has self-energies attached, a RegularSelfEnergy is produced.\n\nattach(h, g1D::GreenFunction, coupling::AbstractModel; reverse = false, transform = identity,  sites...)\n\nAdd a self-energy Σ(ω) = V´⋅g1D(ω)[surface]⋅V corresponding to a 1D lead (semi-infinite or infinite), but with couplings V and V´, defined by coupling, between sites and the surface lead unitcell (or the one with index zero if there is no boundary) . See also Advanced note above.\n\nCurrying\n\nh |> attach(args...; sites...)\n\nCurried form equivalent to attach(h, args...; sites...).\n\nExamples\n\njulia> # A graphene flake with two out-of-plane cubic-lattice leads\n\njulia> g1D = LP.cubic() |> hamiltonian(hopping(1)) |> supercell((0,0,1), region = RP.square(4)) |> greenfunction(GS.Schur(boundary = 0));\n\njulia> coupling = hopping(1, range = 2);\n\njulia> gdisk = HP.graphene(a0 = 1, dim = 3) |> supercell(region = RP.circle(10)) |> attach(g1D, coupling; region = RP.square(4)) |> attach(g1D, coupling; region = RP.square(4), reverse = true) |> greenfunction;\n\n\nSee also\n\n`greenfunction`, `GreenSolvers`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.bands","page":"API","title":"Quantica.bands","text":"bands(h::AbstractHamiltonian, xcolᵢ...; kw...)\n\nConstruct a Bandstructure object, which contains in particular a collection of continuously connected Subbands of h, obtained by diagonalizing the matrix h(ϕs; params...) on an M-dimensional mesh of points (x₁, x₂, ..., xₘ), where each xᵢ takes values in the collection xcolᵢ. The mapping between points in the mesh points and values of (ϕs; params...) is defined by keyword mapping (identity by default, see Keywords). Diagonalization is multithreaded and will use all available Julia threads (start session with julia -t N to have N threads).\n\nbands(f::Function, xcolᵢ...; kw...)\n\nLike the above using f(ϕs)::AbstractMatrix in place of h(ϕs; params...), and returning a Vector{<:Subband} instead of a Bandstructure object. This is provided as a lower level driver without the added slicing functionality of a full Bandstructure object, see below.\n\nbands(h::AbstractHamiltonian; kw...)\n\nEquivalent to bands(h::AbstractHamiltonian, xcolᵢ...; kw...) with a default xcolᵢ = subdiv(-π, π, 49).\n\nKeywords\n\nsolver: eigensolver to use for each diagonalization (see Eigensolvers). Default: ES.LinearAlgebra()\nmapping: a function of the form (x, y, ...) -> ϕs or (x, y, ...) -> ftuple(ϕs...; params...) that translates points (x, y, ...) in the mesh to Bloch phases ϕs or phase+parameter FrankenTuples ftuple(ϕs...; params...). See also linecuts below. Default: identity\ntransform: function to apply to each eigenvalue after diagonalization. Default: identity\ndegtol::Real: maximum distance between to nearby eigenvalue so that they are classified as degenerate. Default: sqrt(eps)\nsplit::Bool: whether to split bands into disconnected subbands. Default: true\nprojectors::Bool: whether to compute interpolating subspaces in each simplex (for use as GreenSolver). Default: true\nwarn::Bool: whether to emit warning when band dislocations are encountered. Default: true\nshowprogress::Bool: whether to show or not a progress bar. Default: true\ndefects: (experimental) a collection of extra points to add to the mesh, typically the location of topological band defects such as Dirac points, so that interpolation avoids creating dislocation defects in the bands. You need to also increase patches to repair the subband dislocations using the added defect vertices. Default: ()\npatches::Integer: (experimental) if a dislocation is encountered, attempt to patch it by searching for the defect recursively to a given order, or using the provided defects (preferred). Default: 0\n\nCurrying\n\nh |> bands(xcolᵢ...; kw...)\n\nCurried form of bands equivalent to bands(h, xcolᵢ...; kw...)\n\nBand linecuts\n\nTo do a linecut of a bandstructure along a polygonal path in the L-dimensional Brillouin zone, mapping a set of 1D points xs to a set of nodes, with pts interpolation points in each segment, one can use the following convenient syntax\n\nbands(h, subdiv(xs, pts); mapping = (xs => nodes))\n\nHere nodes can be a collection of SVector{L} or of named Brillouin zone points from the list (:Γ,:K, :K´, :M, :X, :Y, :Z). If mapping = nodes, then xs defaults to 0:length(nodes)-1. See also subdiv for its alternative methods.\n\nIndexing and slicing\n\nb[i]\n\nExtract i-th subband from b::Bandstructure. i can also be a Vector, an AbstractRange or any other argument accepted by getindex(subbands::Vector, i)\n\nb[slice::Tuple]\n\nCompute a section of b::Bandstructure with a \"plane\" defined by slice = (ϕ₁, ϕ₂,..., ϕₗ[, ϵ]), where each ϕᵢ or ϵ can be a real number (representing a fixed momentum or energy) or a : (unconstrained along that dimension). For bands of an L-dimensional lattice, slice will be padded to an L+1-long tuple with : if necessary. The result is a collection of of sliced Subbands.\n\nExamples\n\njulia> phis = range(0, 2pi, length = 50); h = LP.honeycomb() |> hamiltonian(@hopping((; t = 1) -> t));\n\njulia> bands(h(t = 1), phis, phis)\nBandstructure{Float64,3,2}: 3D Bandstructure over a 2-dimensional parameter space of type Float64\n  Subbands  : 1\n  Vertices  : 5000\n  Edges     : 14602\n  Simplices : 9588\n\njulia> bands(h, phis, phis; mapping = (x, y) -> ftuple(0, x; t = y/2π))\nBandstructure{Float64,3,2}: 3D Bandstructure over a 2-dimensional parameter space of type Float64\n  Subbands  : 1\n  Vertices  : 4950\n  Edges     : 14553\n  Simplices : 9604\n\njulia> bands(h(t = 1), subdiv((0, 2, 3), (20, 30)); mapping = (0, 2, 3) => (:Γ, :M, :K))\nBandstructure{Float64,2,1}: 2D Bandstructure over a 1-dimensional parameter space of type Float64\n  Subbands  : 1\n  Vertices  : 97\n  Edges     : 96\n  Simplices : 96\n\nSee also\n\n`spectrum`, `subdiv`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.bravais_matrix","page":"API","title":"Quantica.bravais_matrix","text":"bravais_matrix(lat::Lattice)\nbravais_matrix(h::AbstractHamiltonian)\n\nReturn the Bravais matrix of lattice lat or AbstractHamiltonian h, with Bravais vectors as its columns.\n\nExamples\n\njulia> lat = lattice(sublat((0,0)), bravais = ((1.0, 2), (3, 4)));\n\njulia> bravais_matrix(lat)\n2×2 SMatrix{2, 2, Float64, 4} with indices SOneTo(2)×SOneTo(2):\n 1.0  3.0\n 2.0  4.0\n\n\nSee also\n\n`lattice`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.cellsites","page":"API","title":"Quantica.cellsites","text":"cellsites(cell_indices, site_indices)\n\nSimple selector of sites with given site_indices in a given cell at cell_indices. Here, site_indices can be an index, a collection of integers or : (for all sites), and cell_indices should be a collection of L integers, where L is the lattice dimension.\n\nSee also\n\n`siteselector`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.combine","page":"API","title":"Quantica.combine","text":"combine(lats::Lattice...)\n\nIf all lats have compatible Bravais vectors, combine them into a single lattice. If necessary, sublattice names are renamed to remain unique.\n\ncombine(hams::AbstractHamiltonians...; coupling = TighbindingModel())\n\nCombine a collection hams of hamiltonians into one by combining their corresponding lattices, and optionally by adding a coupling between them, given by the hopping terms in coupling.\n\nNote that the `coupling` model will be applied to the combined lattice (which may have renamed sublattices to avoid name collissions). However, only hopping terms between different `hams` blocks will be applied.\n\nExamples\n\njulia> # Building Bernal-stacked bilayer graphene\n\njulia> hbot = HP.graphene(a0 = 1, dim = 3); htop = translate(hbot, (0, 1/√3, 1/√3));\n\njulia> h2 = combine(hbot, htop; coupling = hopping(1, sublats = :B => :C) |> plusadjoint))\n┌ Warning: Renamed repeated sublattice :A to :C\n└ @ Quantica ~/.julia/dev/Quantica/src/types.jl:60\n┌ Warning: Renamed repeated sublattice :B to :D\n└ @ Quantica ~/.julia/dev/Quantica/src/types.jl:60\nHamiltonian{Float64,3,2}: Hamiltonian on a 2D Lattice in 3D space\n  Bloch harmonics  : 5\n  Harmonic size    : 4 × 4\n  Orbitals         : [1, 1, 1, 1]\n  Element type     : scalar (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 14\n  Coordination     : 3.5\n\nSee also\n\n`hopping`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.conductance","page":"API","title":"Quantica.conductance","text":"conductance(gs::GreenSlice; nambu = false)\n\nGiven a slice gs = g[i::Integer, j::Integer] of a g::GreenFunction, build a partially evaluated object G::Conductance representing the zero-temperature, linear, differential conductance Gᵢⱼ = dIᵢ/dVⱼ between contacts i and j at arbitrary bias ω = eV in units of e^2/h. Gᵢⱼ is given by\n\n  Gᵢⱼ =  e^2/h × Tr{[im*δᵢⱼ(gʳ-gᵃ)Γⁱ-gʳΓⁱgᵃΓʲ]}         (nambu = false)\n  Gᵢⱼ =  e^2/h × Tr{[im*δᵢⱼ(gʳ-gᵃ)Γⁱτₑ-gʳΓⁱτ₃gᵃΓʲτₑ]}   (nambu = true)\n\nHere gʳ = g(ω) and gᵃ = (gʳ)' = g(ω') are the retarded and advanced Green function of the system, and Γⁱ = im * (Σⁱ - Σⁱ') is the decay rate at contact i. For Nambu systems (nambu = true), the matrices τₑ=[I 0; 0 0] and τ₃ = [I 0; 0 -I] ensure that charge reversal in Andreev reflections is properly taken into account. For normal systems (nambu = false), the total current at finite bias and temperatures is given by Iᵢ = eh   dω ⱼ fᵢ(ω) - fⱼ(ω) Gᵢⱼ(ω), where fᵢ(ω) is the Fermi distribution in lead i.\n\nKeywords\n\nnambu : whether to consider the Hamiltonian of the system is written in a Nambu basis, each site containing N electron orbitals followed by N hole orbitals.\n\nFull evaluation\n\nG(ω; params...)\n\nCompute the conductance at the specified contacts.\n\nExamples\n\njulia> # A central system g0 with two 1D leads and transparent contacts\n\njulia> glead = LP.square() |> hamiltonian(hopping(1)) |> supercell((1,0), region = r->-2<r[2]<2) |> greenfunction(GS.Schur(boundary = 0));\n\njulia> g0 = LP.square() |> hamiltonian(hopping(1)) |> supercell(region = r->-2<r[2]<2 && r[1]≈0) |> attach(glead, reverse = true) |> attach(glead) |> greenfunction;\n\njulia> G = conductance(g0[1])\nConductance{Float64}: Zero-temperature conductance dIᵢ/dVⱼ from contacts i,j, in units of e^2/h\n  Current contact  : 1\n  Bias contact     : 1\n\njulia> G(0.2)\n2.999999999999999\n\nSee also\n\n`greenfunction`, `ldos`, `current`, `josephson`, `transmission`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.current","page":"API","title":"Quantica.current","text":"current(gs::GreenSlice; charge = -I, direction = missing)\n\nBuild Js::CurrentDensitySlice, a partially evaluated object representing the equilibrium local current density Jᵢⱼ(ω) at arbitrary energy ω from site j to site i, both taken from a specific lattice slice. The current is computed along a given direction (see Keywords).\n\ncurrent(gω::GreenSolution; charge = -I, direction = missing)\n\nBuild Jω::CurrentDensitySolution, as above, but for Jᵢⱼ(ω) at a fixed ω and arbitrary sites i, j. See also greenfunction for details on building a GreenSlice and GreenSolution.\n\nThe local current density is defined here as Jᵢⱼ(ω) = (2h) rᵢⱼ Re Tr(Hᵢⱼgⱼᵢ(ω) - gᵢⱼ(ω)Hⱼᵢ) * charge, with the integrated local current given by Jᵢⱼ =  f(ω) Jᵢⱼ(ω) dω. Here Hᵢⱼ is the hopping from site j at rⱼ to i at rᵢ, rᵢⱼ = rᵢ - rⱼ, charge is the charge of carriers in orbital space (see Keywords), and gᵢⱼ(ω) is the retarded Green function between said sites.\n\nKeywords\n\ncharge : for multiorbital sites, charge can be a general matrix, which allows to compute arbitrary currents, such as spin currents.\ndirection: as defined above, Jᵢⱼ(ω) is a vector. If direction is missing the norm |Jᵢⱼ(ω)| is returned. If it is an u::Union{SVector,Tuple}, u⋅Jᵢⱼ(ω) is returned. If an n::Integer, Jᵢⱼ(ω)[n] is returned.\n\nFull evaluation\n\nJω[sites...]\nJs(ω; params...)\n\nGiven a partially evaluated Jω::CurrentDensitySolution or ρs::CurrentDensitySlice, build a sparse matrix Jᵢⱼ(ω) along the specified direction of fully evaluated local current densities.\n\nExample\n\njulia> # A semi-infinite 1D lead with a magnetic field `B`\n\njulia> g = LP.square() |> hamiltonian(@hopping((r, dr; B = 0.1) -> cis(B * dr' * SA[r[2],-r[1]]))) |> supercell((1,0), region = r->-2<r[2]<2) |> greenfunction(GS.Schur(boundary = 0));\n\njulia> J = current(g[cells = SA[1]])\nCurrentDensitySlice{Float64} : current density at a fixed location and arbitrary energy\n  charge      : LinearAlgebra.UniformScaling{Int64}(-1)\n  direction   : missing\n\njulia> J(0.2; B = 0.1)\n3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n  ⋅         0.0290138   ⋅\n 0.0290138   ⋅         0.0290138\n  ⋅         0.0290138   ⋅\n\njulia> J(0.2; B = 0.0)\n3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n  ⋅           7.77156e-16   ⋅\n 7.77156e-16   ⋅           5.55112e-16\n  ⋅           5.55112e-16   ⋅\n\n\nSee also\n\n`greenfunction`, `ldos`, `conductance`, `josephson`, `transmission`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.energies","page":"API","title":"Quantica.energies","text":"energies(sp::Spectrum)\n\nReturns the energies in sp as a vector of Numbers (not necessarily real). Equivalent to first(sp).\n\nSee also\n\n`spectrum`, `bands`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.greenfunction","page":"API","title":"Quantica.greenfunction","text":"greenfunction(h::Union{AbstractHamiltonian,OpenHamiltonian}, solver::GreenSolver)\n\nBuild a g::GreenFunction of Hamiltonian h using solver. See GreenSolvers for available solvers. If solver is not provided, a default solver is chosen automatically based on the type of h.\n\nCurrying\n\nh |> greenfunction(solver)\n\nCurried form equivalent to greenfunction(h, solver).\n\nPartial evaluation\n\nGreenFunctions allow independent, partial evaluation of their positions (producing a GreenSlice) and energy/parameters (producing a GreenSolution). Depending on the solver, this may avoid repeating calculations unnecesarily when sweeping over either of these with the other fixed.\n\ng[ss]\ng[siteselector(; ss...)]\n\nBuild a gs::GreenSlice that represents a Green function at arbitrary energy and parameter values, but at specific sites on the lattice defined by siteselector(; ss...), with ss::NamedTuple (see siteselector).\n\ng[contact_index::Integer]\n\nBuild a GreenSlice equivalent to g[contact_sites...], where contact_sites... correspond to sites in contact number contact_index (must have 1<= contact_index <= number_of_contacts). See attach for details on attaching contacts to a Hamiltonian.\n\ng[:]\n\nBuild a GreenSlice over all contacts.\n\ng[dst, src]\n\nBuild a gs::GreenSlice between sites specified by src and dst, which can take any of the forms above. Therefore, all the previous single-index slice forms correspond to a diagonal block g[i, i].\n\ng[diagonal(i, kernel = missing)]\n\nIf kernel = missing, efficiently construct diag(g[i, i]). If kernel is a matrix, return tr(g[site, site] * kernel) over each site encoded in i. Note that if there are several orbitals per site, these will have different length (i.e. number of orbitals vs number of sites). See also diagonal.\n\ng(ω; params...)\n\nBuild a gω::GreenSolution that represents a retarded Green function at arbitrary points on the lattice, but at fixed energy ω and system parameter values param. If ω is complex, the retarded or advanced Green function is returned, depending on sign(imag(ω)). If ω is Real, a small, positive imaginary part is automatically added internally to produce the retarded g.\n\ngω[i]\ngω[i, j]\ngs(ω; params...)\n\nFor any gω::GreenSolution or gs::GreenSlice, build the Green function matrix fully evaluated at fixed energy, parameters and positions. The matrix is dense and has scalar elements, so that any orbital structure on each site is flattened.\n\nExample\n\njulia> g = LP.honeycomb() |> hamiltonian(@hopping((; t = 1) -> t)) |> supercell(region = RP.circle(10)) |> greenfunction(GS.SparseLU())\nGreenFunction{Float64,2,0}: Green function of a Hamiltonian{Float64,2,0}\n  Solver          : AppliedSparseLUGreenSolver\n  Contacts        : 0\n  Contact solvers : ()\n  Contact sizes   : ()\n  ParametricHamiltonian{Float64,2,0}: Parametric Hamiltonian on a 0D Lattice in 2D space\n    Bloch harmonics  : 1\n    Harmonic size    : 726 × 726\n    Orbitals         : [1, 1]\n    Element type     : scalar (ComplexF64)\n    Onsites          : 0\n    Hoppings         : 2098\n    Coordination     : 2.88981\n    Parameters       : [:t]\n\njulia> gω = g(0.1; t = 2)\nGreenSolution{Float64,2,0}: Green function at arbitrary positions, but at a fixed energy\n\njulia> ss = (; region = RP.circle(2), sublats = :B);\n\njulia> gs = g[ss]\nGreenSlice{Float64,2,0}: Green function at arbitrary energy, but at a fixed lattice positions\n\njulia> gω[ss] == gs(0.1; t = 2)\ntrue\n\nSee also\n\n`GreenSolvers`, `diagonal`, `ldos`, `conductance`, `current`, `josephson`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.hamiltonian","page":"API","title":"Quantica.hamiltonian","text":"hamiltonian(lat::Lattice, model; orbitals = 1)\n\nCreate a Hamiltonian or ParametricHamiltonian by applying model to the lattice lat (see onsite, @onsite, hopping and @hopping for details on building tight-binding models).\n\nhamiltonian(lat::Lattice, model, modifiers...; orbitals = 1)\nhamiltonian(h::AbstractHamiltonian, modifiers...; orbitals = 1)\n\nCreate a ParametricHamiltonian where all onsite and hopping terms in model can be parametrically modified through the provided modifiers (see @onsite! and @hopping! for details on defining modifiers).\n\nKeywords\n\norbitals: number of orbitals per sublattice. If an Integer (or a Val{<:Integer} for type-stability), all sublattices will have the same number of orbitals. A collection of values indicates the orbitals on each sublattice.\n\nCurrying\n\nlat |> hamiltonian(model[, modifiers...]; kw...)\n\nCurried form of hamiltonian equivalent to hamiltonian(lat, model, modifiers...; kw...).\n\nlat |> model\n\nAlternative and less general curried form equivalent to hamiltonian(lat, model).\n\nh |> modifier\n\nAlternative and less general curried form equivalent to hamiltonian(h, modifier).\n\nIndexing\n\nh[dn::SVector{L,Int}]\nh[dn::NTuple{L,Int}]\n\nReturn the Bloch harmonic of an h::AbstractHamiltonian in the form of a SparseMatrixCSC with complex scalar eltype. This matrix is \"flat\", in the sense that it contains matrix elements between indivisual orbitals, not sites. This distinction is only relevant for multiorbital Hamiltonians. To access the non-flattened matrix use h[unflat(dn)] (see also unflat).\n\nh[()]\n\nSpecial syntax equivalent to h[(0...)], which access the fundamental Bloch harmonic.\n\nCall syntax\n\nph(; params...)\n\nReturn a h::Hamiltonian from a ph::ParametricHamiltonian by applying specific values to its parameters params. If ph is a non-parametric Hamiltonian instead, this is a no-op.\n\nh(φs; params...)\n\nReturn the flat, sparse Bloch matrix of h::AbstractHamiltonian at Bloch phases φs, with applied parameters params if h is a ParametricHamiltonian. The Bloch matrix is defined as\n\n    H = ∑_dn exp(-im φs⋅dn) H_dn\n\nwhere H_dn = h[dn] is the dn flat Bloch harmonic of h, and φs[i] = k⋅aᵢ in terms of the wavevector k and the Bravais vectors aᵢ.\n\nExamples\n\njulia> h = hamiltonian(LP.honeycomb(), hopping(SA[0 1; 1 0], range = 1/√3), orbitals = 2)\nHamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5\n  Harmonic size    : 2 × 2\n  Orbitals         : [2, 2]\n  Element type     : 2 × 2 blocks (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 3.0\n\njulia> h((0,0))\n4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:\n     ⋅          ⋅      0.0+0.0im  3.0+0.0im\n     ⋅          ⋅      3.0+0.0im  0.0+0.0im\n 0.0+0.0im  3.0+0.0im      ⋅          ⋅\n 3.0+0.0im  0.0+0.0im      ⋅          ⋅\n\nSee also\n\n`lattice`, `onsite`, `hopping`, `@onsite`, `@hopping`, `@onsite!`, `@hopping!`, `ishermitian`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.hopping","page":"API","title":"Quantica.hopping","text":"hopping(t; hops...)\nhopping((r, dr) -> t(r, dr); hops...)\n\nBuild a TighbindingModel representing a uniform or a position-dependent hopping amplitude, respectively, on hops selected by hopselector(; hops...) (see hopselector for details).\n\nHops from a site at position r₁ to another at r₂ are described using the hop center r = (r₁ + r₂)/2 and the hop vector dr = r₂ - r₁. Hopping amplitudes t can be a Number (for hops between single-orbital sites), a UniformScaling (e.g. 2I) or an AbstractMatrix (use SMatrix for performance) of dimensions matching the number of orbitals in the selected sites. Models may be applied to a lattice lat to produce an Hamiltonian with hamiltonian(lat, model; ...), see hamiltonian. Position dependent models are forced to preserve the periodicity of the lattice.\n\nhopping(m::Union{TighbindingModel,ParametricModel}; hops...)\n\nConvert m into a new model with just hopping terms acting on hops.\n\nModel algebra\n\nModels can be combined using +, - and *, or conjugated with ', e.g. onsite(1) - 2 * hopping(1)'.\n\nExamples\n\njulia> model = hopping((r, dr) -> cis(dot(SA[r[2], -r[1]], dr)); dcells = (0,0)) + onsite(r -> rand())\nTightbindingModel: model with 2 terms\n  HoppingTerm{Function}:\n    Region            : any\n    Sublattice pairs  : any\n    Cell distances    : (0, 0)\n    Hopping range     : Neighbors(1)\n    Reverse hops      : false\n    Coefficient       : 1\n  OnsiteTerm{Function}:\n    Region            : any\n    Sublattices       : any\n    Cells             : any\n    Coefficient       : 1\n\njulia> LP.honeycomb() |> supercell(2) |> hamiltonian(model)\nHamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 1\n  Harmonic size    : 8 × 8\n  Orbitals         : [1, 1]\n  Element type     : scalar (ComplexF64)\n  Onsites          : 8\n  Hoppings         : 16\n  Coordination     : 2.0\n\nSee also\n\n`onsite`, `@onsite`, `@hopping`, `@onsite!`, `@hopping!`, `hamiltonian`, `plusadjoint`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.hopselector","page":"API","title":"Quantica.hopselector","text":"hopselector(; range = neighbors(1), dcells = missing, sublats = missing, region = missing)\n\nReturn a HopSelector object that can be used to select a finite set of hops between sites in a lattice. Hops between two sites at positions r₁ = r - dr/2 and r₂ = r + dr, belonging to unit cells with a cell distance dn::SVector{L,Int} and to a sublattices with names s₁::Symbol and s₂::Symbol will be selected only if\n\n`region(r, dr) && (s₁ => s₂ in sublats) && (dcell in dcells) && (norm(dr) <= range)`\n\nIf any of these is missing it will not be used to constraint the selection.\n\nGeneralization\n\nWhile range is usually a Real, and sublats and dcells are usually collections of Pair{Symbol}s and SVectors, respectively, they also admit other possibilities:\n\nsublats = :A                       # Hops from :A to :A\nsublats = :A => :B                 # Hops from :A to :B sublattices, but not from :B to :A\nsublats = (:A => :B,)              # Same as above\nsublats = (:A => :B, :C => :D)     # Hopping from :A to :B or :C to :D\nsublats = (:A, :C) .=> (:B, :D)    # Broadcasted pairs, same as above\nsublats = (:A, :C) => (:B, :D)     # Direct product, (:A=>:B, :A=>:D, :C=>:B, :C=>D)\nsublats = 1 => 2                   # Hops from 1st to 2nd sublat. All the above patterns also admit Ints\nsublats = (spec₁, spec₂, ...)      # Hops matching any of the specs with any of the above forms\n\ndcells  = dn::SVector{L,Integer}   # Hops between cells separated by `dn`\ndcells  = dn::NTuple{L,Integer}    # Hops between cells separated by `SVector(dn)`\ndcells  = f::Function              # Hops between cells separated by `dn` such that `f(dn) == true`\n\nrange   = neighbors(n)             # Hops within the `n`-th nearest neighbor distance in the lattice\nrange   = (min, max)               # Hops at distance inside the `[min, max]` closed interval (bounds can also be `neighbors(n)`)\n\nUsage\n\nAlthough the constructor hopselector(; kw...) is exported, the end user does not usually need to call it directly. Instead, the keywords kw are input into different functions that allow filtering hops, which themselves call hopselector internally as needed. Some of these functions are\n\n- hopping(...; kw...)   : hopping model term to be applied to site pairs specified by `kw`\n- @hopping(...; kw...)  : parametric hopping model term to be applied to site pairs specified by `kw`\n- @hopping!(...; kw...) : hopping modifier to be applied to site pairs specified by `kw`\n\nExamples\n\njulia> h = LP.honeycomb() |> hamiltonian(hopping(1, range = neighbors(2), sublats = (:A, :B) .=> (:A, :B)))\nHamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 7\n  Harmonic size    : 2 × 2\n  Orbitals         : [1, 1]\n  Element type     : scalar (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 12\n  Coordination     : 6.0\n\njulia> h = LP.honeycomb() |> hamiltonian(hopping(1, range = (neighbors(2), neighbors(3)), sublats = (:A, :B) => (:A, :B)))\nHamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 9\n  Harmonic size    : 2 × 2\n  Orbitals         : [1, 1]\n  Element type     : scalar (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 18\n  Coordination     : 9.0\n\nSee also\n\n`siteselector`, `lattice`, `hopping`, `@hopping`, `@hopping!`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.josephson","page":"API","title":"Quantica.josephson","text":"josephson(gs::GreenSlice, ωmax; kBT = 0.0, phases = missing, imshift = missing, slope = 1, post = real, atol = 1e-7, quadgk_opts...)\n\nFor a gs = g[i::Integer] slice of the g::GreenFunction of a hybrid junction, build a partially evaluated object J::Integrator representing the equilibrium (static) Josephson current I_J flowing into g through contact i, integrated from -ωmax to ωmax (or from -ωmax to 0 at zero temperature kBT = 0). The result of I_J is given in units of qe/h (q is the dimensionless carrier charge). I_J can be written as I_J = Re  dω f(ω) j(ω), where j(ω) = (qeh)  2Tr(ΣʳᵢGʳ - GʳΣʳᵢ)τz.\n\nFull evaluation\n\nJ(; params...)\n\nEvaluate the Josephson current I_J for the given g parameters params, if any.\n\nKeywords\n\nkBT : temperature in same energy units as the Hamiltonian\nphases : collection of superconducting phase biases to apply to the contact, so as to efficiently compute the full current-phase relation [I_J(ϕ) for ϕ in phases]. Note that each phase bias ϕ is applied by a [cis(-ϕ/2) 0; 0 cis(ϕ/2)] rotation to the self energy, which is almost free. If missing, a single I_J is returned.\nimshift: if missing the initial and final integration points ± ωmax are shifted by im * sqrt(eps(ωmax)), to avoid the real axis. Otherwise a shift im*imshift is applied (may be zero if ωmax is greater than the bandwidth).\nslope: if non-zero, the integration will be performed along a piecewise-linear path in the complex plane (-ωmax, -ωmax/2 * (1+slope*im), 0, ωmax/2 * (1+slope*im), ωmax), taking advantage of the holomorphic integrand f(ω) j(ω) and the Cauchy Integral Theorem for faster convergence.\npost: function to apply to the result of ∫ dω f(ω) j(ω) to obtain the result, post = real by default.\natol: absolute integration tolerance. The default 1e-7 is chosen to avoid excessive integration times when the current is actually zero.\nquadgk_opts : extra keyword arguments (other than atol) to pass on to the function QuadGK.quadgk that is used for the integration.\n\nExamples\n\njulia> glead = LP.square() |> hamiltonian(onsite(0.0005 * SA[0 1; 1 0]) + hopping(SA[1 0; 0 -1]), orbitals = 2) |> supercell((1,0), region = r->-2<r[2]<2) |> greenfunction(GS.Schur(boundary = 0));\n\njulia> g0 = LP.square() |> hamiltonian(hopping(SA[1 0; 0 -1]), orbitals = 2) |> supercell(region = r->-2<r[2]<2 && r[1]≈0) |> attach(glead, reverse = true) |> attach(glead) |> greenfunction;\n\njulia> J = josephson(g0[1], 4; phases = subdiv(0, pi, 10))\nIntegrator: Complex-plane integrator\n  Integration path    : (-4.0 + 1.4901161193847656e-8im, -2.0 + 2.000000014901161im, 0.0 + 1.4901161193847656e-8im)\n  Integration options : ()\n  Integrand:          :\n  JosephsonDensity{Float64} : Equilibrium (dc) Josephson current observable before integration over energy\n    kBT                     : 0.0\n    Contact                 : 1\n    Number of phase shifts  : 10\n\njulia> J()\n10-element Vector{Float64}:\n -6.751348391359149e-16\n  0.0016315088241546964\n  0.003213820056117238\n  0.004699191781510955\n  0.0060427526322931946\n  0.0072038354411029185\n  0.008147188939639644\n  0.008844017741703502\n  0.009272686515034255\n -1.7744618723033526e-12\n\nSee also\n\n`greenfunction`,`ldos`, `current`, `conductance`, `transmission`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.lattice","page":"API","title":"Quantica.lattice","text":"lattice(sublats::Sublat...; bravais = (), dim, type, names)\nlattice(sublats::AbstractVector{<:Sublat}; bravais = (), dim, type, names)\n\nCreate a Lattice{T,E,L} from sublattices sublats, where L is the number of Bravais vectors given by bravais, T = type is the AbstractFloat type of spatial site coordinates, and dim = E is the spatial embedding dimension.\n\nlattice(lat::Lattice; bravais = missing, dim = missing, type = missing, names = missing)\n\nCreate a new lattice by applying any non-missing keywords to lat.\n\nlattice(x)\n\nReturn the parent lattice of object x, of type e.g. LatticeSlice, Hamiltonian, etc.\n\nKeywords\n\nbravais: a collection of one or more Bravais vectors of type NTuple{E} or SVector{E}. It can also be an AbstractMatrix of dimension E×L. The default bravais = () corresponds to a bounded lattice with no Bravais vectors.\nnames: a collection of Symbols. Can be used to rename sublats. Any repeated names will be replaced if necessary by :A, :B etc. to ensure that all sublattice names are unique.\n\nIndexing\n\nlat[kw...]\n\nIndexing into a lattice lat with keywords returns LatticeSlice representing a finite collection of sites selected by siteselector(; kw...). See siteselector for details on possible kw, and sites to obtain site positions.\n\nlat[]\n\nSpecial case equivalent to lat[cells = (0,...)] that returns a LatticeSlice of the zero-th unitcell.\n\nExamples\n\njulia> lat = lattice(sublat((0, 0)), sublat((0, 1)); bravais = (1, 0), type = Float32, dim = 3, names = (:up, :down))\nLattice{Float32,3,1} : 1D lattice in 3D space\n  Bravais vectors : Vector{Float32}[[1.0, 0.0, 0.0]]\n  Sublattices     : 2\n    Names         : (:up, :down)\n    Sites         : (1, 1) --> 2 total per unit cell\n\njulia> lattice(lat; type = Float64, names = (:A, :B), dim = 2)\nLattice{Float64,2,1} : 1D lattice in 2D space\n  Bravais vectors : [[1.0, 0.0]]\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (1, 1) --> 2 total per unit cell\n\nSee also\n\n`LatticePresets`, `sublat`, `sites`, `supercell`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.ldos","page":"API","title":"Quantica.ldos","text":"ldos(gs::GreenSlice; kernel = I)\n\nBuild ρs::LocalSpectralDensitySlice, a partially evaluated object representing the local density of states ρᵢ(ω) at specific sites i but at arbitrary energy ω.\n\nldos(gω::GreenSolution; kernel = I)\n\nBuild ρω::LocalSpectralDensitySolution, as above, but for ρᵢ(ω) at a fixed ω and arbitrary sites i. See also greenfunction for details on building a GreenSlice and GreenSolution.\n\nThe local density of states is defined here as ρᵢ(ω) = -Tr(gᵢᵢ(ω))π, where gᵢᵢ(ω) is the retarded Green function at a given site i.\n\nKeywords\n\nkernel : for multiorbital sites, kernel allows to compute a generalized ldos ρᵢ(ω) = -Tr(gᵢᵢ(ω) * kernel)/π, where gᵢᵢ(ω) is the retarded Green function at site i and energy ω. If kernel = missing, the complete, orbital-resolved ldos is returned.\n\nFull evaluation\n\nρω[sites...]\nρs(ω; params...)\n\nGiven a partially evaluated ρω::LocalSpectralDensitySolution or ρs::LocalSpectralDensitySlice, build a vector [ρ₁(ω), ρ₂(ω)...] of fully evaluated local densities of states.\n\nExample\n\njulia> g = HP.graphene(a0 = 1, t0 = 1) |> supercell(region = RP.circle(20)) |> attach(nothing, region = RP.circle(1)) |> greenfunction(GS.KPM(order = 300, bandrange = (-3.1, 3.1)))\nGreenFunction{Float64,2,0}: Green function of a Hamiltonian{Float64,2,0}\n  Solver          : AppliedKPMGreenSolver\n  Contacts        : 1\n  Contact solvers : (SelfEnergyEmptySolver,)\n  Contact sizes   : (6,)\n  Hamiltonian{Float64,2,0}: Hamiltonian on a 0D Lattice in 2D space\n    Bloch harmonics  : 1\n    Harmonic size    : 2898 × 2898\n    Orbitals         : [1, 1]\n    Element type     : scalar (ComplexF64)\n    Onsites          : 0\n    Hoppings         : 8522\n    Coordination     : 2.94065\n\njulia> ldos(g(0.2))[1]\n6-element Vector{Float64}:\n 0.036802204179316955\n 0.034933055722650375\n 0.03493305572265026\n 0.03493305572265034\n 0.03493305572265045\n 0.036802204179317045\n\njulia> ldos(g(0.2))[1] == -imag.(g[diagonal(1; kernel = I)](0.2)) ./ π\ntrue\n\nSee also\n\n`greenfunction`, `diagonal`, `current`, `conductance`, `josephson`, `transmission`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.neighbors","page":"API","title":"Quantica.neighbors","text":"neighbors(n::Int)\n\nCreate a Neighbors(n) object that represents a hopping range to distances corresponding to the n-th nearest neighbors in a given lattice, irrespective of their sublattice. Neighbors at equal distance do not count towards n.\n\nneighbors(n::Int, lat::Lattice)\n\nObtain the actual nth-nearest-neighbot distance between sites in lattice lat.\n\nSee also\n\n`hopping`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.onsite","page":"API","title":"Quantica.onsite","text":"onsite(o; sites...)\nonsite(r -> o(r); sites...)\n\nBuild a TighbindingModel representing a uniform or a position-dependent onsite potential, respectively, on sites selected by siteselector(; sites...) (see siteselector for details).\n\nSite positions are r::SVector{E}, where E is the embedding dimension of the lattice. The onsite potential o can be a Number (for single-orbital sites), a UniformScaling (e.g. 2I) or an AbstractMatrix (use SMatrix for performance) of dimensions matching the number of orbitals in the selected sites. Models may be applied to a lattice lat to produce a Hamiltonian with hamiltonian(lat, model; ...), see hamiltonian. Position dependent models are forced to preserve the periodicity of the lattice.\n\nonsite(m::{TighbindingModel,ParametricModel}; sites...)\n\nConvert m into a new model with just onsite terms acting on sites.\n\nModel algebra\n\nModels can be combined using +, - and *, or conjugated with ', e.g. onsite(1) - 2 * hopping(1)'.\n\nExamples\n\njulia> model = onsite(r -> norm(r) * SA[0 1; 1 0]; sublats = :A) - hopping(I; range = 2)\nTightbindingModel: model with 2 terms\n  OnsiteTerm{Function}:\n    Region            : any\n    Sublattices       : A\n    Cells             : any\n    Coefficient       : 1\n  HoppingTerm{LinearAlgebra.UniformScaling{Bool}}:\n    Region            : any\n    Sublattice pairs  : any\n    Cell distances    : any\n    Hopping range     : 2.0\n    Reverse hops      : false\n    Coefficient       : -1\n\njulia> LP.cubic() |> supercell(4) |> hamiltonian(model, orbitals = 2)\nHamiltonian{Float64,3,3}: Hamiltonian on a 3D Lattice in 3D space\n  Bloch harmonics  : 27\n  Harmonic size    : 64 × 64\n  Orbitals         : [2]\n  Element type     : 2 × 2 blocks (ComplexF64)\n  Onsites          : 64\n  Hoppings         : 2048\n  Coordination     : 32.0\n\nSee also\n\n`hopping`, `@onsite`, `@hopping`, `@onsite!`, `@hopping!`, `hamiltonian`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.plusadjoint","page":"API","title":"Quantica.plusadjoint","text":"plusadjoint(t::Model)\n\nReturns a model t + t'. This is a convenience function analogous to the + h.c. notation.\n\nExample\n\njulia> model = hopping(im, sublats = :A => :B) |> plusadjoint\nTightbindingModel: model with 2 terms\n  HoppingTerm{Complex{Bool}}:\n    Region            : any\n    Sublattice pairs  : :A => :B\n    Cell distances    : any\n    Hopping range     : Neighbors(1)\n    Reverse hops      : false\n    Coefficient       : 1\n  HoppingTerm{Complex{Int64}}:\n    Region            : any\n    Sublattice pairs  : :A => :B\n    Cell distances    : any\n    Hopping range     : Neighbors(1)\n    Reverse hops      : true\n    Coefficient       : 1\n\njulia> h = hamiltonian(LP.honeycomb(), model)\nHamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5\n  Harmonic size    : 2 × 2\n  Orbitals         : [1, 1]\n  Element type     : scalar (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 3.0\n\njulia> h((0,0))\n2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅      0.0-3.0im\n 0.0+3.0im      ⋅\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.sites","page":"API","title":"Quantica.sites","text":"sites(lat::Lattice[, sublat])\n\nReturn a collection of site positions in the unit cell of lattice lat. If a sublat::Symbol or sublat::Int is specified, only sites for the specified sublattice are returned.\n\nsites(ls::LatticeSlice)\n\nReturn a collection of positions of a LatticeSlice, generally obtained by indexing a lattice lat[sel...] with some siteselector keywords sel. See also lattice.\n\nNote: the returned collections can be of different types (vectors, generators, views...)\n\nExamples\n\njulia> sites(LatticePresets.honeycomb(), :A)\n1-element view(::Vector{SVector{2, Float64}}, 1:1) with eltype SVector{2, Float64}:\n [0.0, -0.2886751345948129]\n\nSee also\n\n`lattice`, `siteselector`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.siteselector","page":"API","title":"Quantica.siteselector","text":"siteselector(; region = missing, sublats = missing, cells = missing)\n\nReturn a SiteSelector object that can be used to select a finite set of sites in a lattice. Sites at position r::SVector{E}, belonging to a cell of index n::SVector{L,Int} and to a sublattice with name s::Symbol will be selected only if\n\n`region(r) && s in sublats && n in cells`\n\nAny missing region, sublat or cells will not be used to constraint the selection.\n\nGeneralization\n\nWhile sublats and cells are usually collections of Symbols and SVectors, respectively, they also admit other possibilities:\n\nIf either cells or sublats are a single cell or sublattice, they will be treated as single-element collections\nIf sublat is a collection of Integers, it will refer to sublattice numbers.\nIf cells is an i::Integer, it will be converted to an SVector{1}\nIf cells is a collection, each element will be converted to an SVector.\nIf cells is a boolean function, n in cells will be the result of cells(n)\n\nUsage\n\nAlthough the constructor siteselector(; kw...) is exported, the end user does not usually need to call it directly. Instead, the keywords kw are input into different functions that allow filtering sites, which themselves call siteselector internally as needed. Some of these functions are\n\ngetindex(lat::Lattice; kw...) : return a LatticeSlice with sites specified by kw (also lat[kw...])\nsupercell(lat::Lattice; kw...) : returns a bounded lattice with the sites specified by kw\nonsite(...; kw...) : onsite model term to be applied to sites specified by kw\n@onsite!(...; kw...) : onsite modifier to be applied to sites specified by kw\n\nSee also\n\n`hopselector`, `lattice`, `supercell`, `onsite`, `@onsite`, `@onsite!`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.spectrum","page":"API","title":"Quantica.spectrum","text":"spectrum(h::AbstractHamiltonian, ϕs; solver = EigenSolvers.LinearAlgebra(), transform = missing, params...)\n\nCompute the Spectrum of the Bloch matrix h(ϕs; params...) using the specified eigensolver, with transform applied to the resulting eigenenergies, if not missing. Eigenpairs are sorted by the real part of their energy. See EigenSolvers for available solvers and their options.\n\nspectrum(h::AbstractHamiltonian; kw...)\n\nFor a 0D h, equivalent to spectrum(h, (); kw...)\n\nspectrum(m::AbstractMatrix; solver = EigenSolvers.LinearAlgebra()], transform = missing)\n\nCompute the Spectrum of matrix m using solver and transform.\n\nspectrum(b::Bandstructure, ϕs)\n\nCompute the Spectrum corresponding to slicing the bandstructure b at point ϕs of its base mesh (see bands for details).\n\nIndexing and destructuring\n\nEigenenergies ϵs::Tuple and eigenstates ψs::Matrix can be extracted from a spectrum sp using any of the following\n\nϵs, ψs = sp\nϵs = first(sp)\nϵs = energies(sp)\nψs = last(sp)\nψs = states(sp)\n\nIn addition, one can extract the n eigenpairs closest (in real energy) to a given energy ϵ₀ with\n\nϵs, ψs = sp[1:n, around = ϵ₀]\n\nMore generally, sp[inds, around = ϵ₀] will take the eigenpairs at position given by inds after sorting by increasing distance to ϵ₀, or the closest eigenpair in inds is missing. If around is omitted, the ordering in sp is used.\n\nExamples\n\njulia> h = HP.graphene(t0 = 1); spectrum(h, (0,0))\nSpectrum{Float64,ComplexF64} :\nEnergies:\n2-element Vector{ComplexF64}:\n -2.9999999999999982 + 0.0im\n  2.9999999999999982 + 0.0im\nStates:\n2×2 Matrix{ComplexF64}:\n -0.707107+0.0im  0.707107+0.0im\n  0.707107+0.0im  0.707107+0.0im\n\nSee also\n\n`EigenSolvers`, `bands`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.states","page":"API","title":"Quantica.states","text":"states(sp::Spectrum)\n\nReturns the eigenstates in sp as columns of a matrix. Equivalent to last(sp).\n\nSee also\n\n`spectrum`, `bands`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.subdiv","page":"API","title":"Quantica.subdiv","text":"subdiv((x₁, x₂, ..., xₙ), (p₁, p₂, ..., pₙ₋₁))\n\nBuild a vector of values between x₁ and xₙ containing all xᵢ such that in each interval [xᵢ, xᵢ₊₁] there are pᵢ equally space values.\n\nsubdiv((x₁, x₂, ..., xₙ), p)\n\nSame as above with all pᵢ = p\n\nsubdiv(x₁, x₂, p)\n\nEquivalent to subdiv((x₁, x₂), p) == collect(range(x₁, x₂, length = p))\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.sublat","page":"API","title":"Quantica.sublat","text":"sublat(sites...; name::Symbol = :A)\nsublat(sites::AbstractVector; name::Symbol = :A)\n\nCreate a Sublat{E,T} that adds a sublattice, of name name, with sites at positions sites in E dimensional space. Sites positions can be entered as Tuples or SVectors.\n\nExamples\n\njulia> sublat((0.0, 0), (1, 1), (1, -1), name = :A)\nSublat{2,Float64} : sublattice of Float64-typed sites in 2D space\n  Sites    : 3\n  Name     : :A\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.supercell","page":"API","title":"Quantica.supercell","text":"supercell(lat::Lattice{E,L}, v::NTuple{L,Integer}...; seed = missing, kw...)\nsupercell(lat::Lattice{E,L}, uc::SMatrix{L,L´,Int}; seed = missing, kw...)\n\nGenerate a new Lattice from an L-dimensional lattice lat with a larger unit cell, such that its Bravais vectors are br´= br * uc. Here uc::SMatrix{L,L´,Int} is the integer supercell matrix, with the L´ vectors vs as its columns. If no v are given, the new lattice will have no Bravais vectors (i.e. it will be bounded, with its shape determined by keywords kw...). Likewise, if L´ < L, the resulting lattice will be bounded along L´ - L directions, as dictated by kw....\n\nOnly sites selected by siteselector(; kw...) will be included in the supercell (see siteselector for details on the available keywords kw). If no keyword region is given in kw, a single Bravais unit cell perpendicular to the v axes will be selected along the L-L´ bounded directions.\n\nsupercell(lattice::Lattice{E,L}, factors::Integer...; seed = missing, kw...)\n\nCall supercell with different scaling along each Bravais vector, so that supercell matrix uc is Diagonal(factors). If a single factor is given, uc = SMatrix{L,L}(factor * I)\n\nsupercell(h::Hamiltonian, v...; mincoordination = 0, seed = missing, kw...)\n\nTransform the Lattice of h to have a larger unit cell, while expanding the Hamiltonian accordingly.\n\nKeywords\n\nseed::NTuple{L,Integer}: starting cell index to perform search of included sites. By default seed = missing, which makes search start from the zero-th cell.\nmincoordination::Integer: minimum number of nonzero hopping neighbors required for sites to be included in the supercell. Sites with less coordination will be removed recursively, until all remaining sites satisfy mincoordination.\n\nCurrying\n\nlat_or_h |> supercell(v...; kw...)\n\nCurried syntax, equivalent to supercell(lat_or_h, v...; kw...)\n\nExamples\n\njulia> LatticePresets.square() |> supercell((1, 1), region = r -> 0 < r[1] < 5)\nLattice{Float64,2,1} : 1D lattice in 2D space\n  Bravais vectors : [[1.0, 1.0]]\n  Sublattices     : 1\n    Names         : (:A,)\n    Sites         : (8,) --> 8 total per unit cell\n\njulia> LatticePresets.honeycomb() |> supercell(3)\nLattice{Float64,2,2} : 2D lattice in 2D space\n  Bravais vectors : [[1.5, 2.598076], [-1.5, 2.598076]]\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (9, 9) --> 18 total per unit cell\n\nSee also\n\n`supercell`, `siteselector`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.transform","page":"API","title":"Quantica.transform","text":"transform(lat_or_h::Union{Lattice,AbstractHamiltonian}, f::Function)\n\nBuild a new lattice or hamiltonian transforming each site positions r into f(r).\n\nCurrying\n\nx |> transform(f::Function)\n\nCurried version of transform, equivalent to transform(f, x)\n\nNote: Unexported `Quantica.transform!` is also available for in-place transforms. Use with care, as aliasing (i.e. several objects sharing the modified one) can produce unexpected results.\n\nExamples\n\njulia> LatticePresets.square() |> transform(r -> 3r)\nLattice{Float64,2,2} : 2D lattice in 2D space\n  Bravais vectors : [[3.0, 0.0], [0.0, 3.0]]\n  Sublattices     : 1\n    Names         : (:A,)\n    Sites         : (1,) --> 1 total per unit cell\n\nSee also\n\n`translate`, `reverse`, `reverse!`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.translate","page":"API","title":"Quantica.translate","text":"translate(lat::Lattice, δr)\n\nBuild a new lattice translating each site positions from r to r + δr, where δr can be a NTuple or an SVector in embedding space.\n\nCurrying\n\nx |> translate(δr)\n\nCurried version of translate, equivalent to translate(x, δr)\n\nNote: Unexported `Quantica.translate!` is also available for in-place translations. Use with care, as aliasing (i.e. several objects sharing the modified one) can produce unexpected results.\n\nExamples\n\njulia> LatticePresets.square() |> translate((3,3)) |> sites\n1-element Vector{SVector{2, Float64}}:\n [3.0, 3.0]\n\n\nSee also\n\n`transform`, `reverse`, `reverse!`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.transmission","page":"API","title":"Quantica.transmission","text":"transmission(gs::GreenSlice)\n\nGiven a slice gs = g[i::Integer, j::Integer] of a g::GreenFunction, build a partially evaluated object T::Transmission representing the normal transmission probability Tᵢⱼ(ω) from contact j to i at energy ω. It can be written as Tᵢⱼ = TrgʳΓⁱgᵃΓʲ. Here gʳ = g(ω) and gᵃ = (gʳ)' = g(ω') are the retarded and advanced Green function of the system, and Γⁱ = im * (Σⁱ - Σⁱ') is the decay rate at contact i\n\nFull evaluation\n\nT(ω; params...)\n\nCompute the transmission Tᵢⱼ(ω) at a given ω and for the specified params of g.\n\nExamples\n\njulia> # A central system g0 with two 1D leads and transparent contacts\n\njulia> glead = LP.honecycomb() |> hamiltonian(hopping(1)) |> supercell((1,-1), region = r->-2<r[2]<2) |> greenfunction(GS.Schur(boundary = 0));\n\njulia> g0 = LP.honecycomb() |> hamiltonian(hopping(1)) |> supercell(region = r->-2<r[2]<2 && r[1]≈0) |> attach(glead, reverse = true) |> attach(glead) |> greenfunction;\n\njulia> T = transmission(g0[2, 1])\nTransmission: total transmission probability between two different contacts\n  From contact  : 1\n  To contact    : 2\n\njulia> T(0.2)   # The difference from 3 is due to the automatic `im*sqrt(eps(Float64))` added to `ω`\n2.9999999410323537\n\njulia> T(0.2 + 0.00000000000001im)\n2.999999999999961\n\nSee also\n\n`greenfunction`, `conductance`, `ldos`, `current`, `josephson`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.unflat","page":"API","title":"Quantica.unflat","text":"unflat(dn)\n\nConstruct an u::Unflat object wrapping some indices dn. This object is meant to be used to index into a h::AbstractHamiltonian as h[u], which returns an non-flattened version of the Bloch harmonic h[dn]. Each element in the matrix h[u] is an SMatrix block representing onsite or hoppings between whole sites, in contrast to h[dn] where they are scalars representing single orbitals. This is only relevant for multi-orbital Hamiltonians h.\n\nunflat()\n\nEquivalent to unflat(())\n\nExamples\n\njulia> h = HP.graphene(orbitals = 2); h[unflat(0,0)])\n2×2 SparseArrays.SparseMatrixCSC{SMatrix{2, 2, ComplexF64, 4}, Int64} with 2 stored entries:\n                     ⋅                       [2.7+0.0im 0.0+0.0im; 0.0+0.0im 2.7+0.0im]\n [2.7+0.0im 0.0+0.0im; 0.0+0.0im 2.7+0.0im]                      ⋅\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.wrap","page":"API","title":"Quantica.wrap","text":"wrap(h::AbstractHamiltonian, (ϕ₁, ϕ₂,...))\n\nFor an h of lattice dimension L and a set of L Bloch phases ϕ = (ϕ₁, ϕ₂,...), contruct a new zero-dimensional h´::AbstractHamiltonian for all Bravais vectors have been eliminated by wrapping the lattice onto itself along the corresponding Bravais vector. Intercell hoppings along wrapped directions will pick up a Bloch phase exp(-iϕ⋅dn).\n\nIf a number L´ of phases ϕᵢ are : instead of numbers, the corresponding Bravais vectors will not be wrapped, and the resulting h´ will have a finite lattice dimension L´.\n\nCurrying\n\nh |> wrap((ϕ₁, ϕ₂,...))\n\nCurrying syntax equivalent to wrap(h, (ϕ₁, ϕ₂,...)).\n\nExamples\n\njulia> h2D = HP.graphene(); h1D = wrap(h2D, (:, 0.2))\nHamiltonian{Float64,2,1}: Hamiltonian on a 1D Lattice in 2D space\n  Bloch harmonics  : 3\n  Harmonic size    : 2 × 2\n  Orbitals         : [1, 1]\n  Element type     : scalar (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 4\n  Coordination     : 2.0\n\njulia> h2D((0.3, 0.2)) ≈ h1D(0.3)\ntrue\n\nSee also\n\n`hamiltonian`, `supercell`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.@hopping","page":"API","title":"Quantica.@hopping","text":"@hopping((; params...) -> t(; params...); hops...)\n@hopping((r, dr; params...) -> t(r; params...); hops...)\n\nBuild a ParametricModel representing a uniform or a position-dependent hopping amplitude, respectively, on hops selected by hopselector(; hops...) (see hopselector for details).\n\nHops from a site at position r₁ to another at r₂ are described using the hop center r = (r₁ + r₂)/2 and the hop vector dr = r₂ - r₁. Hopping amplitudes t can be a Number (for hops between single-orbital sites), a UniformScaling (e.g. 2I) or an AbstractMatrix (use SMatrix for performance) of dimensions matching the number of site orbitals in the selected sites. Parametric models may be applied to a lattice lat to produce a ParametricHamiltonian with hamiltonian(lat, model; ...), see hamiltonian. Position dependent models are forced to preserve the periodicity of the lattice.\n\nThe difference between regular and parametric tight-binding models (see onsite and hopping) is that parametric models may depend on arbitrary parameters, specified by the params keyword arguments. These are inherited by h::ParametricHamiltonian, which can then be evaluated very efficiently for different parameter values by callling h(; params...), to obtain a regular Hamiltonian without reconstructing it from scratch.\n\n@hopping((ω; params...) -> Σᵢⱼ(ω; params...); hops...)\n@hopping((ω, r, dr; params...) -> Σᵢⱼ(ω, r, dr; params...); hops...)\n\nSpecial form of a parametric hopping amplitude meant to model a self-energy (see attach).\n\nModel algebra\n\nParametric models can be combined using +, - and *, or conjugated with ', e.g. @onsite((; o=1) -> o) - 2 * hopping(1)'. The combined parametric models can share parameters.\n\nExamples\n\njulia> model = @hopping((r, dr; t = 1, A = Returns(SA[0,0])) -> t * cis(-dr' * A(r)))\nParametricModel: model with 1 term\n  ParametricHoppingTerm{ParametricFunction{2}}\n    Region            : any\n    Sublattice pairs  : any\n    Cell distances    : any\n    Hopping range     : Neighbors(1)\n    Reverse hops      : false\n    Coefficient       : 1\n    Parameters        : [:t, :A]\n\njulia> LP.honeycomb() |> supercell(2) |> hamiltonian(model)\nParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5\n  Harmonic size    : 8 × 8\n  Orbitals         : [1, 1]\n  Element type     : scalar (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 24\n  Coordination     : 3.0\n  Parameters       : [:A, :t]\n\nSee also\n\n`onsite`, `hopping`, `@onsite`, `@onsite!`, `@hopping!`, `attach`, `hamiltonian`\n\n\n\n\n\n","category":"macro"},{"location":"api/#Quantica.@hopping!","page":"API","title":"Quantica.@hopping!","text":"@hopping!((t; params...) -> t´(t; params...); hops...)\n@hopping!((t, r, dr; params...) -> t´(t, r, dr; params...); hops...)\n\nBuild a uniform or position-dependent hopping term modifier, respectively, acting on hops selected by hopselector(; hops...) (see hopselector for details).\n\nHops from a site at position r₁ to another at r₂ are described using the hop center r = (r₁ + r₂)/2 and the hop vector dr = r₂ - r₁. The original hopping amplitude is t, and the modified hopping is t´, which is a function of t and possibly r, dr. It may optionally also depend on parameters, enconded in params.\n\nModifiers are meant to be applied to an h:AbstractHamiltonian to obtain a ParametricHamiltonian (with hamiltonian(h, modifiers...) or hamiltonian(lat, model, modifiers...), see hamiltonian). Modifiers will affect only pre-existing model terms. In particular, if no onsite model has been applied to a specific site, its onsite potential will be zero, and will not be modified by any @onsite! modifier. Conversely, if an onsite model has been applied, @onsite! may modify the onsite potential even if it is zero. The same applies to @hopping!.\n\nExamples\n\njulia> model = hopping(1); peierls = @hopping!((t, r, dr; A = r -> SA[0,0]) -> t * cis(-dr' * A(r)))\nOnsiteModifier{ParametricFunction{3}}:\n  Region            : any\n  Sublattice pairs  : any\n  Cell distances    : any\n  Hopping range     : Neighbors(1)\n  Reverse hops      : false\n  Parameters        : [:A]\n\njulia> LP.honeycomb() |> hamiltonian(model) |> supercell(10) |> hamiltonian(peierls)\nParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5\n  Harmonic size    : 200 × 200\n  Orbitals         : [1, 1]\n  Element type     : scalar (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 600\n  Coordination     : 3.0\n  Parameters       : [:A]\n\nSee also\n\n`onsite`, `hopping`, `@onsite`, `@hopping`, `@onsite!`, `hamiltonian`\n\n\n\n\n\n","category":"macro"},{"location":"api/#Quantica.@onsite","page":"API","title":"Quantica.@onsite","text":"@onsite((; params...) -> o(; params...); sites...)\n@onsite((r; params...) -> o(r; params...); sites...)\n\nBuild a ParametricModel representing a uniform or a position-dependent onsite potential, respectively, on sites selected by siteselector(; sites...) (see siteselector for details).\n\nSite positions are r::SVector{E}, where E is the embedding dimension of the lattice. The onsite potential o can be a Number (for single-orbital sites), a UniformScaling (e.g. 2I) or an AbstractMatrix (use SMatrix for performance) of dimensions matching the number of orbitals in the selected sites. Parametric models may be applied to a lattice lat to produce a ParametricHamiltonian with hamiltonian(lat, model; ...), see hamiltonian. Position dependent models are forced to preserve the periodicity of the lattice.\n\nThe difference between regular and parametric tight-binding models (see onsite and hopping) is that parametric models may depend on arbitrary parameters, specified by the params keyword arguments. These are inherited by h::ParametricHamiltonian, which can then be evaluated very efficiently for different parameter values by callling h(; params...), to obtain a regular Hamiltonian without reconstructing it from scratch.\n\n@onsite((ω; params...) -> Σᵢᵢ(ω; params...); sites...)\n@onsite((ω, r; params...) -> Σᵢᵢ(ω, r; params...); sites...)\n\nSpecial form of a parametric onsite potential meant to model a self-energy (see attach).\n\nModel algebra\n\nParametric models can be combined using +, - and *, or conjugated with ', e.g. @onsite((; o=1) -> o) - 2 * hopping(1)'. The combined parametric models can share parameters.\n\nExamples\n\njulia> model = @onsite((r; dμ = 0) -> (r[1] + dμ) * I; sublats = :A) + @onsite((; dμ = 0) -> - dμ * I; sublats = :B)\nParametricModel: model with 2 terms\n  ParametricOnsiteTerm{ParametricFunction{1}}\n    Region            : any\n    Sublattices       : A\n    Cells             : any\n    Coefficient       : 1\n    Parameters        : [:dμ]\n  ParametricOnsiteTerm{ParametricFunction{0}}\n    Region            : any\n    Sublattices       : B\n    Cells             : any\n    Coefficient       : 1\n    Parameters        : [:dμ]\n\njulia> LP.honeycomb() |> supercell(2) |> hamiltonian(model, orbitals = 2)\nParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 1\n  Harmonic size    : 8 × 8\n  Orbitals         : [2, 2]\n  Element type     : 2 × 2 blocks (ComplexF64)\n  Onsites          : 8\n  Hoppings         : 0\n  Coordination     : 0.0\n  Parameters       : [:dμ]\n\nSee also\n\n`onsite`, `hopping`, `@hopping`, `@onsite!`, `@hopping!`, `attach`, `hamiltonian`\n\n\n\n\n\n","category":"macro"},{"location":"api/#Quantica.@onsite!","page":"API","title":"Quantica.@onsite!","text":"@onsite!((o; params...) -> o´(o; params...); sites...)\n@onsite!((o, r; params...) -> o´(o, r; params...); sites...)\n\nBuild a uniform or position-dependent onsite term modifier, respectively, acting on sites selected by siteselector(; sites...) (see siteselector for details).\n\nSite positions are r::SVector{E}, where E is the embedding dimension of the lattice. The original onsite potential is o, and the modified potential is o´, which is a function of o and possibly r. It may optionally also depend on parameters, enconded in params.\n\nModifiers are meant to be applied to an h:AbstractHamiltonian to obtain a ParametricHamiltonian (with hamiltonian(h, modifiers...) or hamiltonian(lat, model, modifiers...), see hamiltonian). Modifiers will affect only pre-existing model terms. In particular, if no onsite model has been applied to a specific site, its onsite potential will be zero, and will not be modified by any @onsite! modifier. Conversely, if an onsite model has been applied, @onsite! may modify the onsite potential even if it is zero. The same applies to @hopping!.\n\nExamples\n\njulia> model = onsite(0); disorder = @onsite!((o; W = 0) -> o + W * rand())\nOnsiteModifier{ParametricFunction{1}}:\n  Region            : any\n  Sublattices       : any\n  Cells             : any\n  Parameters        : [:W]\n\njulia> LP.honeycomb() |> hamiltonian(model) |> supercell(10) |> hamiltonian(disorder)\nParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 1\n  Harmonic size    : 200 × 200\n  Orbitals         : [1, 1]\n  Element type     : scalar (ComplexF64)\n  Onsites          : 200\n  Hoppings         : 0\n  Coordination     : 0.0\n  Parameters       : [:W]\n\nSee also\n\n`onsite`, `hopping`, `@onsite`, `@hopping`, `@hopping!`, `hamiltonian`\n\n\n\n\n\n","category":"macro"},{"location":"tutorial/observables/#Observables","page":"Observables","title":"Observables","text":"","category":"section"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"We are almost at our destination now. We have defined a Lattice, a Model for our system, we applied the Model to the Lattice to obtain a Hamiltonian or a ParametricHamiltonian, and finally, after possibly attaching some contacts to outside reservoirs and specifying a GreenSolver, we obtained a GreenFunction. It is now time to use the GreenFunction to obtain some observables of interest.","category":"page"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"Currently, we have the following observables built into Quantica.jl (with more to come in the future)     - ldos: computes the local density of states at specific energy and sites     - current: computes the local current density along specific directions, and at specific energy and sites     - transmission: computes the total transmission between contacts     - conductance: computes the differential conductance dIᵢ/dVⱼ between contacts i and j     - josephson: computes the supercurrent and the current-phase relation through a given contact in a superconducting system","category":"page"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"See the corresponding docstrings for full usage instructions. Here we will present some basic examples","category":"page"},{"location":"tutorial/observables/#Local-density-of-states-(LDOS)","page":"Observables","title":"Local density of states (LDOS)","text":"","category":"section"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"Let us compute the LDOS in a cavity like in the previous section. Instead of computing the Green function between a contact to an arbitrary point, we can construct an object ρ = ldos(g(ω)) without any contacts. By using a small imaginary part in ω, we broaden the discrete spectrum, and obtain a finite LDOS. Then, we can pass ρ directly as a site shader to qplot","category":"page"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"julia> h = LP.square() |> onsite(4) - hopping(1) |> supercell(region = r -> norm(r) < 40*(1+0.2*cos(5*atan(r[2],r[1]))));\n\njulia> g = h|> greenfunction;\n\njulia> ρ = ldos(g(0.1 + 0.001im))\nLocalSpectralDensitySolution{Float64} : local density of states at fixed energy and arbitrary location\n  kernel   : LinearAlgebra.UniformScaling{Bool}(true)\n\njulia> qplot(h, hide = :hops, sitecolor = ρ, siteradius = ρ, minmaxsiteradius = (0, 2), sitecolormap = :balance)","category":"page"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"<img src=\"../../assets/star_shape_ldos.png\" alt=\"LDOS\" width=\"400\" class=\"center\"/>","category":"page"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"Note that ρ[sites...] produces a vector with the LDOS at sites defined by siteselector(; sites...) (ρ[] is the ldos over all sites). We can also define a kernel to be traced over orbitals to obtain the spectral density of site-local observables (see diagonal slicing in the preceding section).","category":"page"},{"location":"tutorial/observables/#Current","page":"Observables","title":"Current","text":"","category":"section"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"A similar computation can be done to obtain the current density, using J = current(g(ω), direction = missing). This time J[sᵢ, sⱼ] yields a sparse matrix of current densities along a given direction for each hopping (or the current norm if direction = missing). Passing J as a hopping shader yields the equilibrium current in a system. In the above example we can add a magnetic flux to make this current finite","category":"page"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"julia> h = LP.square() |> supercell(region = r -> norm(r) < 40*(1+0.2*cos(5*atan(r[2],r[1])))) |> onsite(4) - @hopping((r, dr; B = 0.1) -> cis(B * dr[1] * r[2]));\n\njulia> g = h |> greenfunction;\n\njulia> J = current(g(0.1; B = 0.01))\nCurrentDensitySolution{Float64} : current density at a fixed energy and arbitrary location\n  charge      : LinearAlgebra.UniformScaling{Int64}(-1)\n  direction   : missing\n\njulia> qplot(h, siteradius = 0.08, sitecolor = :black, siteoutline = 0, hopradius = J, hopcolor = J, minmaxhopradius = (0, 2), hopcolormap = :balance, hopdarken = 0)","category":"page"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"<img src=\"../../assets/star_shape_current.png\" alt=\"Current density with magnetic flux\" width=\"400\" class=\"center\"/>","category":"page"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"note: Remember to construct supercell before applying position-dependent fields\nNote that we built the supercell before applying the model with the magnetic flux. Not doing so would make the gauge field be repeated in each unit cell when expanding the supercell. This was mentioned in the section on Hamiltonians, and is a common mistake when modeling systems with position dependent fields.","category":"page"},{"location":"tutorial/observables/#Transmission","page":"Observables","title":"Transmission","text":"","category":"section"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"The transmission Tᵢⱼ from contact j to contact i can be computed using transmission. This function accepts a GreenSlice between the contact. Let us recover the four-terminal setup of the preceding section, but let's make it bigger this time","category":"page"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"julia> hcentral = LP.square() |> onsite(4) - hopping(1) |> supercell(region = RP.circle(100) | RP.rectangle((202, 50)) | RP.rectangle((50, 202)))\n\njulia> glead = LP.square() |> onsite(4) - hopping(1) |> supercell((1, 0), region = r -> abs(r[2]) <= 50/2) |> greenfunction(GS.Schur(boundary = 0));\n\njulia> Rot = r -> SA[0 -1; 1 0] * r;  # 90º rotation function\n\njulia> g = hcentral |>\n           attach(glead, region = r -> r[1] ==  101) |>\n           attach(glead, region = r -> r[1] == -101, reverse = true) |>\n           attach(glead, region = r -> r[2] ==  101, transform = Rot) |>\n           attach(glead, region = r -> r[2] == -101, reverse = true, transform = Rot) |>\n           greenfunction;\n\njulia> gx1 = sum(abs2, g(0.04)[siteselector(), 1], dims = 2);\n\njulia> qplot(hcentral, hide = :hops, siteoutline = 1, sitecolor = (i, r) -> gx1[i], siteradius = (i, r) -> gx1[i], minmaxsiteradius = (0, 2), sitecolormap = :balance)","category":"page"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"<img src=\"../../assets/four_terminal_g_big.png\" alt=\"Green function from right lead\" width=\"400\" class=\"center\"/>","category":"page"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"It's apparent from the plot that the transmission from right to left (T₂₁ here) at this energy of 0.04 is larger than from right to top (T₃₁). Is this true in general? Let us compute the two transmissions as a function of energy. To show the progress of the calculation we can use a monitor package, such as ProgressMeter","category":"page"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"julia> using ProgressMeter\n\njulia> T₂₁ = transmission(g[2,1]); T₃₁ = transmission(g[3,1]); ωs = subdiv(0, 8, 201);\n\njulia> T₂₁ω = @showprogress [T₂₁(ω) for ω in ωs]; T₃₁ω = @showprogress [T₃₁(ω) for ω in ωs];\nProgress: 100%|██████████████████████████████████████████████████████████████| Time: 0:01:02\nProgress: 100%|██████████████████████████████████████████████████████████████| Time: 0:01:00\n\njulia> f = Figure(); a = Axis(f[1,1], xlabel = \"ω/t\", ylabel = \"T(ω)\"); lines!(a, ωs, T₂₁ω, label = L\"T_{2,1}\"); lines!(a, ωs, T₃₁ω, label = L\"T_{3,1}\"); axislegend(\"Transmission\", position = :lt); f","category":"page"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"<img src=\"../../assets/four_terminal_T.png\" alt=\"Total transmission from right contact\" width=\"400\" class=\"center\"/>","category":"page"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"So we indeed find that the 90-degree transmission T₃₁ is indeed larger than the forward transmission T₂₁ for all energies. The rapid oscillations are due to mesoscopic fluctuations.","category":"page"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"note: Total transmission vs transmission probability\nNote that transmission gives the total transmission, which is the sum of the transmission probability from each orbital in the source contact to any other orbital in the drain contact. As such it is not normalized to 1, but to the number of source orbitals. It also gives the local conductance from a given contact in units of e^2h according to the Landauer formula, G_j = e^2h sum_i T_ij(eV).","category":"page"},{"location":"tutorial/observables/#Conductance","page":"Observables","title":"Conductance","text":"","category":"section"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"Local and non-local differential conductance G_ij = dI_idV_j can be computed with G = conductance(g[i,j]). Calling G(ω) returns the conductance at bias eV = omega in units of e^2h. Let's look at the local differential conductance into the right contact in the previous example","category":"page"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"julia> G₁₁ = conductance(g[1,1])\nConductance{Float64}: Zero-temperature conductance dIᵢ/dVⱼ from contacts i,j, in units of e^2/h\n  Current contact  : 1\n  Bias contact     : 1\n\njulia> Gω = @showprogress  [G₁₁(ω) for ω in ωs];\nProgress: 100%|██████████████████████████████████████████████████████████████| Time: 0:01:01\n\njulia> f = Figure(); a = Axis(f[1,1], xlabel = \"eV/t\", ylabel = \"G [e²/h]\"); lines!(a, ωs, Gω); f","category":"page"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"<img src=\"../../assets/four_terminal_cond.png\" alt=\"Local conductance from right contact\" width=\"400\" class=\"center\"/>","category":"page"},{"location":"tutorial/observables/","page":"Observables","title":"Observables","text":"!! warning \"Sign of non-local conductance\"     If you compute a non-local conductance such as conductance(g[2,1])(ω) in this example you will note it is negative. This is actually expected. It means that the current flowing into the system through the right contact when you increase the bias in a different contact is negative, because the current is actually flowing out into the right reservoir.","category":"page"},{"location":"tutorial/observables/#Josephson","page":"Observables","title":"Josephson","text":"","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"tutorial/models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"We now will show how to build a generic single-particle tight-binding model, with generic Hamiltonian","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"H = sum_ialpha jbeta c_ialpha^dagger V_alphabeta(r_i r_j)c_jalpha","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"Here, α,β are orbital indices in each site, i,j are site indices, and rᵢ, rⱼ are site positions. In Quantica.jl we would write the above model as","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"julia> model = onsite(r -> V(r, r)) + hopping((r, dr) -> V(r-dr/2, r+dr/2))\nTightbindingModel: model with 2 terms\n  OnsiteTerm{Function}:\n    Region            : any\n    Sublattices       : any\n    Cells             : any\n    Coefficient       : 1\n  HoppingTerm{Function}:\n    Region            : any\n    Sublattice pairs  : any\n    Cell distances    : any\n    Hopping range     : Neighbors(1)\n    Reverse hops      : false\n    Coefficient       : 1","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"where V(rᵢ, rⱼ) is a function that returns a matrix (ideally an SMatrix) V_alphabeta(r_i r_j) of the required orbital dimensionality.","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"Note that when writing models we distinguish between onsite (rᵢ=rⱼ) and hopping (rᵢ≠rⱼ) terms. For the former, r is the site position. For the latter we use a bond-center and bond-distance (r, dr) parametrization of V, so that r₁, r₂ = r ∓ dr/2","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"If the onsite and hopping amplitudes do not depend on position, we can simply use constants","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"julia> model = onsite(1) - 2*hopping(1)\nTightbindingModel: model with 2 terms\n  OnsiteTerm{Int64}:\n    Region            : any\n    Sublattices       : any\n    Cells             : any\n    Coefficient       : 1\n  HoppingTerm{Int64}:\n    Region            : any\n    Sublattice pairs  : any\n    Cell distances    : any\n    Hopping range     : Neighbors(1)\n    Reverse hops      : false\n    Coefficient       : -2","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"tip: Model term algebra\nNote that we can combine model terms as in the above example by summing and subtracting them, and using constant coefficients.","category":"page"},{"location":"tutorial/models/#HopSelectors","page":"Models","title":"HopSelectors","text":"","category":"section"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"By default onsite terms apply to any site in a Lattice, and hopping terms apply to any pair of sites within nearest-neighbor distance (see the Hopping range: Neighbors(1) above).","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"We can change this default by specifying a SiteSelector or HopSelector for each term. SiteSelectors where already introduced to create LatticeSlices. HopSelectors are very similar, but support slightly different keywords:","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"region: to restrict according to bond center r and bond vector dr\nsublats: to restrict source and target sublattices\ndcells: to restrict the distance in cell index\nrange: to restrict the distance in real space","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"As an example, a HopSelector that selects any two sites at a distance between 1.0 and the second-nearest neighbor distance, with the first belonging to sublattice :B and the second to sublattice :A, and their bond center inside a unit circle","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"julia> hs = hopselector(range = (1.0, neighbors(2)), sublats = :B => :A, region = (r, dr) -> norm(r) < 1)\nHopSelector: a rule that defines a finite collection of hops between sites in a lattice\n  Region            : Function\n  Sublattice pairs  : :B => :A\n  Cell distances    : any\n  Hopping range     : (1.0, Neighbors(2))\n  Reverse hops      : false","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"We can now use this HopSelector to restrict the hoppings in a model, just as SiteSelectors can be used to restrict onsite terms","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"julia> model = plusadjoint(hopping(1, hs)) - 2*onsite(1, sublats = :B)\nTightbindingModel: model with 3 terms\n  HoppingTerm{Int64}:\n    Region            : Function\n    Sublattice pairs  : :B => :A\n    Cell distances    : any\n    Hopping range     : (1.0, Neighbors(2))\n    Reverse hops      : false\n    Coefficient       : 1\n  HoppingTerm{Int64}:\n    Region            : Function\n    Sublattice pairs  : :B => :A\n    Cell distances    : any\n    Hopping range     : (1.0, Neighbors(2))\n    Reverse hops      : true\n    Coefficient       : 1\n  OnsiteTerm{Int64}:\n    Region            : any\n    Sublattices       : B\n    Cells             : any\n    Coefficient       : 1","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"Note that we can pass the Selector itself as a second argument to hopping and onsite, or alternatively use selector keywords directly as in the onsite above.","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"tip: plusadjoint function\nThe convenience function plusadjoint(term) = term + term' adds the Hermitian conjugate of its argument (term'), equivalent to the + h.c. notation often used in the literature.","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"note: Index-agnostic modeling\nThe Quantica.jl approach to defining tight-binding models does not rely explicitly on site indices (i,j above), since these are arbitrary, and may even be beyond the control of the user (for example after using supercell). Instead, we rely on physical properties of sites, such as position, distance or sublattice.","category":"page"},{"location":"tutorial/models/#Parametric-Models","page":"Models","title":"Parametric Models","text":"","category":"section"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"The models introduced above are non-parametric, in the sense that they encode fixed, numerical Hamiltonian matrix elements. In many problems, it is commonplace to have models that depend on a number of free parameters that will need to be adjusted during a calculation. For example, one may need to compute the phase diagram of a system as a function of a spin-orbit coupling or an applied magnetic field. For these cases, we have ParametricModels.","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"Parametric models are defined with","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"@onsite((; params...) -> ...; sites...)\n@onsite((r; params...) -> ...; sites...)\n@hopping((; params...) -> ...; hops...)\n@hopping((r, dr; params...) -> ...; hops...)","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"where the params keyword arguments define the free parameters, together with (optional) default values. Here is an example of a hopping model with a Peierls phase in the symmetric gauge, with the magnetic field Bz and the zero-field hopping t as free parameters","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"julia> model_perierls = @hopping((r, dr; Bz = 0, t = 1) -> t * cis(-im * Bz/2 * SA[-r[2], r[1], 0]' * dr))\nParametricModel: model with 1 term\n  ParametricHoppingTerm{ParametricFunction{2}}\n    Region            : any\n    Sublattice pairs  : any\n    Cell distances    : any\n    Hopping range     : Neighbors(1)\n    Reverse hops      : false\n    Coefficient       : 1\n    Parameters        : [:B, :t]","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"One can linearly combine parametric and non-parametric models freely, omit parameter default values, and use any of the functional argument forms described for onsite and hopping (although not the constant argument form):","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"julia> model´ = 2 * (onsite(1) - 2 * @hopping((; t) -> t))\nParametricModel: model with 2 terms\n  ParametricHoppingTerm{ParametricFunction{0}}\n    Region            : any\n    Sublattice pairs  : any\n    Cell distances    : any\n    Hopping range     : Neighbors(1)\n    Reverse hops      : false\n    Coefficient       : -4\n    Parameters        : [:t]\n  OnsiteTerm{Int64}:\n    Region            : any\n    Sublattices       : any\n    Cells             : any\n    Coefficient       : 2","category":"page"},{"location":"tutorial/models/#Modifiers","page":"Models","title":"Modifiers","text":"","category":"section"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"There is a third model-related functionality known as OnsiteModifiers and HoppingModifiers. Given a model that defines a set of onsite and hopping amplitudes on a subset of sites and hops, one can define a parameter-dependent modification of a subset of said amplitudes. This is a useful way to introduce a new parameter dependence on an already defined model. Modifiers are built with","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"@onsite!((o; params...) -> new_onsite; sites...)\n@onsite!((o, r; params...) -> new_onsite; sites...)\n@hopping((t; params...) -> new_hopping; hops...)\n@hopping((t, r, dr; params...) -> new_hopping; hops...)","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"where the first argument o and t is the unmodified value of the onsite or hopping amplitude, respectively. Here sites and hops are once more keyword arguments to restrict the modification with a SiteSelector or HopSelector.","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"For example, the following HoppingModifier inserts a Peierls phase on all the hopping in a given model","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"julia> model_perierls! = @hopping!((t, r, dr; B = 0) -> t * cis(-Bz/2 * SA[-r[2], r[1], 0]' * dr))\nHoppingModifier{ParametricFunction{3}}:\n  Region            : any\n  Sublattice pairs  : any\n  Cell distances    : any\n  Hopping range     : Inf\n  Reverse hops      : false\n  Parameters        : [:B]","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"The difference with model_perierls is that model_perierls! will never add any new hoppings. It will only modify previously existing hoppings in a model. Modifiers are not models themselves, and cannot be summed to other models. They are instead meant to be applied sequentially after applying a model.","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"In the next section we show how models and modifiers can be used in practice to construct Hamiltonians.","category":"page"},{"location":"tutorial/models/","page":"Models","title":"Models","text":"note: Mind the `;`\nWhile syntax like onsite(2, sublats = :B) and onsite(2; sublats = :B) are equivalent in Julia, due to the way keyword arguments are parsed, the same is not true for macro calls like @onsite, @onsite!, @hopping and @hopping!. These macros just emulate the function call syntax. But to work you must currently always use the ; separator for keywords. Hence, something like @onsite((; p) -> p; sublats = :B) works, but @onsite((; p) -> p, sublats = :B) does not.","category":"page"},{"location":"tutorial/bandstructures/#Bandstructures","page":"Bandstructures","title":"Bandstructures","text":"","category":"section"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"The eigenpairs (eigenvalues and eigenvectors) of a Hamiltonian or ParametricHamiltonian at given Bloch phases ϕᵢ can be obtained with spectrum:","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"julia> h = LP.honeycomb() |> hopping(1); ϕᵢ = (0, π);\n\njulia> eᵢ, ψᵢ = spectrum(h, ϕᵢ; solver = EigenSolvers.LinearAlgebra())\nSpectrum{Float64,ComplexF64} :\nEnergies:\n2-element Vector{ComplexF64}:\n -1.0 + 0.0im\n  1.0 + 0.0im\nStates:\n2×2 Matrix{ComplexF64}:\n  0.707107-8.65956e-17im  0.707107-8.65956e-17im\n -0.707107+0.0im          0.707107+0.0im","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"The above destructuring syntax assigns eigenvalues and eigenvectors to eᵢ and ψᵢ, respectively. The available eigensolvers and their options can be checked in the EigenSolvers docstrings.","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"We define a \"bandstructure\" of an h::AbstractHamiltonian as a linear interpolation of its eigenpairs over a portion of the Brillouin zone, which is discretized with a base mesh of ϕᵢ values. At each ϕᵢ of the base mesh, the Bloch matrix h(ϕᵢ) is diagonalized with spectrum. The adjacent eigenpairs eⱼ(ϕᵢ), ψⱼ(ϕᵢ) are then connected (\"stitched\") together into a number of band meshes with vertices (ϕᵢ..., eⱼ(ϕᵢ)) by maximizing the overlap of adjacent ψⱼ(ϕᵢ) (since the bands should be continuuous). Degenerate eigenpairs are collected into a single node of the band mesh.","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"The bandstructure of an h::AbstractHamiltonian is computed using bands:","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"julia> ϕ₁points = ϕ₂points = range(0, 2π, length = 19);\n\njulia> b = bands(h, ϕ₁points, ϕ₂points)\nBandstructure{Float64,3,2}: 3D Bandstructure over a 2-dimensional parameter space of type Float64\n  Subbands  : 1\n  Vertices  : 720\n  Edges     : 2016\n  Simplices : 1296","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"The first argument is the AbstractHamiltonian. Here it is defined on an L=2 dimensional lattice. The subsequent arguments are collections of Bloch phases on each of the L axes of the Brillouin zone, whose direct product ϕ₁points ⊗ ϕ₂points defines our base mesh of ϕᵢ points. Here it is a uniform 19×19 grid. We can once more use qplot to visualize the bandstructure, or more precisely the band meshes:","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"julia> using GLMakie; qplot(b, inspector = true)","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"<img src=\"../../assets/graphene_bands.png\" alt=\"Graphene bands\" width=\"400\" class=\"center\"/>","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"The dots on the bands are the band mesh vertices (ϕᵢ..., eⱼ(ϕᵢ)). They can be omitted with the qplot keyword hide = :nodes (or hide = :vertices, both are equivalent).","category":"page"},{"location":"tutorial/bandstructures/#Band-defects","page":"Bandstructures","title":"Band defects","text":"","category":"section"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"Note that the uniform grid contains the Dirac points. This is the reason for the number 19 of Bloch phases used above. Note also that it is identified as a point in the bands with degeneracy = 2 (the rest have degeneracy = 1). As mentioned, the points on the bands are connected based on eigenstate overlaps between adjacent ϕᵢs. This interpolation algorithm can deal with subspace degeneracies, as here. However, Dirac points (and Diabolical Points in general) must belong to the mesh for the method to work. If the number of points is reduced to 18 per axis, the Dirac points become unavoidable band dislocations, that appear as missing simplices in the bands:","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"<img src=\"../../assets/graphene_bands_bad.png\" alt=\"Graphene bands with Dirac point dislocation\" width=\"400\" class=\"center\"/>","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"tip: Advanced: band defects and patching\nIf a Dirac point or other type of band dislocation point happens to not belong to the sampling grid, it can be added with the bands keyword defects. Then, it can be reconnected with the rest of the band by increasing the patches::Integer keyword (see bands docstring for details). This \"band repair\" functionality is experimental, and should only be necessary in some cases with Diabolical Points.","category":"page"},{"location":"tutorial/bandstructures/#Coordinate-mapping-and-band-linecuts","page":"Bandstructures","title":"Coordinate mapping and band linecuts","text":"","category":"section"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"The direct product of the ϕᵢpoints above define a rectangular mesh over which we want to compute the bandstructure. By default, this mesh is taken as a discretization of Bloch phases, so h(ϕᵢ) is diagonalized at each point of the base mesh. We might want, however, a different relation between the mesh and the parameters passed to h, for example if we wish to use wavevectors k instead of Bloch phases ϕᵢ = k⋅Aᵢ for the mesh. This is achieved with the mapping keyword, which accepts a function mapping = (mesh_points...) -> bloch_phases,","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"julia> h = LP.honeycomb() |> hopping(2); k₁points = range(-2π, 2π, length = 51); k₂points = range(-2π, 2π, length = 51);\n\njulia> Kpoints = [SA[cos(θ) -sin(θ); sin(θ) cos(θ)] * SA[4π/3,0] for θ in range(0, 5*2π/6, length = 6)];\n\njulia> ϕ(k...) =  SA[k...]' * bravais_matrix(h)\nϕ (generic function with 1 method)\n\njulia> b = bands(h,  k₁points, k₂points; mapping = ϕ, defects = Kpoints, patches = 20);\n\njulia> using GLMakie; qplot(b, hide = (:nodes, :wireframe), color = :orange)","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"<img src=\"../../assets/graphene_bands_k.png\" alt=\"Graphene bands in k-space\" width=\"400\" class=\"center\"/>","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"To compute a bandstructure linecut along a polygonal line in the Brillouin zone, we could once more use the mapping functionality, mapping a set of points xᵢ::Real in the mesh to Bloch phases ϕᵢ that defines the nodes of the polygonal path, and interpolating linearly between them. To avoid having to construct this mapping ourselves, mapping accepts a second type of input for this specific usecase, mapping = xᵢ => ϕᵢ. Here, ϕᵢ can be a collection of Tuples, SVector{L}, or even Symbols denoting common names for high-symmetry points in the Brillouin zone, such as :Γ, :K, :K´, :M, :X, :Y, and :Z. The following gives a Γ-K-M-Γ linecut for the bands above, where the (Γ, K, M, Γ) points lie at x = (0, 2, 3, 4), respectively, with 10 subdivisions in each segment,","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"julia> b = bands(h, subdiv((0, 2, 3, 4), 10); mapping = (0, 2, 3, 4) => (:Γ, :K, :M, :Γ));\n\njulia> qplot(b, axis = (; xticks = ([0, 2, 3, 4], [\"Γ\", \"K\", \"M\", \"Γ\"]), ylabel = \"ϵ\"))","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"<img src=\"../../assets/graphene_bands_linecut.png\" alt=\"Graphene bands along a Γ-K-M-Γ cut\" width=\"400\" class=\"center\"/>","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"tip: subdiv\nThe subdiv function is a convenience function provided by Quantica.jl that generalizes range (see the corresponding docstring for comprehensive details). It is useful to create collections of numbers as subdivisions of intervals, as in the example above. In its simplest form subdiv(min, max, npoints) is is equivalent to range(min, max, length = npoints) or collect(LinRange(min, max, npoints))","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"The mapping keyword understand a third syntax that can be used to map a mesh to the space of Bloch phases and parameters of a ParametricHamiltonian. To this end we use mapping = (mesh_points...) -> ftuple(bloch_phases...; params...). The ftuple function creates a FrankenTuple, which is a hybrid between a Tuple and a NamedTuple. For example, in the following 1D SSH chain we can compute the bandstructure as a function of Bloch phase ϕ and hopping t´, and plot it using more customization options","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"julia> h = LP.linear() |> supercell(2) |> @hopping((r, dr; t = 1, t´ = 1) -> iseven(r[1]-1/2) ? t : t´);\n\njulia> b = bands(h, subdiv(0, 2π, 11), subdiv(0, 10, 11), mapping = (ϕ, y) -> ftuple(ϕ; t´ = y/5), patches = 20)\nBandstructure{Float64,3,2}: 3D Bandstructure over a 2-dimensional parameter space of type Float64\n  Subbands  : 1\n  Vertices  : 249\n  Edges     : 664\n  Simplices : 416\n\njulia> qplot(b, nodedarken = 0.5, axis = (; aspect = (1,1,1), perspectiveness = 0.5, xlabel = \"ϕ\", ylabel = \"t´/t\", zlabel = \"ϵ\"), fancyaxis = false)","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"<img src=\"../../assets/ssh_bands.png\" alt=\"SSH bandstructure as a function of `ϕ` and `t´/t\" width=\"400\" class=\"center\"/>","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"Note that since we didn't specify a value for t, it assumed its default t=1. In this case we needed to patch the defect at (ϕ, t´) = (π, 1) (topological transition) using the patches keyword to avoid a band dislocation.","category":"page"},{"location":"tutorial/bandstructures/#Band-indexing-and-slicing","page":"Bandstructures","title":"Band indexing and slicing","text":"","category":"section"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"The individual subbands in a given b::Bandstructure can be obtained with b[inds] with inds::Integer or inds::Vector, just as if b where a normal AbstractVector. The extracted subbands can also be plotted directly. The following example has 12 subbands, of which we extract and plot the first and last","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"julia> h = LP.triangular() |> supercell(4) |> hopping(1) + onsite(r -> 4*rand());\n\njulia> b = bands(h, subdiv(0, 2π, 31), subdiv(0, 2π, 31))\nBandstructure{Float64,3,2}: 3D Bandstructure over a 2-dimensional parameter space of type Float64\n  Subbands  : 12\n  Vertices  : 15376\n  Edges     : 44152\n  Simplices : 28696\n\njulia> qplot(b, hide = (:nodes, :wireframe))\n\njulia> qplot(b[[1, end]], hide = (:nodes, :wireframe))","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"<img src=\"../../assets/bands_indexed.png\" alt=\"Extracting and plotting a subset of the subbands in a bandstructure\" width=\"600\" class=\"center\"/>","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"For a band in a 2D Brillouin zone, we can also obtain the intersection of a bandstructure with a plane of constant energy ϵ=2 using the syntax b[(:,:,2)]. A section at fixed Bloch phase ϕ₁=0 (or mesh coordinate x₁=0 if mapping was used), can be obtained with b[(0,:,:)]. This type of band slicing can be generalized to higher dimensional bandstructures, or to more than one constrain (e.g. energy and/or a subset of Bloch phases). As an example, this would be the Fermi surface of a nearest-neighbor cubic-lattice Hamiltonian at Fermi energy µ = 0.2t","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"julia> pts = subdiv(0, 2π, 41); b = LP.cubic() |> hopping(1) |> bands(pts, pts, pts)\nBandstructure{Float64,4,3}: 4D Bandstructure over a 3-dimensional parameter space of type Float64\n  Subbands  : 1\n  Vertices  : 68921\n  Edges     : 462520\n  Simplices : 384000\n\njulia> qplot(b[(:, :, :, 0.2)], hide = (:nodes, :wireframe))","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"<img src=\"../../assets/cubic_Fermi_surface.png\" alt=\"Fermi surface of a cubic crystal at `µ = 0.2t`\" width=\"400\" class=\"center\"/>","category":"page"},{"location":"tutorial/bandstructures/","page":"Bandstructures","title":"Bandstructures","text":"warning: On simplex orientation of bandstructure slices\nThe above example showcases a current (cosmetic) limitation of the band slicing algorithm: it sometimes fails to align all faces of the resulting manifold to the same orientation. The dark and bright regions of the surface above reveals that approximately half of the faces in this case are facing inward and the rest outward.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Quantica.jl logo)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Quantica.jl is a Julia package for building generic tight-binding models and computing spectral and transport properties.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"Quantica\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Quantica.jl requires Julia v1.9 or later. Some of its functionality, notably plotting, will become available only after using GLMakie, or some other plotting package from the Makie.jl family. Install GLMakie with","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"GLMakie\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, to begin using Quantica, just load it by doing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Quantica","category":"page"},{"location":"","page":"Home","title":"Home","text":"(and possibly also e.g. using GLMakie if you need to plot Quantica objects).","category":"page"},{"location":"#Asking-questions,-reporting-bugs","page":"Home","title":"Asking questions, reporting bugs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you encounter problems, please read the tutorial and examples, your question is probably answered there. You can also check the docstring of each Quantica.jl function here or within the Julia REPL, by entering the function preceded by a ?, e.g. ?hamiltonian.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are still stuck, you may sometimes find me (@pablosanjose) at the Julia Slack or Julia Discourse.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you believe you found a bug in Quantica.jl, please don't hesitate to file a GitHub issue, preferably with detailed instructions to reproduce it. Pull requests with fixes are also welcome!","category":"page"}]
}
