var documenterSearchIndex = {"docs":
[{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = Quantica","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Quantica]","category":"page"},{"location":"reference/#Quantica.Quantica","page":"Reference","title":"Quantica.Quantica","text":"Quantica.jl\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: GitHub commits since last release)\n\nThe Quantica.jl package provides an expressive API to build arbitrary quantum systems on a discrete lattice, and to compute a number of their properties.\n\nSome current features\n\nBuild Hamiltonians on discrete lattices of arbitrary dimensions, using tight-binding models with arbitrary number of orbitals\nCompute band structures of periodic systems and extract individual bands by interpolation\nCompute electronic structures and expectation values using Kernel Polynomial methods\n\nExported API\n\nlattice, sublat: build lattices\nhopping, onsite, siteselector, hopselector, nrange, not: build tightbinding models\nhamiltonian: build a Hamiltonian from tightbinding model and a lattice\nbloch, bloch!, similarmatrix: build the Bloch matrix of a Hamiltonian\nparametric, @onsite!, @hopping!, parameters: build a parametric Hamiltonian\ndims, sitepositions, siteindices, bravais: inspect lattices and Hamiltonians\nsupercell, unitcell, wrap, transform!, combine: build derived lattices or Hamiltonians\nflatten, unflatten, orbitalstructure: operate with multiorbital Hamiltonian or Subspaces\ncuboid: build a bandstructure discretization mesh\nbandstructure, spectrum, diagonalizer: compute the generalized bandstructure of a Hamiltonian or a ParametricHamiltonian\nbands, energies, states: inspect spectrum and bandstructure objects\nmomentaKPM, dosKPM, averageKPM, densityKPM, bandrangeKPM: Kernel Polynomial Method (KPM)\nket, randomkets: define ket models for use in e.g. KPM routines\ngreens, greensolver: build Green's functions of a Hamiltonian\n\nSome of this functionality require loading one or more third-party packages, which include the following:\n\nKPM: FFTW, ArnoldiMethod\nBandstructures: Arpack, ArnoldiMethod, KrylovKit\n\nThe user is told when this is needed. We do this to reduce dependencies and launch time with packages whose functionality is not essential for the use of Quantica.jl\n\nOther functions become available after loading specific third-party packages:\n\nMakie: enables plot(::Hamiltonian) and plot(::Bandstructure) (for 1D and 2D bandstructures)\nVegaLite: enables vlplot(::Hamiltonian) and vlplot(::Bandstructure) (for 1D bandstructures)\n\nFunding\n\nThis work has been partly funded by the Spanish Ministry of Economy and Competitiveness under Grant Nos. FIS2015-65706-P, PCI2018-093026, and the CSIC Intramural Project 201760I086.\n\n\n\n\n\n","category":"module"},{"location":"reference/#Base.Matrix-Tuple{Quantica.KetModel,Quantica.Hamiltonian}","page":"Reference","title":"Base.Matrix","text":"Matrix(km::KetModel, h::Hamiltonian)   Matrix(kms::NTuple{N,KetModel}, h::Hamiltonian)   Matrix(kms::AbstractMatrix, h::Hamiltonian)   Matrix(kms::StochasticTraceKets, h::Hamiltonian)\n\nConstruct an M×N Matrix representation of the N kets kms applied to M×M Hamiltonian h. If kms::StochasticTraceKets for n random kets (constructed with randomkets(n)), a normalization 1/√n required for stochastic traces is included.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.Vector-Tuple{Quantica.KetModel,Quantica.Hamiltonian}","page":"Reference","title":"Base.Vector","text":"Vector(km::KetModel, h::Hamiltonian)\n\nConstruct a Vector representation of km applied to Hamiltonian h.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.BoxIterator","page":"Reference","title":"Quantica.BoxIterator","text":"BoxIterator(seed::SVector{N,Int}; maxiterations = missing)\n\nCartesian iterator iter over SVector{N,Int}s (cells) that starts at seed and grows outwards in the form of a box of increasing sides (not necesarily equal) until it encompasses a certain N-dimensional region. To signal that a cell is in the desired region the user calls acceptcell!(iter, cell).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.:&-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O<:Quantica.OrbitalStructure where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s38<:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O<:Quantica.OrbitalStructure where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s37<:Quantica.Superlattice}","page":"Reference","title":"Base.:&","text":"&(h1::Hamiltonian{<:Superlattice}, h2::Hamiltonian{<:Superlattice})\n\nConstruct a new Hamiltonian{<:Superlattice} using an and boolean mask, i.e. with a supercell that contains cells that are both in the supercell of h1 and h2\n\n&(s1::Superlattice, s2::Superlattice}\n\nEquivalent of the above for Superlattices\n\nSee also\n\n`|`, `xor`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:|-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O<:Quantica.OrbitalStructure where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s38<:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O<:Quantica.OrbitalStructure where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s37<:Quantica.Superlattice}","page":"Reference","title":"Base.:|","text":"|(h1::Hamiltonian{<:Superlattice}, h2::Hamiltonian{<:Superlattice})\n\nConstruct a new Hamiltonian{<:Superlattice} using an or boolean mask, i.e. with a supercell that contains cells that are either in the supercell of h1 or h2\n\n|(s1::Superlattice, s2::Superlattice}\n\nEquivalent of the above for Superlattices\n\nSee also\n\n`&`, `xor`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.xor-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O<:Quantica.OrbitalStructure where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s38<:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O<:Quantica.OrbitalStructure where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s37<:Quantica.Superlattice}","page":"Reference","title":"Base.xor","text":"xor(h1::Hamiltonian{<:Superlattice}, h2::Hamiltonian{<:Superlattice})\n\nConstruct a new Hamiltonian{<:Superlattice} using a xor boolean mask, i.e. with a supercell that contains cells that are either in the supercell of h1 or h2 but not in both\n\nxor(s1::Superlattice, s2::Superlattice}\n\nEquivalent of the above for Superlattices\n\nSee also\n\n`&`, `|`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.averageKPM-Tuple{Any,Any}","page":"Reference","title":"Quantica.averageKPM","text":"averageKPM(h::Hamiltonian, A; kBT = 0, Ef = 0, kw...)\n\nCompute, using the Kernel Polynomial Method (KPM), the thermal expectation value <A> = Σ_k f(E_k) <k|A|k> = ∫dE f(E) Tr [A δ(E-H)] = Tr [A f(H)] for a given hermitian operator A and a zero-dimensional hamiltonian h (see momentaKPM and its options kw for further details). f(E) is the Fermi-Dirac distribution function, |k⟩ are h eigenstates with energy E_k, kBTis the temperature in energy units andEf` the Fermi energy.\n\naverageKPM(μ::MomentaKPM, A; kBT = 0, Ef = 0)\n\nSame as above with the KPM momenta as input (see momentaKPM).\n\nSee also\n\n`dosKPM`, `momentaKPM`, `averageKPM`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.bands-Tuple{Quantica.Bandstructure}","page":"Reference","title":"Quantica.bands","text":"bands(bs::Bandstructure[, i])\n\nReturn a bands::Vector{Band} of all the bands in bs, or bands[i] if i is given.\n\nSee also\n\n`bandstructure`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.bandstructure-Union{Tuple{Quantica.Hamiltonian{#s36,L,M,A,H,O} where O<:Quantica.OrbitalStructure where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where #s36}, Tuple{L}} where L","page":"Reference","title":"Quantica.bandstructure","text":"bandstructure(h::Hamiltonian; subticks = 13, kw...)\n\nCompute bandstructure(h, cuboid((-π,π)...; subticks = subticks); kw...) using a base mesh (of type CuboidMesh) over h's full Brillouin zone with the specified subticks along each [-π,π] reciprocal axis.\n\nbandstructure(h::Hamiltonian, nodes...; subticks = 13, kw...)\n\nCreate a linecut of a bandstructure of h along a polygonal line connecting two or more nodes. Each node is either a Tuple or SVector of Bloch phases, or a symbolic name for a Brillouin zone point (:Γ,:K, :K´, :M, :X, :Y or :Z). Each segment in the polygon has the specified number of subticks. Different subticks per segments can be specified with subticks = (p1, p2...).\n\nbandstructure(h::Hamiltonian, mesh::CuboidMesh; mapping = missing, kw...)\n\nCompute the bandstructure bandstructure(h, mesh; kw...) of Bloch Hamiltonian bloch(h, ϕ), with ϕ = v taken on each vertex v of the base mesh (or ϕ = mapping(v...) if a mapping function is provided).\n\nbandstructure(ph::ParametricHamiltonian, ...; kw...)\n\nCompute the bandstructure of a ph. Unless all parameters have default values, a mapping is required between mesh vertices and Bloch/parameters for ph, see details on mapping below.\n\nbandstructure(matrixf::Function, mesh::CuboidMesh; kw...)\n\nCompute the bandstructure of the Hamiltonian matrix m = matrixf(ϕ), with ϕ evaluated on the vertices v of the mesh. Note that ϕ in matrixf(ϕ) is an unsplatted container. Hence, i.e. matrixf(x) = ... or matrixf(x, y) = ... will not work. Use matrixf((x,)) = ..., matrixf((x, y)) = ... or matrixf(s::SVector) = ...` instead.\n\nh |> bandstructure([mesh,]; kw...)\n\nCurried form of the above equivalent to bandstructure(h[, mesh]; kw...).\n\nOptions\n\nThe default options are\n\n(mapping = missing, method = LinearAlgebraPackage(), transform = missing, splitbands = true, showprogress = true)\n\nmapping: when not missing, mapping = v -> p is a function that map base mesh vertices v to Bloch phases and/or parameters p. The structure of p is whatever is accepted by bloch(h, p, ...) (see bloch). For h::Hamiltonian, p = ϕs::Union{Tuple,SVector} are Bloch phases. For h::ParametricHamiltonian, p = (ϕs..., (; ps)) or p = (ϕs, (; ps)) combine Bloch phases ϕs and keyword parameters ps of ph. This allows to compute a bandstructure along a cut in the Brillouin zone/parameter space of ph, see examples below.\n\nmethod: it is chosen automatically if unspecified, and can be one of the following\n\nmethod                     diagonalization function\n--------------------------------------------------------------\nLinearAlgebraPackage()     LinearAlgebra.eigen!\nArpackPackage()            Arpack.eigs (must be `using Arpack`)\n\nOptions passed to the method will be forwarded to the diagonalization function. For example, method = ArpackPackage(nev = 8, sigma = 1im) will use Arpack.eigs(matrix; nev = 8, sigma = 1im) to compute the bandstructure.\n\ntransform: the option transform = ε -> fε(ε) allows to transform eigenvalues by fε in the returned bandstructure (useful for performing shifts or other postprocessing). We can also do transform -> (fφ, fε) to transform also mesh vertices with fφ. Additionally, transform -> isometric or transform -> (isometric, fε) will transform mesh vertices into momenta, assuming they represent Bloch phases. This works both in full bandstructures and linecuts.\n\nsplitbands: split all bands into disconnected subbands. See also splitbands!\n\nshowprogress: indicate whether progress bars are displayed during the calculation\n\nIndexing\n\nThe bands in a bs::Bandstructure object can be accessed with bands, while the indexing syntax bs[(φs...)] gives access to one or more sub::Subspace objects, contructed by linear interpolation of each band at base-mesh coordinates φs.\n\nbs[(φs...), 1]                  : first interpolated subspaces at base mesh coordinates `φs`, ordered by energy\nbs[(φs...), 1:3]                : interpolated subspaces 1 to 3 at base mesh coordinates `φs`, ordered by energy\nbs[(φs...)]                     : interpolated subspaces at base mesh coordinates `φs` in any band\nbs[(φs...), around = 0.2]       : the single interpolated subspaces at `φs` with energies closest to 0.2\nbs[(φs...), around = (0.2, 10)] : the ten interpolated subspaces at `φs` with energies closest to 0.2\n\nThe eigenenergy ε and subspace basis ψs of a sub::Subspace can themselves be obtained via destructuring, ε, ψs = sub, or ε = first(sub), ψs = last(sub).\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |> hamiltonian(hopping(-1)) |> unitcell(3);\n\njulia> bandstructure(h; subticks = 25, method = LinearAlgebraPackage())\nBandstructure{2}: collection of 2D bands\n  Bands        : 8\n  Element type : scalar (Complex{Float64})\n  Band{2}: mesh of a 2-dimensional manifold\n    Vertices   : 625\n    Edges      : 1776\n\njulia> bandstructure(h, :Γ, :X, :Y, :Γ; subticks = (10,15,10))\nBandstructure{2}: collection of 1D bands\n  Bands        : 18\n  Element type : scalar (Complex{Float64})\n  Band{1}: mesh of a 1-dimensional manifold\n    Vertices   : 33\n    Edges      : 32\n\njulia> bandstructure(h, mesh((0, 2π); subticks = 13); mapping = φ -> (φ, 0))\n       # Equivalent to bandstructure(h, :Γ, :X; subticks = 13)\nBandstructure{2}: collection of 1D bands\n  Bands        : 18\n  Element type : scalar (Complex{Float64})\n  Band{1}: mesh of a 1-dimensional manifold\n    Vertices   : 11\n    Edges      : 10\n\njulia> ph = parametric(h, @hopping!((t; α) -> t * α));\n\njulia> bandstructure(ph, mesh((0, 2π); subticks = 13); mapping = φ -> (φ, 0, (; α = 2φ)))\nBandstructure{2}: collection of 1D bands\n  Bands        : 18\n  Element type : scalar (Complex{Float64})\n  Band{1}: mesh of a 1-dimensional manifold\n    Vertices   : 11\n    Edges      : 10\n\nSee also\n\n`cuboid`, `diagonalizer`, `bloch`, `parametric`, `splitbands!`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.bloch","page":"Reference","title":"Quantica.bloch","text":"bloch(h::Hamiltonian{<:Lattice}, ϕs)\n\nBuild the Bloch Hamiltonian matrix of h, for Bloch phases ϕs = (ϕ₁, ϕ₂,...) (or an SVector(ϕs...)). In terms of Bloch wavevector k, ϕs = k * bravais(h), it is defined as H(ϕs) = ∑exp(-im * ϕs' * dn) h_dn where h_dn are Bloch harmonics connecting unit cells at a distance dR = bravais(h) * dn.\n\nbloch(h::Hamiltonian{<:Lattice})\n\nBuild the intra-cell Hamiltonian matrix of h, without adding any Bloch harmonics.\n\nbloch(h::Hamiltonian{<:Lattice}, ϕs, axis::Int)\n\nA nonzero axis produces the derivative of the Bloch matrix respect to ϕs[axis] (i.e. the velocity operator along this axis), ∂H(ϕs) = ∑ -im * dn[axis] * exp(-im * ϕs' * dn) h_dn\n\nbloch(matrix, h::Hamiltonian{<:Lattice}, ϕs::NTuple{L,Real}, dnfunc::Function)\n\nGeneralization that applies a prefactor dnfunc(dn) * exp(im * ϕs' * dn) to the dn harmonic.\n\nbloch(ph::ParametricHamiltonian, [pϕs, [axis]])\n\nBuild the Bloch matrix for ph. pϕs = (ϕs, (;kw...)) or pϕs = (ϕs..., (;kw...)) specifies both Bloch phases ϕs and the parameters kw passed to ph(; kw...). If there are no ϕs, the syntax pϕs = (;kw...) is also allowed, which is in that case equivalent to bloch(ph(; kw...)). Similarly, bloch(ph) is equivalent to bloch(ph()).\n\nh |> bloch(ϕs, ...)\nph |> bloch(pϕs, ...)\n\nCurried forms of bloch, equivalent to bloch(h, ϕs, ...) and bloch(ph, pϕs, ...)\n\nNotes\n\nbloch allocates a new matrix on each call. For a non-allocating version of bloch, see bloch!.\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |> hamiltonian(onsite(1) + hopping(2)) |> bloch((0, 0))\n2×2 SparseMatrixCSC{Complex{Float64},Int64} with 4 stored entries:\n  [1, 1]  =  1.0+0.0im\n  [2, 1]  =  6.0+0.0im\n  [1, 2]  =  6.0+0.0im\n  [2, 2]  =  1.0+0.0im\n\nSee also\n\n`bloch!`, `similarmatrix`\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.bloch!","page":"Reference","title":"Quantica.bloch!","text":"bloch!(matrix, h::Hamiltonian, [ϕs, [axis]])\n\nIn-place version of bloch. Overwrite matrix with the Bloch Hamiltonian matrix of h for the specified Bloch phases ϕs = (ϕ₁,ϕ₂,...) (see bloch for definition and API). A conventient way to obtain a matrix is to use similarmatrix(h,matrix_type), which will return an AbstractMatrix of the same type as the Hamiltonian's. Note, however, that matrix need not be of the same type (e.g. it can be dense with Number eltype for a sparse h with SMatrix block eltype).\n\nbloch!(matrix, ph::ParametricHamiltonian, [pϕs, [axis]])\n\nSame as above but with pϕs = (ϕs, (;kw...)), pϕs = (ϕs..., (;kw...)) or pϕs = (;kw...) (see bloch for details).\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |> hamiltonian(hopping(2I), orbitals = (Val(2), Val(1)));\n\njulia> bloch!(similarmatrix(h), h, (0, 0))\n2×2 SparseMatrixCSC{StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4},Int64} with 2 stored entries:\n  [2, 1]  =  [6.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]\n  [1, 2]  =  [6.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]\n\njulia> bloch!(similarmatrix(h, flatten), h, (0, 0))\n3×3 SparseMatrixCSC{Complex{Float64},Int64} with 9 stored entries:\n  [1, 1]  =  0.0+0.0im\n  [2, 1]  =  0.0+0.0im\n  [3, 1]  =  6.0+0.0im\n  [1, 2]  =  0.0+0.0im\n  [2, 2]  =  0.0+0.0im\n  [3, 2]  =  0.0+0.0im\n  [1, 3]  =  6.0+0.0im\n  [2, 3]  =  0.0+0.0im\n  [3, 3]  =  0.0+0.0im\n\njulia> ph = parametric(h, @hopping!((t; α, β = 0) -> α * t + β));\n\njulia> bloch!(similarmatrix(ph, flatten), ph, (0, 0, (; α = 2)))\n3×3 SparseMatrixCSC{Complex{Float64},Int64} with 9 stored entries:\n  [1, 1]  =  0.0+0.0im\n  [2, 1]  =  0.0+0.0im\n  [3, 1]  =  12.0+0.0im\n  [1, 2]  =  0.0+0.0im\n  [2, 2]  =  0.0+0.0im\n  [3, 2]  =  0.0+0.0im\n  [1, 3]  =  12.0+0.0im\n  [2, 3]  =  0.0+0.0im\n  [3, 3]  =  0.0+0.0im\n\nSee also\n\n`bloch`, `similarmatrix`\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.bravais-Tuple{Quantica.AbstractLattice}","page":"Reference","title":"Quantica.bravais","text":"bravais(lat::Lattice)\nbravais(h::Hamiltonian)\n\nObtain the Bravais matrix of lattice lat or Hamiltonian h\n\nExamples\n\njulia> bravais((1.0, 2), (3, 4))\nBravais{2,2,Float64} : set of 2 Bravais vectors in 2D space.\n  Vectors     : ((1.0, 2.0), (3.0, 4.0))\n  Matrix      : [1.0 3.0; 2.0 4.0]\n\nSee also\n\n`lattice`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.combine-Tuple{Vararg{Quantica.Hamiltonian,N} where N}","page":"Reference","title":"Quantica.combine","text":"combine(hams::Hamiltonian...; coupling = missing)\n\nBuild a new Hamiltonian h that combines all hams as diagonal blocks, and applies coupling::Model, if provided, to build the off-diagonal couplings. Note that the diagonal blocks are not modified by the coupling model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.combine-Tuple{Vararg{Quantica.Lattice,N} where N}","page":"Reference","title":"Quantica.combine","text":"combine(lats::Lattice...)\n\nIf all lats have compatible Bravais vectors, combine them into a single lattice. Sublattice names are renamed to be unique if necessary.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.cuboid-Union{Tuple{Vararg{Tuple,L}}, Tuple{L}} where L","page":"Reference","title":"Quantica.cuboid","text":"cuboid(ticks...; subticks = 13)\n\nCreate a CuboidMesh of L-dimensional marching-tetrahedra over a cuboid aligned with the Cartesian axes. The dimension L is given by the number of ticks, each of the form (x₁, x₂,...). The interval between xⱼ and xⱼ₊₁ ticks in axis i are further subdivided to have a number of subticks including endpoints. The number is subticks if subticks is an Integer, subticks[i] if subticks = (s₁, s₂,...) or subticks[i][j] if subticks = ((s₁₁, s₁₂,...), (s₂₁, s₂₂,...), ...).\n\nExamples\n\njulia> cuboid((-π, π), (0, 2π); subticks = 25)\n\njulia> cuboid((-π, π), (0, 2π); subticks = (10, 10))\n\nExternal links\n\nMarching tetrahedra (https://en.wikipedia.org/wiki/Marching_tetrahedra) in Wikipedia\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.degeneracy-Tuple{Quantica.Subspace}","page":"Reference","title":"Quantica.degeneracy","text":"degeneracy(s::Subspace)\n\nReturn the degeneracy of a given energy subspace. It is equal to size(s.basis, 2).\n\nSee also\n\n`spectrum`, `bandstructure`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.densityKPM-Tuple{Any,Any}","page":"Reference","title":"Quantica.densityKPM","text":"densityKPM(h::Hamiltonian, A; resolution = 2, kets = randomkets(1), kw...)\n\nCompute, using the Kernel Polynomial Method (KPM), the spectral density of A for zero-dimensional Hamiltonian h, ρ_A(ϵ) = ∑⟨ket|A δ(ϵ-h)|ket⟩/R ≈ Tr[Aδ(ϵ-h)] (the sum is over R random kets). A can itself be a Hamiltonian or a UniformScaling λ*I. If kets are not randomkets but one or more KetModels (see ket), the division by R is ommitted, which results in a local spectral density ρ_A(ϵ) = ∑⟨ket|Aδ(ϵ-h)|ket⟩ at sites specified by kets.\n\nThe result is a tuple of energy points xk::Vector and real ρ_A::Vector values (unlike for dosKPM, all imaginary parts in ρ_A are preserved), where the number of energy points xk is order * resolution, rounded to the closest integer.\n\ndensityKPM(momenta::MomentaKPM; resolution = 2)\n\nSame as above with the KPM momenta as input (see momentaKPM).\n\nSee also\n\n`dosKPM`, `momentaKPM`, `averageKPM`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.diagonalizer-Tuple{Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian}}","page":"Reference","title":"Quantica.diagonalizer","text":"diagonalizer(h::Union{Hamiltonian,ParametricHamiltonian}; method = LinearAlgebraPackage(), mapping = missing)\n\nBuild a d::Diagonalizer object that, when called as d(φs) , uses the specified diagonalization method to produce the sorted eigenpairs (εs, ψs) of h at Bloch phases/parameters given by mapping. See bandstructure for further details.\n\nA 0D Hamiltonian h also supports d = diagonalizer(h). In this case d can be called with no arguments and gives the same information as spectrum, d() == Tuple(spectrum(h)).\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |> hamiltonian(hopping(1));\n\njulia> d = diagonalizer(h)\nDiagonalizer with method : LinearAlgebraPackage{NamedTuple{(),Tuple{}}}\n\njulia> d((0, 0)) |> first\n2-element Array{Float64,1}:\n -3.0\n  3.0\n\njulia> h = wrap(h); d = diagonalizer(h);\n\njulia> d() == Tuple(spectrum(h))\ntrue\n\nSee also\n\n`bandstructure`, `spectrum`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.dims-Union{Tuple{Quantica.AbstractLattice{E,L,T} where T}, Tuple{L}, Tuple{E}} where L where E","page":"Reference","title":"Quantica.dims","text":"dims(lh::Union{Hamiltonian,AbstractLattice}) -> (E, L)\n\nReturn a tuple (E, L) of the embedding E and lattice dimensions L of AbstractLattice or Hamiltonian lh\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.dosKPM-Tuple{Any}","page":"Reference","title":"Quantica.dosKPM","text":"dosKPM(h::Hamiltonian; resolution = 2, kets = randomkets(1), kw...)\n\nCompute, using the Kernel Polynomial Method (KPM), the density of states per site of zero-dimensional Hamiltonian h, ρ(ϵ) = ∑⟨ket|δ(ϵ-h)|ket⟩/(NR) ≈ Tr[δ(ϵ-h)]/N (N is the number of sites, and the sum is over R random kets). If kets are not randomkets but one or more KetModels (see ket), the division by NR is ommitted, which results in a local density of states ρ(ϵ) = ∑⟨ket|δ(ϵ-h)|ket⟩ at sites specified by kets.\n\nThe result is a tuple of energy points xk::Vector and real ρ::Vector values (any residual imaginary part in ρ is dropped), where the number of energy points xk is order * resolution, rounded to the closest integer.\n\ndosKPM(μ::MomentaKPM; resolution = 2)\n\nSame as above with KPM momenta μ as input. Equivalent to densityKPM(μ; kw...) except that imaginary parts are dropped.\n\nSee also\n\n`momentaKPM`, `densityKPM`, `averageKPM`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.flatten-Tuple{}","page":"Reference","title":"Quantica.flatten","text":"flatten(h::Hamiltonian)\n\nFlatten a multiorbital Hamiltonian h into one with a single orbital per site. The associated lattice is flattened also, so that there is one site per orbital for each initial site (all at the same position). Note that in the case of sparse Hamiltonians, zeros in hopping/onsite matrices are preserved as structural zeros upon flattening.\n\nflatten(s::Subspace)\n\nRebuild s by flattening its basis to have a scalar eltype.\n\nh |> flatten()\n\nCurried form equivalent to flatten(h) of h |> flatten (included for consistency with the rest of the API).\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |>\n           hamiltonian(hopping(@SMatrix[1; 2], range = 1/√3, sublats = :A =>:B),\n           orbitals = (Val(1), Val(2)))\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 × 2\n  Orbitals         : ((:a,), (:a, :a))\n  Element type     : 2 × 2 blocks (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 3\n  Coordination     : 1.5\n\njulia> flatten(h)\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)\n  Harmonic size    : 3 × 3\n  Orbitals         : ((:flat,), (:flat,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 2.0\n\nSee also\n\n`unflatten`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.greens-Tuple{Any,Any}","page":"Reference","title":"Quantica.greens","text":"greens(h::Hamiltonian, solveobject)\n\nConstruct the Green's function g::GreensFunction of h using the provided solveobject. Currently valid solveobjects are\n\nthe Bandstructure of h (for an unbounded h or an Hamiltonian{<:Superlattice}})\nthe Spectrum of h (for a bounded h)\nh |> greens(h -> solveobject(h))\n\nCurried form equivalent to the above, giving greens(h, solveobject(h)) (see example below).\n\ng([m,] ω, cells::Pair = missing)\n\nFrom a constructed g::GreensFunction, obtain the retarded Green's function matrix at frequency ω between unit cells src and dst by calling g(ω, src => dst), where src, dst are ::NTuple{L,Int} or SVector{L,Int}. If cells is missing, src and dst are assumed to be zero vectors. For performance, one can use a preallocated matrix m (e.g. m = similarmatrix(h)) by calling g(m, ω, cells).\n\nExamples\n\njulia> g = LatticePresets.square() |> hamiltonian(hopping(-1)) |> greens(bandstructure(resolution = 17))\nGreensFunction{Bandstructure}: Green's function from a 2D bandstructure\n  Matrix size    : 1 × 1\n  Element type   : scalar (Complex{Float64})\n  Band simplices : 512\n\njulia> g(0.2)\n1×1 Array{Complex{Float64},2}:\n 6.663377810046025 - 24.472789025006396im\n\njulia> m = similarmatrix(g); g(m, 0.2)\n1×1 Array{Complex{Float64},2}:\n 6.663377810046025 - 24.472789025006396im\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.hamiltonian-Tuple{Quantica.AbstractLattice,Vararg{Any,N} where N}","page":"Reference","title":"Quantica.hamiltonian","text":"hamiltonian(lat, model; orbitals, orbtype)\n\nCreate a Hamiltonian by applying model::TighbindingModel to the lattice lat (see hopping and onsite for details on building tightbinding models).\n\nlat |> hamiltonian(model; kw...)\n\nCurried form of hamiltonian equivalent to hamiltonian(lat, model; kw...).\n\nKeywords\n\nThe number of orbitals on each sublattice can be specified by the keyword orbitals (otherwise all sublattices have one orbital by default). The following, and obvious combinations, are possible formats for the orbitals keyword:\n\norbitals = :a                # all sublattices have 1 orbital named :a\norbitals = (:a,)             # same as above\norbitals = (:a, :b, 3)       # all sublattices have 3 orbitals named :a and :b and :3\norbitals = ((:a, :b), (:c,)) # first sublattice has 2 orbitals, second has one\norbitals = ((:a, :b), :c)    # same as above\norbitals = (Val(2), Val(1))  # same as above, with automatic names\norbitals = (:A => (:a, :b), :D => :c) # sublattice :A has two orbitals, :D and rest have one\norbitals = :D => Val(4)      # sublattice :D has four orbitals, rest have one\n\nThe matrix sizes of tightbinding model must match the orbitals specified. Internally, we define a block size N = max(num_orbitals). If N = 1 (all sublattices with one orbital) the Hamiltonian element type is orbtype. Otherwise it is SMatrix{N,N,orbtype} blocks, padded with the necessary zeros as required. Keyword orbtype is Complex{T} by default, where T is the number type of lat.\n\nIndexing\n\nIndexing into a Hamiltonian h works as follows. Access the HamiltonianHarmonic matrix at a given dn::NTuple{L,Int} with h[dn]. Assign v into element (i,j) of said matrix with h[dn][i,j] = v or h[dn, i, j] = v. Broadcasting with vectors of indices is and js is supported, h[dn][is, js] = v_matrix.\n\nTo add an empty harmonic with a given dn::NTuple{L,Int}, do push!(h, dn). To delete it, do deleteat!(h, dn).\n\nExamples\n\njulia> h = hamiltonian(LatticePresets.honeycomb(), hopping(@SMatrix[1 2; 3 4], range = 1/√3), orbitals = Val(2))\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 × 2\n  Orbitals         : ((:a, :a), (:a, :a))\n  Element type     : 2 × 2 blocks (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 3.0\n\njulia> push!(h, (3,3)) # Adding a new Hamiltonian harmonic (if not already present)\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 6 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 × 2\n  Orbitals         : ((:a, :a), (:a, :a))\n  Element type     : 2 × 2 blocks (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 3.0\n\njulia> h[(3,3)][1,1] = @SMatrix[1 2; 2 1]; h[(3,3)] # element assignment\n2×2 SparseMatrixCSC{StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4},Int64} with 1 stored entry:\n  [1, 1]  =  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]\n\njulia> h[(3,3)][[1,2],[1,2]] .= Ref(@SMatrix[1 2; 2 1])\n2×2 view(::SparseMatrixCSC{StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4},Int64}, [1, 2], [1, 2]) with eltype StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4}:\n [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]\n [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]\n\nSee also\n\n`onsite`, `hopping`, `bloch`, `bloch!`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.hopping-Tuple{Any}","page":"Reference","title":"Quantica.hopping","text":"hopping(t; range = nrange(1), dn = missing, sublats = missing, indices = missing, region = missing, plusadjoint = false)\n\nCreate an TightbindingModel with a single HoppingTerm that applies a hopping t to a Lattice when creating a Hamiltonian with hamiltonian.\n\nThe hopping amplitude t can be a number, an SMatrix, a UniformScaling (e.g. 3*I) or a function of the form (r, dr) -> ... for a position-dependent hopping (r is the bond center, and dr the bond vector). If sublats is specified as a sublattice name pair, or tuple thereof, hopping is only applied between sublattices with said names.\n\nThe dimension of t::AbstractMatrix must match the orbital dimension of applicable sublattices (see also orbitals option for hamiltonian). If t::UniformScaling it will be converted to a (possibly rectangular) identity matrix of the appropriate size when applied to multiorbital sublattices. Similarly, if t::SMatrix it will be truncated or padded to the appropriate size.\n\nOnsiteTerms and HoppingTerms created with onsite or hopping can be added or substracted together to build more complicated TightbindingModels.\n\nhopping(model::TightbindingModel; kw...)\n\nReturn a TightbindingModel with only the hopping terms of model. Any non-missing kw is applied to all such terms.\n\nKeyword arguments\n\nMost keywords are the same as for hopselector. Only hoppings between two sites at positions r₁ = r - dr/2 and r₂ = r + dr, belonging to unit cells at integer distance dn´ and to sublattices s₁ and s₂ will be selected if: region(r, dr) && s in sublats && dn´ in dn && norm(dr) <= range. If any of these is missing it will not be used to constraint the selection.\n\nThe keyword range admits the following possibilities\n\nmax_range                   # i.e. `norm(dr) <= max_range`\n(min_range, max_range)      # i.e. `min_range <= norm(dr) <= max_range`\n\nBoth max_range and min_range can be a Real or a NeighborRange created with nrange(n). The latter represents the distance of n-th nearest neighbors. Note that the range default for hopping (unlike for the more general hopselector) is nrange(1), i.e. first-nearest-neighbors.\n\nThe keyword dn can be a Tuple/Vector/SVector of Ints, or a tuple thereof. The keyword sublats allows the following formats:\n\nsublats = :A => :B                 # Hopping from :A to :B sublattices\nsublats = (:A => :B,)              # Same as above\nsublats = (:A => :B, :C => :D)     # Hopping from :A to :B or :C to :D\nsublats = (:A, :C) .=> (:B, :D)    # Broadcasted pairs, same as above\nsublats = (:A, :C) => (:B, :D)     # Direct product, (:A=>:B, :A=:D, :C=>:B, :C=>D)\n\nThe keyword plusadjoint produces a model with the input hopping term plus its adjoint. Note that this substitution is made before multiplying by any coefficient, so that im*hopping(..., plusadjoint = true) == im*(hopping(...) + hopping(...)').\n\nCombining models\n\nOnsiteTerms and HoppingTerms created with onsite or hopping can added or substracted together or be multiplied by scalars to build more complicated TightbindingModels, e.g. onsite(1) - 3 * hopping(2)\n\nExamples\n\njulia> model = 3 * onsite(1) - hopping(2, dn = ((1,2), (0,0)), sublats = :A=>:B)\nTightbindingModel{2}: model with 2 terms\n  OnsiteTerm{Int64}:\n    Sublattices      : any\n    Coefficient      : 3\n  HoppingTerm{Int64}:\n    Sublattice pairs : (:A => :B,)\n    dn cell distance : ([1, 2], [0, 0])\n    Hopping range    : 1.0\n    Coefficient      : -1\n\njulia> newmodel = onsite(model) + hopping(model, range = 2)\nTightbindingModel{2}: model with 2 terms\n  OnsiteTerm{Int64}:\n    Sublattices      : any\n    Coefficient      : 3\n  HoppingTerm{Int64}:\n    Sublattice pairs : (:A => :B,)\n    dn cell distance : ([1, 2], [0, 0])\n    Hopping range    : 2.0\n    Coefficient      : -1\n\njulia> LatticePresets.honeycomb() |> hamiltonian(hopping((r,dr) -> cos(r[1]), sublats = (:A,:B) => (:A,:B)))\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 7 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 × 2\n  Orbitals         : ((:a,), (:a,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 18\n  Coordination     : 9.0\n\nSee also\n\n`onsite`, `nrange`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.hopselector-Tuple{}","page":"Reference","title":"Quantica.hopselector","text":"hopselector(; range = missing, dn = missing, sublats = missing, indices = missing, region = missing)\n\nReturn a HopSelector object that can be used to select hops between two sites in a lattice. Only hops between two sites, with indices ipair = src => dst, at positions r₁ = r - dr/2 and r₂ = r + dr, belonging to unit cells at integer distance dn´ and to sublattices s₁ and s₂ will be selected if:\n\n`region(r, dr) && s in sublats && dn´ in dn && norm(dr) <= range && ipair in indices`\n\nIf any of these is missing it will not be used to constraint the selection.\n\nThe keyword range admits the following possibilities\n\nmax_range                   # i.e. `norm(dr) <= max_range`\n(min_range, max_range)      # i.e. `min_range <= norm(dr) <= max_range`\n\nBoth max_range and min_range can be a Real or a NeighborRange created with nrange(n). The latter represents the distance of n-th nearest neighbors.\n\nThe keyword dn can be a Tuple/Vector/SVector of Ints, or a tuple thereof.\n\nThe keyword sublats allows the following formats:\n\nsublats = :A => :B                  # Hopping from :A to :B sublattices, but not from :B to :A\nsublats = (:A => :B,)               # Same as above\nsublats = (:A => :B, :C => :D)      # Hopping from :A to :B or :C to :D\nsublats = (:A, :C) .=> (:B, :D)     # Broadcasted pairs, same as above\nsublats = (:A, :C) => (:B, :D)      # Direct product, (:A=>:B, :A=:D, :C=>:B, :C=>D)\n\nThe keyword indices accepts a single src => dest pair or a collection thereof. Any src == dest will be neglected. Possible combinations:\n\nindices = 1 => 2                    # Hopping from site 1 to 2, but not from 2 to 1\nindices = (1 => 2, 2 => 1)          # Hoppings from 1 to 2 or from 2 to 1\nindices = [1 => 2, 2 => 1]          # Same as above\nindices = [(1, 2) .=> (2, 1)]       # Broadcasted pairs, same as above\nindices = [1:10 => 20:25, 3 => 30]  # Direct product, any hopping from sites 1:10 to sites 20:25, or from 3 to 30\n\nAdditionally, indices or sublattices can be wrapped in not to exclude them (see not):\n\nsublats = not(:A => :B, :B => :A)   # Any sublat pairs different from :A => :B or :B => :A\nsublats = not(:A) => :B             # Any sublat pair s1 => s2 with s1 different from :A and s2 equal to :B\nindices = not(8 => 9)               # Any site indices different from 8 => 9\nindices = 1 => not(3:4)             # Any site pair 1 => s with s different from 3, 4\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.ket-Tuple{Any}","page":"Reference","title":"Quantica.ket","text":"ket(a; region = missing, sublats = missing, normalized = true, maporbitals = false)\n\nCreate an KetModel of amplitude a on the specified region and sublats. The amplitude a can be a number, an SVector, or a function of the form r -> ... for a position-dependent amplitude.\n\nUnless maporbitals = true, the dimension of a::AbstractVector must match the orbital dimension of applicable sublattices (see also orbitals option for hamiltonian).\n\nOne or more k::KetModel can be converted to a Vector or Matrix representation corresponding to Hamiltonian h with Vector(k, h) and Matrix(k, h), see Vector and Matrix.\n\nKeyword arguments\n\nKeyword normalized indicates whether to force normalization of the ket when the KetModel is applied to a specific Hamiltonian.\n\nIf keyword maporbitals == true and a is a scalar or a scalar function, a will be applied to each orbital independently. This is particularly useful in multiorbital systems with random amplitudes, e.g. a = randn(). If a is not a scalar, a convert error will be thrown.\n\nKeywords region and sublats are the same as for siteselector. Only sites at position r in sublattice with name s::NameType will be selected if region(r) && s in sublats is true. Any missing region or sublat will not be used to constraint the selection.\n\nThe keyword sublats allows the following formats:\n\nsublats = :A           # Onsite on sublat :A only\nsublats = (:A,)        # Same as above\nsublats = (:A, :B)     # Onsite on sublat :A and :B\n\nKet algebra\n\nKetModels created with ket can added or substracted together or be multiplied by scalars to build more elaborate KetModels, e.g. ket(1) - 3 * ket(2, region = r -> norm(r) < 10)\n\nExamples\n\njulia> k = ket(1, sublats=:A) - ket(1, sublats=:B)\nKetModel{2}: model with 2 terms\n  Normalized : false\n  OnsiteTerm{Int64}:\n    Sublattices      : (:A,)\n    Coefficient      : 1\n  OnsiteTerm{Int64}:\n    Sublattices      : (:B,)\n    Coefficient      : -1\n\nSee also\n\n`onsite`, `Vector`, `Matrix`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.lattice-Tuple{Vararg{Quantica.Sublat,N} where N}","page":"Reference","title":"Quantica.lattice","text":"lattice(sublats::Sublat...; bravais = (), dim::Val{E}, type::T, names = missing)\n\nCreate a Lattice{E,L,T} with Bravais vectors bravais and sublattices sublats converted to a common  E-dimensional embedding space and type T. To override the embedding  dimension E, use keyword dim = Val(E). Similarly, override type T with type = T.\n\nThe keyword bravais indicates one or more Bravais vectors in the form of tuples or other iterables. It can also be an AbstractMatrix of dimension E×L. The default bravais = () corresponds to a bounded lattice with no Bravais vectors.\n\nA keyword names can be used to rename sublats. Given names can be replaced to ensure that all sublattice names are unique.\n\nlattice(lat::AbstractLattice; bravais = missing, dim = missing, type = missing, names = missing)\n\nCreate a new lattice by applying any non-missing kw to lat. For performance, allocations will be avoided if possible (depends on kw), so the result can share memory of lat. To avoid that, do lattice(copy(lat); kw...).\n\nSee also LatticePresets for built-in lattices.\n\nExamples\n\njulia> lattice(sublat((0, 0)), sublat((0, Float32(1))); bravais = (1, 0), dim = Val(3))\nLattice{3,1,Float32} : 1D lattice in 3D space\n  Bravais vectors : ((1.0f0, 0.0f0, 0.0f0),)\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (1, 1) --> 2 total per unit cell\n\njulia> LatticePresets.honeycomb(names = (:C, :D))\nLattice{2,2,Float64} : 2D lattice in 2D space\n  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))\n  Sublattices     : 2\n    Names         : (:C, :D)\n    Sites         : (1, 1) --> 2 total per unit cell\n\njulia> LatticePresets.cubic(bravais = ((1, 0), (0, 2)))\nLattice{3,2,Float64} : 2D lattice in 3D space\n  Bravais vectors : ((1.0, 0.0, 0.0), (0.0, 2.0, 0.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (1) --> 1 total per unit cell\n\nSee also\n\n`LatticePresets`, `bravais`, `sublat`, `supercell`, `intracell`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.momentaKPM","page":"Reference","title":"Quantica.momentaKPM","text":"momentaKPM(h::Hamiltonian, A = I; kets = randomkets(1), order = 10, bandrange = missing)\n\nCompute the Kernel Polynomial Method (KPM) momenta μ_n = ∑⟨ket|T_n(h) A|ket⟩, where the sum is over kets and where T_n(x) is the Chebyshev polynomial of order n, for a given ket, hamiltonian h, and observable A.\n\nkets can be a KetModel or a tuple of KetModels (see ket and randomkets). A kets = randomkets(R, ...) produces a special RepeatedKets object that can be used to compute momenta by means of a stochastic trace μ_n = Tr[A T_n(h)] ≈ ∑ₐ⟨a|A T_n(h)|a⟩, where the |a⟩ are the R random kets of norm 1/√R.\n\nThe order of the Chebyshev expansion is order. The bandbrange = (ϵmin, ϵmax) should completely encompass the full bandwidth of hamiltonian. If missing it is computed automatically using ArnoldiMethods (must be loaded).\n\nExamples\n\njulia> h = LatticePresets.cubic() |> hamiltonian(hopping(1)) |> unitcell(region = RegionPresets.sphere(10));\n\njulia> momentaKPM(h, bandrange = (-6,6)).mulist |> length\n11\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.not-Tuple{Any}","page":"Reference","title":"Quantica.not","text":"not(i)\n\nWrapper indicating the negation or complement of i, typically used to encode excluded site indices. See siteselector and hopselector for applications.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.nrange-Tuple{Int64}","page":"Reference","title":"Quantica.nrange","text":"nrange(n::Int)\n\nCreate a NeighborRange that represents a hopping range to distances corresponding to the n-th nearest neighbors in a given lattice. Such distance is obtained by finding the n-th closest pairs of sites in a lattice, irrespective of their sublattice.\n\nnrange(n::Int, lat::AbstractLattice)\n\nObtain the actual nth-nearest-neighbot distance between sites in lattice lat.\n\nSee also\n\n`hopping`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.offdiagonal-Tuple{Quantica.TightbindingModel,Any,Any}","page":"Reference","title":"Quantica.offdiagonal","text":"offdiagonal(model, lat, nsublats::NTuple{N,Int})\n\nBuild a restricted version of model that applies only to off-diagonal blocks formed by sublattice groups of size nsublats.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.onsite-Tuple{Any}","page":"Reference","title":"Quantica.onsite","text":"onsite(o; region = missing, sublats = missing)\n\nCreate an TightbindingModel with a single OnsiteTerm that applies an onsite energy o to a Lattice when creating a Hamiltonian with hamiltonian.\n\nThe onsite energy o can be a number, an SMatrix, a UniformScaling (e.g. 3*I) or a function of the form r -> ... for a position-dependent onsite energy.\n\nThe dimension of o::AbstractMatrix must match the orbital dimension of applicable sublattices (see also orbitals option for hamiltonian). If o::UniformScaling it will be converted to an identity matrix of the appropriate size when applied to multiorbital sublattices. Similarly, if o::SMatrix it will be truncated or padded to the appropriate size.\n\nonsite(model::TightbindingModel; kw...)\n\nReturn a TightbindingModel with only the onsite terms of model. Any non-missing kw is applied to all such terms.\n\nKeyword arguments\n\nKeywords are the same as for siteselector. Only sites at position r in sublattice with name s::NameType will be selected if region(r) && s in sublats is true. Any missing region or sublat will not be used to constraint the selection.\n\nThe keyword sublats allows the following formats:\n\nsublats = :A           # Onsite on sublat :A only\nsublats = (:A,)        # Same as above\nsublats = (:A, :B)     # Onsite on sublat :A and :B\n\nCombining models\n\nOnsiteTerms and HoppingTerms created with onsite or hopping can added or substracted together or be multiplied by scalars to build more complicated TightbindingModels, e.g. onsite(1) - 3 * hopping(2)\n\nExamples\n\njulia> model = onsite(1, sublats = (:A,:B)) - 2 * hopping(2, sublats = :A=>:A)\nTightbindingModel{2}: model with 2 terms\n  OnsiteTerm{Int64}:\n    Sublattices      : (:A, :B)\n    Coefficient      : 1\n  HoppingTerm{Int64}:\n    Sublattice pairs : (:A => :A,)\n    dn cell distance : any\n    Hopping range    : 1.0\n    Coefficient      : -2\n\njulia> newmodel = onsite(model; sublats = :A) + hopping(model)\nTightbindingModel{2}: model with 2 terms\n  OnsiteTerm{Int64}:\n    Sublattices      : (:A,)\n    Coefficient      : 1\n  HoppingTerm{Int64}:\n    Sublattice pairs : (:A => :A,)\n    dn cell distance : any\n    Hopping range    : 1.0\n    Coefficient      : -2\n\njulia> LatticePresets.honeycomb() |> hamiltonian(onsite(r -> @SMatrix[1 2; 3 4]), orbitals = Val(2))\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 1 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 × 2\n  Orbitals         : ((:a, :a), (:a, :a))\n  Element type     : 2 × 2 blocks (Complex{Float64})\n  Onsites          : 2\n  Hoppings         : 0\n  Coordination     : 0.0\n\nSee also\n\n`hopping`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.orbitalstructure-Tuple{Quantica.Hamiltonian}","page":"Reference","title":"Quantica.orbitalstructure","text":"orbitalstructure(x::Union{Hamiltonian,ParametricHamiltonian})\norbitalstructure(x::Subspace)\n\nReturn an OrbitalStructure containing information about the orbital structure of x\n\nExamples\n\njulia> sp = spectrum(LP.honeycomb() |> hamiltonian(hopping(I), orbitals = (:up,:down)) |> unitcell);\n\njulia> sp[around = -1] |> orbitalstructure\nOrbitalStructure: orbital structure of Hamiltonian\n  Orbital Type  : SVector{2, ComplexF64}\n  Orbitals      : ((:up, :down), (:up, :down))\n  Sublattices   : 2\n  Dimensions    : 2\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.parameters-Tuple{Quantica.ParametricHamiltonian}","page":"Reference","title":"Quantica.parameters","text":"parameters(ph::ParametricHamiltonian)\n\nReturn the names of the parameter that ph depends on\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.parameters-Tuple{Vararg{Quantica.ElementModifier,N} where N}","page":"Reference","title":"Quantica.parameters","text":"parameters(p::ElementModifier...)\n\nReturn the parameter names for one or several  ElementModifier created with @onsite! or @hopping!\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.parametric-Tuple{Quantica.Hamiltonian,Vararg{Quantica.ElementModifier,N} where N}","page":"Reference","title":"Quantica.parametric","text":"parametric(h::Hamiltonian, modifiers::ElementModifier...)\n\nBuilds a ParametricHamiltonian that can be used to efficiently apply modifiers to h. modifiers can be any number of @onsite!(args -> body; kw...) and @hopping!(args -> body; kw...) transformations, each with a set of parameters ps given as keyword arguments of functions f = (...; ps...) -> body.\n\nFor sparse h (the default), parametric only modifies existing onsites and hoppings in h, so be sure to add zero onsites and/or hoppings to h if they are originally not present but you need to apply modifiers to them.\n\nph(; ps...)\n\nFor a ph::ParametricHamiltonian, return the corresponding Hamiltonian with parameters ps applied.\n\nh |> parametric(modifiers::ElementModifier...)\n\nFunction form of parametric, equivalent to parametric(h, modifiers...).\n\nExamples\n\njulia> ph = LatticePresets.honeycomb() |> hamiltonian(onsite(0) + hopping(1, range = 1/√3)) |>\n       unitcell(10) |> parametric(@onsite!((o; μ) -> o - μ))\nParametricHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)\n  Harmonic size    : 200 × 200\n  Orbitals         : ((:a,), (:a,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 600\n  Coordination     : 3.0\n  Parameters       : (:μ,)\n\njulia> ph(μ = 2)\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)\n  Harmonic size    : 200 × 200\n  Orbitals         : ((:a,), (:a,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 200\n  Hoppings         : 600\n  Coordination     : 3.0\n\nSee also\n\n`@onsite!`, `@hopping!`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.randomkets","page":"Reference","title":"Quantica.randomkets","text":"randomkets(n, f::Function = r -> cis(2pi*rand()); maporbitals = false, kw...)\n\nCreate a StochasticTraceKets object to use in stochastic trace evaluation of KPM methods. The ket amplitudes at point r is given by function f(r). In order to produce an accurate estimate of traces ∑⟨ket|A|ket⟩/n ≈ TrA, f must be a random function satisfying ⟨f⟩ = 0, ⟨ff⟩ = 0 and ⟨f'f⟩ = 1. The default f produces a uniform random phase. To apply it to an N-orbital system, f must in general be adapted to produce the desired random SVector{N} (unless maporbitals = true), with the above statistical properties for each orbital.\n\nFor example, to have independent, complex, normally-distributed random components of two orbitals use randomkets(n, r -> randn(SVector{2,ComplexF64})), or alternatively randomkets(n, r -> randn(ComplexF64), maporbitals = true).\n\nIf maporbitals == true the function f (which should then return a scalar) is applied independently to each orbital. The remaining keywords kw are passed to ket and can be used to constrain the random amplitude to a subset of sites. normalized, however, is always false.\n\nSee also\n\n`ket`\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.similarmatrix","page":"Reference","title":"Quantica.similarmatrix","text":"similarmatrix(h::Hamiltonian)\n\nCreate an uninitialized matrix of the same type and size of the Hamiltonian's matrix.\n\nsimilarmatrix(h::Hamiltonian, T::Type{<:AbstractMatrix})\n\nMake the matrix of type B<:T. Can be used to specify a different eltype from h's, (e.g. T=SparseMatrixCSC{Float64} with a multiorbital h)\n\nsimilarmatrix(h::Hamiltonian, flatten)\n\nCreate an unitialized matrix of the same type as a flattened version of h's, i.e. with a scalar eltype as in the example above.\n\nsimilarmatrix(h::Hamiltonian, T::AbstractDiagonalizeMethod)\n\nAdapts the type of the matrix (e.g. dense/sparse) to the specified method\n\nsimilarmatrix(x::Union{ParametricHamiltonian, GreensFunction}, ...)\n\nEquivalent to the above, but adapted to the more general type of x.\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |> hamiltonian(hopping(I), orbitals = Val(2))\n\njulia> similarmatrix(h) |> summary\n\"2×2 SparseMatrixCSC{StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4},Int64}\"\n\njulia> similarmatrix(h, Matrix{Int}) |> summary\n\"4×4 Array{Int64,2}\"\n\njulia> similarmatrix(h, flatten) |> summary\n\"4×4 SparseMatrixCSC{Complex{Float64},Int64}\"\n\njulia> similarmatrix(h, LinearAlgebraPackage()) |> summary\n\"4×4 Array{Complex{Float64},2}\"\n\nSee also\n\n`bloch!`\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.siteindices-Tuple{Quantica.AbstractLattice}","page":"Reference","title":"Quantica.siteindices","text":"siteindices(lat::AbstractLattice; kw...)\nsiteindices(lat::Hamiltonian; kw...)\n\nBuild a generator of the unique indices of sites in the lattice unitcell. Only sites specified by siteselector(kw...) are selected, see siteselector for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.sitepositions-Tuple{Quantica.AbstractLattice}","page":"Reference","title":"Quantica.sitepositions","text":"sitepositions(lat::AbstractLattice; kw...)\nsitepositions(h::Hamiltonian; kw...)\n\nBuild a generator of the positions of sites in the lattice unitcell. Only sites specified by siteselector(kw...) are selected, see siteselector for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.siteselector-Tuple{}","page":"Reference","title":"Quantica.siteselector","text":"siteselector(; region = missing, sublats = missing, indices = missing)\n\nReturn a SiteSelector object that can be used to select sites in a lattice contained within the specified region and sublattices. Only sites with index i, at position r and belonging to a sublattice with name s::NameType will be selected if\n\n`region(r) && s in sublats && i in indices`\n\nAny missing region, sublat or indices will not be used to constraint the selection.\n\nThe keyword sublats allows the following formats:\n\nsublats = :A                    # Sites on sublat :A only\nsublats = (:A,)                 # Same as above\nsublats = (:A, :B)              # Sites on sublat :A and :B\n\nThe keyword indices accepts a single integer, or a collection thereof. If several collections are given, they are flattened into a single one. Possible combinations:\n\nindices = 1                     # Site 1 only\nindices = (1, )                 # Same as above\nindices = (1, 2, 3)             # Sites 1, 2 or 3\nindices = [1, 2, 3]             # Same as above\nindices = 1:3                   # Same as above\nindices = (1:3, 7, 8)           # Sites 1, 2, 3, 7 or 8\n\nAdditionally, indices or sublattices can be wrapped in not to exclude them (see not):\n\nsublats = not(:A)               # Any sublat different from :A\nsublats = not(:A, :B)           # Any sublat different from :A and :B\nindices = not(8)                # Any site index different from 8\nindices = not(1, 3:4)           # Any site index different from 1, 3 or 4\nindices = (not(3:4), 4:6)       # Any site different from 3 and 4, *or* equal to 4, 5 or 6\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.spectrum-Tuple{Any}","page":"Reference","title":"Quantica.spectrum","text":"spectrum(h; method = LinearAlgebraPackage(), transform = missing)\n\nCompute the spectrum of a 0D Hamiltonian h (or alternatively of the bounded unit cell of a finite dimensional h) using one of the following methods\n\nmethod                    diagonalization function\n--------------------------------------------------------------\nLinearAlgebraPackage()     LinearAlgebra.eigen!\nArpackPackage()            Arpack.eigs (must be `using Arpack`)\n\nThe option transform = ε -> f(ε) allows to transform eigenvalues by f in the returned spectrum (useful for performing shifts or other postprocessing).\n\nIndexing\n\nThe eigenenergies εv::Vector and eigenstates ψm::Matrix in a s::Spectrum object can be accessed via destructuring, εv, ψm = sp, or εv, ψm = Tuple(sp), or εv = first(sp) = sp.energies, ψm = last(sp) = sp.states. Any degenerate energies appear repeated in εv. Alternatively, one can access one or more complete sub::Subspaces (eigenenergy together with its eigenstates, including all degenerates) via the indexing syntax,\n\ns[1]                   : first `Subspace`\ns[2:4]                 : subspaces 2, 3 and 4\ns[[2,5,6]]             : subspaces 2, 5 and 6\ns[around = 0.2]        : single subspace with energy closest to 0.2\ns[around = (0.2, 10)]  : the ten subspaces with energies closest to 0.2\n\nThe eigenenergy ε and subspace basis ψs of a sub::Subspace can be obtained via destructuring, ε, ψs = sub, or ε = first(sub) = sub.energy, ψs = last(sub) = sub.basis. For performance reasons ψs is a SubArray view of the appropriate columns of ψm, not an independent copy.\n\nSee also\n\n`bandstructure`, `diagonalizer`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.splitbands-Tuple{Quantica.Bandstructure}","page":"Reference","title":"Quantica.splitbands","text":"splitbands(bs::Bandstructure)\n\nSplits the bands in bs into disconnected subbands that share no vertices. See also splitbands option in bandstructure.\n\nSee also\n\n`bandstructure`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.sublat-Tuple{AbstractArray{#s36,1} where #s36<:(StaticArrays.SArray{Tuple{S},T,1,S} where T where S)}","page":"Reference","title":"Quantica.sublat","text":"sublat(sites...; name::Symbol)\nsublat(sites::Vector{<:SVector}; name::Symbol)\n\nCreate a Sublat{E,T,D} that adds a sublattice, of name name, with sites at positions sites in E dimensional space. Sites can be entered as tuples or SVectors.\n\nExamples\n\njulia> sublat((0.0, 0), (1, 1), (1, -1), name = :A)\nSublat{2,Float64} : sublattice of Float64-typed sites in 2D space\n  Sites    : 3\n  Name     : :A\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.supercell-Tuple","page":"Reference","title":"Quantica.supercell","text":"supercell(lat::AbstractLattice{E,L}, v::NTuple{L,Integer}...; seed = missing, kw...)\nsupercell(lat::AbstractLattice{E,L}, sc::SMatrix{L,L´,Int}; seed = missing, kw...)\n\nGenerates a Superlattice from an L-dimensional lattice lat with Bravais vectors br´= br * sc, where sc::SMatrix{L,L´,Int} is the integer supercell matrix with the L´ vectors vs as columns. If no v are given, the superlattice will be bounded.\n\nOnly sites selected by siteselector(; kw...) will be included in the supercell (see siteselector for details on the available keywords kw). The search for included sites will start from point seed::Union{Tuple,SVector}, or the origin if seed = missing. If no keyword region is given in kw, a Bravais unit cell perpendicular to the v axes will be selected for the L-L´ non-periodic directions.\n\nsupercell(lattice::AbstractLattice{E,L}, factor::Integer; kw...)\n\nCalls supercell with a uniformly scaled sc = SMatrix{L,L}(factor * I)\n\nsupercell(lattice::AbstractLattice, factors::Integer...; kw...)\n\nCalls supercell with different scaling along each Bravais vector (diagonal supercell with factors along the diagonal)\n\nlat |> supercell(v...; kw...)\n\nCurried syntax, equivalent to `supercell(lat, v...; kw...)\n\nsupercell(h::Hamiltonian, v...; kw...)\n\nPromotes the Lattice of h to a Superlattice without changing the Hamiltonian itself, which always refers to the unitcell of the lattice.\n\nExamples\n\njulia> supercell(LatticePresets.honeycomb(), region = RegionPresets.circle(300))\nSuperlattice{2,2,Float64,0} : 2D lattice in 2D space, filling a 0D supercell\n  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (1, 1) --> 2 total per unit cell\n  Supercell{2,0} for 0D superlattice of the base 2D lattice\n    Supervectors  : ()\n    Supersites    : 652966\n\njulia> supercell(LatticePresets.triangular(), (1,1), (1, -1))\nSuperlattice{2,2,Float64,2} : 2D lattice in 2D space, filling a 2D supercell\n  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (1) --> 1 total per unit cell\n  Supercell{2,2} for 2D superlattice of the base 2D lattice\n    Supervectors  : ((1, 1), (1, -1))\n    Supersites    : 2\n\njulia> LatticePresets.square() |> supercell(3)\nSuperlattice{2,2,Float64,2} : 2D lattice in 2D space, filling a 2D supercell\n  Bravais vectors : ((1.0, 0.0), (0.0, 1.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (1) --> 1 total per unit cell\n  Supercell{2,2} for 2D superlattice of the base 2D lattice\n    Supervectors  : ((3, 0), (0, 3))\n    Supersites    : 9\n\nSee also\n\n`unitcell`, `siteselector`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.transform!-Tuple{Any,Quantica.Bandstructure}","page":"Reference","title":"Quantica.transform!","text":"transform!(f::Function, b::Bandstructure)\n\nTransform the energies of all bands in b by applying f to them in place.\n\ntransform!((fk, fε), b::Bandstructure)\n\nTransform Bloch phases and energies of all bands in b by applying fk and fε to them in place, respectively. If any of them is missing, it will be ignored.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.transform!-Tuple{Any,Quantica.Hamiltonian}","page":"Reference","title":"Quantica.transform!","text":"transform!(f::Function, h::Hamiltonian)\n\nTransform the site positions of the Hamiltonian's lattice in place without modifying the Hamiltonian harmonics.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.transform!-Tuple{Any,Quantica.Spectrum}","page":"Reference","title":"Quantica.transform!","text":"transform!(f::Function, s::Spectrum)\n\nTransform the energies of s by applying f to them in place.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.transform!-Tuple{Function,Quantica.Lattice}","page":"Reference","title":"Quantica.transform!","text":"transform!(f::Function, lat::Lattice)\n\nTransform the site positions of lat by applying f to them in place.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.unflatten-Union{Tuple{T}, Tuple{AbstractArray{T,1} where T,Quantica.OrbitalStructure{T,N,O} where O<:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N}} where N}} where T","page":"Reference","title":"Quantica.unflatten","text":"unflatten(v::AbstractArray, o::OrbitalStructure{T})\n\nRebuild v to have element type T and orbital structure o by performing the inverse of flatten(v).\n\nExamples\n\njulia> h = LP.honeycomb() |> hamiltonian(hopping(I), orbitals = (:up,:down)) |> unitcell;\n\njulia> psi = spectrum(h)[around = -1]\nSubspace{0}: eigenenergy subspace on a 0D manifold\n  Energy       : -0.9999999999999989\n  Degeneracy   : 2\n  Bloch/params : Float64[]\n  Basis eltype : SVector{2, ComplexF64}\n\njulia> psiflat = flatten(psi)\nSubspace{0}: eigenenergy subspace on a 0D manifold\n  Energy       : -0.9999999999999989\n  Degeneracy   : 2\n  Bloch/params : Float64[]\n  Basis eltype : ComplexF64\n\njulia> unflatten(psiflat, orbitalstructure(psi))\nSubspace{0}: eigenenergy subspace on a 0D manifold\n  Energy       : -0.9999999999999989\n  Degeneracy   : 2\n  Bloch/params : Float64[]\n  Basis eltype : SVector{2, ComplexF64}\n\nSee also\n\n`flatten`, `orbitalstructure`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.unitcell-Tuple{Vararg{Union{Integer, Tuple, StaticArrays.SArray{Tuple{S},T,1,S} where T where S, StaticArrays.SArray{Tuple{S1,S2},T,2,L} where L where T where S2 where S1},N} where N}","page":"Reference","title":"Quantica.unitcell","text":"unitcell(lat::Lattice{E,L}, v::NTuple{L,Integer}...; seed = missing, kw...)\nunitcell(lat::Lattice{E,L}, uc::SMatrix{L,L´,Int}; seed = missing, kw...)\n\nGenerates a Lattice from an L-dimensional lattice lat and a larger unit cell, such that its Bravais vectors are br´= br * uc. Here uc::SMatrix{L,L´,Int} is the integer unitcell matrix, with the L´ vectors vs as columns. If no v are given, the new lattice will be bounded.\n\nOnly sites selected by siteselector(; kw...) will be included in the supercell (see siteselector for details on the available keywords kw). The search for included sites will start from point seed::Union{Tuple,SVector}, or the origin if seed = missing. If no keyword region is given in kw, a Bravais unit cell perpendicular to the v axes will be selected for the L-L´ non-periodic directions.\n\nunitcell(lattice::Lattice{E,L}, factor::Integer; kw...)\n\nCalls unitcell with a uniformly scaled uc = SMatrix{L,L}(factor * I)\n\nunitcell(lattice::Lattice{E,L}, factors::Integer...; kw...)\n\nCalls unitcell with different scaling along each Bravais vector (diagonal supercell with factors along the diagonal)\n\nunitcell(slat::Superlattice)\n\nConvert Superlattice slat into a lattice with its unit cell matching slat's supercell.\n\nunitcell(h::Hamiltonian, v...; mincoordination, modifiers = (), kw...)\n\nTransforms the Lattice of h to have a larger unitcell, while expanding the Hamiltonian accordingly.\n\nA nonzero mincoordination indicates a minimum number of nonzero hopping neighbors required for sites to be included in the resulting unit cell. Sites with inferior coordination will be removed recursively, until all remaining satisfy mincoordination.\n\nThe modifiers (a tuple of ElementModifiers, either @onsite! or @hopping! with no free parameters) will be applied to onsite and hoppings as the hamiltonian is expanded. See @onsite! and @hopping! for details.\n\nNote: for performance reasons, in sparse hamiltonians only the stored onsites and hoppings will be transformed by ElementModifiers, so you might want to add zero onsites or hoppings when building h to have a modifier applied to them later.\n\nlat_or_h |> unitcell(v...; kw...)\n\nCurried syntax, equivalent to unitcell(lat_or_h, v...; kw...)\n\nExamples\n\njulia> unitcell(LatticePresets.honeycomb(), region = RegionPresets.circle(300))\nLattice{2,0,Float64} : 0D lattice in 2D space\n  Bravais vectors : ()\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (326483, 326483) --> 652966 total per unit cell\n\njulia> unitcell(LatticePresets.triangular(), (1,1), (1, -1))\nLattice{2,2,Float64} : 2D lattice in 2D space\n  Bravais vectors : ((0.0, 1.732051), (1.0, 0.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (2) --> 2 total per unit cell\n\njulia> LatticePresets.square() |> unitcell(3)\nLattice{2,2,Float64} : 2D lattice in 2D space\n  Bravais vectors : ((3.0, 0.0), (0.0, 3.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (9) --> 9 total per unit cell\n\njulia> supercell(LatticePresets.square(), 3) |> unitcell\nLattice{2,2,Float64} : 2D lattice in 2D space\n  Bravais vectors : ((3.0, 0.0), (0.0, 3.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (9) --> 9 total per unit cell\n\nSee also\n\n`supercell`, `siteselector`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.vertices-Tuple{Quantica.Bandstructure,Any}","page":"Reference","title":"Quantica.vertices","text":"vertices(bs::Bandstructure, i)\n\nReturn the vertices (k..., ϵ) of the i-th band in bs, in the form of a Vector{SVector{L+1}}, where L is the lattice dimension.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.wrap-Tuple{Quantica.Hamiltonian,Int64}","page":"Reference","title":"Quantica.wrap","text":"wrap(h::Hamiltonian, axes; phases = missing)\n\nBuild a new Hamiltonian from h reducing its dimensions from L to L - length(axes) by wrapping the specified Bravais axes into a loop. axes can be an integer ∈ 1:L or a tuple of such integers. If phases are given (with length(axes) == length(phases)), the wrapped hoppings at a cell distance dn along axes will be multiplied by a factor cis(-dot(phases, dn)). This is useful, for example, to represent a flux Φ through a loop, using a single axes = 1 and phases = 2π * Φ/Φ₀.\n\nwrap(h::Hamiltonian; kw...)\n\nWrap all axes of h, yielding a compactified zero-dimensional Hamiltonian.\n\nh |> wrap(axes; kw...)\n\nCurried form equivalent to wrap(h, axes; kw...).\n\nExamples\n\njulia> LatticePresets.honeycomb() |> hamiltonian(hopping(1, range = 1/√3)) |>\n       unitcell((1,-1), (10, 10)) |> wrap(2)\nHamiltonian{<:Lattice} : Hamiltonian on a 1D Lattice in 2D space\n  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)\n  Harmonic size    : 40 × 40\n  Orbitals         : ((:a,), (:a,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 120\n  Coordination     : 3.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.@hopping!-Tuple{Any,Any}","page":"Reference","title":"Quantica.@hopping!","text":"@hopping!(args -> body; kw...)\n\nCreate an ElementModifier, to be used with parametric, that applies f = args -> body to hoppings energies specified by kw (see hopping for details on possible kws). The form of args -> body may be (t; params...) -> ... or (t, r, dr; params...) -> ... if the modification is position (r, dr) dependent. Keyword arguments params are optional, and include any parameters that body depends on that the user may want to tune.\n\nNote: unlike onsite and hopping, ElementModifiers cannot be combined (i.e. you cannot do @onsite!(...) + @hopping!(...)). ElementModifiers are not model terms but transformations of an existing Hamiltonian that are meant to be applied sequentially (the order of application usually matters).\n\nSee also\n\n`@onsite!`, `parametric`\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Quantica.@onsite!-Tuple{Any,Any}","page":"Reference","title":"Quantica.@onsite!","text":"@onsite!(args -> body; kw...)\n\nCreate an ElementModifier, to be used with parametric, that applies f = args -> body to onsite energies specified by kw (see onsite for details  on possible kws). The form of args -> body may be (o; params...) -> ... or (o, r; params...) -> ... if the modification is position (r) dependent. Keyword arguments params are optional, and include any parameters that body depends on that the user may want to tune.\n\nNote: unlike onsite and hopping, ElementModifiers cannot be combined (i.e. you cannot do @onsite!(...) + @hopping!(...)). ElementModifiers are not model terms but transformations of an existing Hamiltonian that are meant to be applied sequentially (the order of application usually matters).\n\nSee also\n\n`@hopping!`, `parametric`\n\n\n\n\n\n","category":"macro"},{"location":"#Quantica.jl","page":"Home","title":"Quantica.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Quantica.jl is a Julia package for building generic tight-binding models and computing various spectral and transport properties.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Important information\nThis package supersedes Elsa.jl, which will soon be deprecated.","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"tutorial.md\",\n    \"examples.md\",\n    \"reference.md\",\n]\nDepth = 1","category":"page"},{"location":"#Current-functionality","page":"Home","title":"Current functionality","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Build arbitrary lattices (periodic or bounded in any dimension and with any unit cell)\nDefine generic model Hamiltonians by applying a model onto a lattice\nUse models with arbitrary orbital structure, spatial dependence and coordination (e.g. normal/superconducting, spin-orbit coupling, etc.)\nDefine parametric Hamiltonians that efficiently implement external parameters dependencies\nEfficiently compute the Bloch Hamiltonian matrix at arbitrary wave vector\nCompute the band structure or spectrum of a Hamiltonian, using advanced meshing and co-diagonalization techniques to resolve degeneracies and extract subbands\nUse Order-N Kernel polynomial methods to compute spectral and transport properties efficiently","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Funding\nThis work has been partly funded by the Spanish Ministry of Economy and Competitiveness under Grant Nos. FIS2015-65706-P, PCI2018-093026, and the CSIC Intramural Project 201760I086.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"}]
}
