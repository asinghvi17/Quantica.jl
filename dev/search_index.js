var documenterSearchIndex = {"docs":
[{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = Quantica","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Quantica]","category":"page"},{"location":"reference/#Quantica.Quantica","page":"Reference","title":"Quantica.Quantica","text":"Quantica.jl\n\n(Image: Stable) (Image: Dev) (Image: DOI) (Image: Build Status) (Image: Coverage) (Image: GitHub commits since last release)\n\nThe Quantica.jl package provides an expressive API to build arbitrary quantum systems on a discrete lattice, and to compute a number of their properties.\n\nSome current features\n\nBuild Hamiltonians on discrete lattices of arbitrary dimensions, using tight-binding models with arbitrary number of orbitals\nCompute band structures of periodic systems and extract individual bands by interpolation\nCompute electronic structures and expectation values using Kernel Polynomial methods\n\nExported API\n\nlattice, sublat: build lattices\nhopping, onsite, siteselector, hopselector, nrange, not: build tightbinding models\nhamiltonian: build a Hamiltonian from tightbinding model and a lattice\nbloch, bloch!, similarmatrix: build the Bloch matrix of a Hamiltonian\nparametric, @onsite!, @hopping!, parameters: build a parametric Hamiltonian\ndims, sitepositions, siteindices, bravais: inspect lattices and Hamiltonians\nsupercell, unitcell, wrap, transform!, combine: build derived lattices or Hamiltonians\nket, ketmodel, randomkets, basiskets: define kets and ket models for use in e.g. KPM routines\nflatten, unflatten, orbitalstructure: operate with multiorbital Hamiltonian, Kets or Subspaces\ncuboid: build a bandstructure discretization mesh\nbandstructure, spectrum, diagonalizer: compute the generalized bandstructure of a Hamiltonian or a ParametricHamiltonian\nbands, energies, states, minima, maxima, gapedge, gap, isinband: inspect spectrum and bandstructure objects\nmomentaKPM, dosKPM, averageKPM, densityKPM, bandrangeKPM: Kernel Polynomial Method (KPM)\ngreens, greensolver: build Green's functions of a Hamiltonian\n\nSome of this functionality require loading one or more third-party packages, which include the following:\n\nKPM: FFTW, ArnoldiMethod\nBandstructures: Arpack, ArnoldiMethod, KrylovKit\n\nThe user is told when this is needed. We do this to reduce dependencies and launch time with packages whose functionality is not essential for the use of Quantica.jl\n\nOther functions become available after loading specific third-party packages:\n\nMakie: enables plot(::Hamiltonian) and plot(::Bandstructure) (for 1D and 2D bandstructures)\nVegaLite: enables vlplot(::Hamiltonian) and vlplot(::Bandstructure) (for 1D bandstructures)\n\nFunding\n\nThis work has been partly funded by the Spanish Ministry of Economy and Competitiveness under Grant Nos. FIS2015-65706-P, PCI2018-093026, and the CSIC Intramural Project 201760I086.\n\n\n\n\n\n","category":"module"},{"location":"reference/#Quantica.BoxIterator","page":"Reference","title":"Quantica.BoxIterator","text":"BoxIterator(seed::SVector{N,Int}; maxiterations = missing)\n\nCartesian iterator iter over SVector{N,Int}s (cells) that starts at seed and grows outwards in the form of a box of increasing sides (not necesarily equal) until it encompasses a certain N-dimensional region. To signal that a cell is in the desired region the user calls acceptcell!(iter, cell).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Quantica.EffectiveMatrix","page":"Reference","title":"Quantica.EffectiveMatrix","text":"EffectiveMatrix\n\nA dense matrix of the form matrix = [ZaL(œâ) L' 0; L*ZaR(œâ) I*œâ-H R*ZrL(œâ); 0 R' ZrR(œâ)], where H, L and R are given at construction, while œâ, and the Z's are given at runtime.\n\nThis is equivalent, integrating out the Z blocks, to dressing I*œâ-H with self energies     Œ£‚Çä = h‚Çãg‚ÇÄh‚Çä = h‚Çã Œ¶r Œõr Œ¶r‚Åª¬π = R ZrL ZrR‚Åª¬π R'     Œ£‚Çã = h‚Çäg‚ÇÄh‚Çã = h‚Çã Œ¶a Œõa Œ¶a‚Åª¬π = L ZaR ZaL‚Åª¬π L' where     h‚Çä = L'R     h‚Çã = R'L     Œ¶rL = L' Œ¶r Œõr = ZrL * R11r     Œ¶rR = R' Œ¶r = ZrR * R11r     Œ¶aL = L' Œ¶a Œõa = ZaL * R11a     Œ¶aR = R' Œ¶a = ZaR * R11a and Z = [ZrL ZaL; ZrR ZaR] is obtained from the QZ decomposition A - ŒªB= Q(SA-ŒªSB)Z' of the deflated_pencil!(A, B), with eigenvalues ordered according to their modulus.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Quantica.Schur1D","page":"Reference","title":"Quantica.Schur1D","text":"Schur1D()\n\nReturn a Greens function solver using the generalized eigenvalue approach, whereby given the energy œâ, the eigenmodes of the infinite 1D Hamiltonian, and the corresponding infinite and semi-infinite Greens function can be computed by solving the generalized eigenvalue equation\n\nA‚ãÖœÜœá = Œª B‚ãÖœÜœá\nA = [0 I; -h‚Çä œâ-h‚ÇÄ]\nB = [I 0; 0 h‚Çã]\n\nThis is the matrix form of the problem Œª(œâ-h‚ÇÄ)œÜ - h‚ÇäœÜ - Œª¬≤h‚ÇãœÜ = 0, where œÜœá = [œÜ; ŒªœÜ], and œÜ are œâ-energy eigenmodes, with (possibly complex) momentum q, and eigenvalues are Œª = exp(-iqa‚ÇÄ). The algorithm assumes the Hamiltonian has only dn = (0,) and dn = (¬±1, ) Bloch harmonics (h‚ÇÄ, h‚Çä and h‚Çã), and will error otherwise instructing the user to grow the unit cell. Bound states in the spectrum will yield delta functions in the density of states that can be resolved by adding a broadening in the form of a small positive imaginary part to œâ. If œâ::Real, a small imaginary part will be added automatically.\n\nFor performace, the eigenvalue equation may be deflated' andstabilized', i.e. singular solutions Œª=0,‚àû will be removed, and an inverse-free algorithm is used to preserve precision even in the presence of singularities.\n\nExamples\n\njulia> using LinearAlgebra\n\njulia> h = LP.honeycomb() |> hamiltonian(hopping(1)) |> unitcell((1,-1), (10,10)) |> wrap(2);\n\njulia> g = greens(h, Schur1D(), boundaries = (0,))\nGreensFunction{Schur1DGreensSolver}: Green's function using the Schur1D method\n  Flat matrix size      : 40 √ó 40\n  Flat deflated size    : 20 √ó 20\n  Original element type : scalar (ComplexF64)\n  Boundaries            : (0,)\n\njulia> tr(g(0.3, 1=>1))\n-32.193416071797216 - 3.4400038418349084im\n\nSee also\n\n`greens`\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.:&-Tuple{Quantica.Hamiltonian{#s41,L,M,A,H,O} where O<:Quantica.OrbitalStructure where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s41<:Quantica.Superlattice,Quantica.Hamiltonian{#s40,L,M,A,H,O} where O<:Quantica.OrbitalStructure where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s40<:Quantica.Superlattice}","page":"Reference","title":"Base.:&","text":"&(h1::Hamiltonian{<:Superlattice}, h2::Hamiltonian{<:Superlattice})\n\nConstruct a new Hamiltonian{<:Superlattice} using an and boolean mask, i.e. with a supercell that contains cells that are both in the supercell of h1 and h2\n\n&(s1::Superlattice, s2::Superlattice}\n\nEquivalent of the above for Superlattices\n\nSee also\n\n`|`, `xor`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:|-Tuple{Quantica.Hamiltonian{#s41,L,M,A,H,O} where O<:Quantica.OrbitalStructure where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s41<:Quantica.Superlattice,Quantica.Hamiltonian{#s40,L,M,A,H,O} where O<:Quantica.OrbitalStructure where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s40<:Quantica.Superlattice}","page":"Reference","title":"Base.:|","text":"|(h1::Hamiltonian{<:Superlattice}, h2::Hamiltonian{<:Superlattice})\n\nConstruct a new Hamiltonian{<:Superlattice} using an or boolean mask, i.e. with a supercell that contains cells that are either in the supercell of h1 or h2\n\n|(s1::Superlattice, s2::Superlattice}\n\nEquivalent of the above for Superlattices\n\nSee also\n\n`&`, `xor`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.xor-Tuple{Quantica.Hamiltonian{#s41,L,M,A,H,O} where O<:Quantica.OrbitalStructure where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s41<:Quantica.Superlattice,Quantica.Hamiltonian{#s40,L,M,A,H,O} where O<:Quantica.OrbitalStructure where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s40<:Quantica.Superlattice}","page":"Reference","title":"Base.xor","text":"xor(h1::Hamiltonian{<:Superlattice}, h2::Hamiltonian{<:Superlattice})\n\nConstruct a new Hamiltonian{<:Superlattice} using a xor boolean mask, i.e. with a supercell that contains cells that are either in the supercell of h1 or h2 but not in both\n\nxor(s1::Superlattice, s2::Superlattice}\n\nEquivalent of the above for Superlattices\n\nSee also\n\n`&`, `|`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.DACPdiagonaliser-Tuple{Any,Any,Any}","page":"Reference","title":"Quantica.DACPdiagonaliser","text":"`DACPdiagonaliser(h::AbstractMatrix{T}, s::AbstractMatrix{T}; threshold = 1e-12)`\nsolves the GEP problem defined by the hamiltonian matrix `h` and the overlap matrix `s`\n\nwhich are built using an overcomplete basis corresponding to a number numkets of Chebyshev evolutions.      It returns the eigendescomposition (eigenvalues and eigenvectors) of the target subspace of a hamiltonian, h. Note that we throw all linear dependencies by means of a rank revealing factorization of the overlap matrices. We select the subspace corresponding to all singular  values up to tolerance = 1e-12.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.DACPdiagonaliser-Tuple{Quantica.Hamiltonian,Any}","page":"Reference","title":"Quantica.DACPdiagonaliser","text":"Diagonaliser, uses the selected codepath method to solve the General Eigenvalue Problem so we are taking care of possible degeneracies.     method = :QZ, performs a Generalized Schur Decomposition (QZ)     method = :default performs ref method SVD     method = :deflatedQZ, performs a QZ with a previous deflation of the subspace (testing...)     method = :twoQR, method with two QR with complete pivoting factorizations (testing...)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica._chebyshev_loop!-NTuple{5,Any}","page":"Reference","title":"Quantica._chebyshev_loop!","text":"Chebyshev evolution loop\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.averageKPM-Tuple{Any,Any}","page":"Reference","title":"Quantica.averageKPM","text":"averageKPM(h::Hamiltonian, A; kBT = 0, Ef = 0, kw...)\n\nCompute, using the Kernel Polynomial Method (KPM), the thermal expectation value ‚ü®A‚ü© = Œ£_k f(E_k) ‚ü®k|A|k‚ü© = ‚à´dE f(E) Tr [A Œ¥(E-H)]/N‚ÇÄ = Tr [A f(H)]/N‚ÇÄ for a given hermitian operator A and a zero-dimensional hamiltonian h with a total of N‚ÇÄ orbitals (see momentaKPM and its options kw for further details). f(E) is the Fermi-Dirac distribution function, |k‚ü© are h eigenstates with energy E_k, kBTis the temperature in energy units andEf` the Fermi energy.\n\naverageKPM(Œº::MomentaKPM, A; kBT = 0, Ef = 0)\n\nSame as above with the KPM momenta as input (see momentaKPM).\n\nSee also\n\n`dosKPM`, `momentaKPM`, `averageKPM`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.bands-Tuple{Quantica.Bandstructure}","page":"Reference","title":"Quantica.bands","text":"bands(bs::Bandstructure[, i])\n\nReturn a bands::Vector{Band} of all the bands in bs, or bands[i] if i is given.\n\nSee also\n\n`bandstructure`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.bandstructure-Tuple","page":"Reference","title":"Quantica.bandstructure","text":"bandstructure(h::Hamiltonian; subticks = 13, kw...)\n\nCompute bandstructure(h, cuboid((-œÄ,œÄ)...; subticks = subticks); kw...) using a base mesh (of type CuboidMesh) over h's full Brillouin zone with the specified subticks along each [-œÄ,œÄ] reciprocal axis.\n\nbandstructure(h::Hamiltonian, nodes...; subticks = 13, kw...)\n\nCreate a linecut of a bandstructure of h along a polygonal line connecting two or more nodes. Each node is either a Tuple or SVector of Bloch phases, or a symbolic name for a Brillouin zone point (:Œì,:K, :K¬¥, :M, :X, :Y or :Z). Each segment in the polygon has the specified number of subticks. Different subticks per segments can be specified with subticks = (p1, p2...).\n\nbandstructure(h::Hamiltonian, mesh::CuboidMesh; mapping = missing, kw...)\n\nCompute the bandstructure bandstructure(h, mesh; kw...) of Bloch Hamiltonian bloch(h, œï), with œï = v taken on each vertex v of the base mesh (or œï = mapping(v...) if a mapping function is provided).\n\nbandstructure(ph::ParametricHamiltonian, ...; kw...)\n\nCompute the bandstructure of a ph. Unless all parameters have default values, a mapping is required between mesh vertices and Bloch/parameters for ph, see details on mapping below.\n\nbandstructure(matrixf::Function, mesh::CuboidMesh; kw...)\n\nCompute the bandstructure of the Hamiltonian matrix m = matrixf(œï), with œï evaluated on the vertices v of the mesh. Note that œï in matrixf(œï) is an unsplatted container. Hence, i.e. matrixf(x) = ... or matrixf(x, y) = ... will not work. Use matrixf((x,)) = ..., matrixf((x, y)) = ... or matrixf(s::SVector) = ...` instead.\n\nh |> bandstructure([mesh,]; kw...)\n\nCurried form of the above equivalent to bandstructure(h[, mesh]; kw...).\n\nOptions\n\nThe default options are\n\n(mapping = missing, method = LinearAlgebraPackage(), transform = missing, splitbands = true, showprogress = true)\n\nmapping: when not missing, mapping = v -> p is a function that map base mesh vertices v to Bloch phases and/or parameters p. The structure of p is whatever is accepted by bloch(h, p, ...) (see bloch). For h::Hamiltonian, p = œïs::Union{Tuple,SVector} are Bloch phases. For h::ParametricHamiltonian, p = (œïs..., (; ps)) or p = (œïs, (; ps)) combine Bloch phases œïs and keyword parameters ps of ph. This allows to compute a bandstructure along a cut in the Brillouin zone/parameter space of ph, see examples below.\n\nmethod: it is chosen automatically if unspecified, and can be one of the following\n\nmethod                     diagonalization function\n--------------------------------------------------------------\nLinearAlgebraPackage()     LinearAlgebra.eigen!\nArpackPackage()            Arpack.eigs (must be `using Arpack`)\n\nOptions passed to the method will be forwarded to the diagonalization function. For example, method = ArpackPackage(nev = 8, sigma = 1im) will use Arpack.eigs(matrix; nev = 8, sigma = 1im) to compute the bandstructure.\n\ntransform: the option transform = Œµ -> fŒµ(Œµ) allows to transform eigenvalues by fŒµ in the returned bandstructure (useful for performing shifts or other postprocessing). We can also do transform -> (fœÜ, fŒµ) to transform also mesh vertices with fœÜ. Additionally, transform -> isometric or transform -> (isometric, fŒµ) will transform mesh vertices into momenta, assuming they represent Bloch phases. This works both in full bandstructures and linecuts.\n\nsplitbands: split all bands into disconnected subbands. See also splitbands!\n\nshowprogress: indicate whether progress bars are displayed during the calculation\n\nIndexing\n\nThe bands in a bs::Bandstructure object can be accessed with bands, while the indexing syntax bs[(œÜs...)] gives access to one or more sub::Subspace objects, contructed by linear interpolation of each band at base-mesh coordinates œÜs.\n\nbs[(œÜs...), 1]                  : first interpolated subspaces at base mesh coordinates `œÜs`, ordered by energy\nbs[(œÜs...), 1:3]                : interpolated subspaces 1 to 3 at base mesh coordinates `œÜs`, ordered by energy\nbs[(œÜs...)]                     : interpolated subspaces at base mesh coordinates `œÜs` in any band\nbs[(œÜs...), around = 0.2]       : the single interpolated subspaces at `œÜs` with energies closest to 0.2\nbs[(œÜs...), around = (0.2, 10)] : the ten interpolated subspaces at `œÜs` with energies closest to 0.2\n\nThe eigenenergy Œµ and subspace basis œàs of a sub::Subspace can themselves be obtained via destructuring, Œµ, œàs = sub, or Œµ = first(sub), œàs = last(sub).\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |> hamiltonian(hopping(-1)) |> unitcell(3);\n\njulia> bandstructure(h; subticks = 25, method = LinearAlgebraPackage())\nBandstructure{2}: bands of a 2D Hamiltonian\n  Bands         : 1\n  Vertices      : 9917\n  Edges         : 31044\n  Simplices     : 20724\n\njulia> bandstructure(h, :Œì, :X, :Y, :Œì; subticks = (10,15,10))\nBandstructure{1}: bands of a 1D Hamiltonian\n  Bands         : 1\n  Vertices      : 442\n  Edges         : 468\n  Simplices     : 468\n\njulia> bandstructure(h, cuboid((0, 2œÄ); subticks = 13); mapping = œÜ -> (œÜ, 0))\nBandstructure{1}: bands of a 1D Hamiltonian\n  Bands         : 1\n  Vertices      : 136\n  Edges         : 144\n  Simplices     : 144\n\njulia> ph = parametric(h, @hopping!((t; Œ±) -> t * Œ±));\n\njulia> bandstructure(ph, cuboid((0, 2œÄ); subticks = 13); mapping = œÜ -> (œÜ, 0, (; Œ± = 2œÜ)))\nBandstructure{1}: bands of a 1D Hamiltonian\n  Bands         : 1\n  Vertices      : 132\n  Edges         : 144\n  Simplices     : 144\n\nSee also\n\n`cuboid`, `diagonalizer`, `bloch`, `parametric`, `splitbands!`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.basiskets","page":"Reference","title":"Quantica.basiskets","text":"basiskets(a = I; kw...)\n\nCreate a multicolumn ket model that represents a basis for sites selected by siteselctor(kw...), with amplitude a on each site. For hamiltonians with N orbitals per site, a will need to be either I or a matrix with N columns. \n\nbasiskets(a; kw...) is equivalent to ketmodel(a; singlesitekets = true, kw...).\n\nSee also\n\n`ket`\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.bloch","page":"Reference","title":"Quantica.bloch","text":"bloch(h::Hamiltonian{<:Lattice}, œïs)\n\nBuild the Bloch Hamiltonian matrix of h, for Bloch phases œïs = (œï‚ÇÅ, œï‚ÇÇ,...) (or an SVector(œïs...)). In terms of Bloch wavevector k, œïs = k * bravais(h), it is defined as H(œïs) = ‚àëexp(-im * œïs' * dn) h_dn where h_dn are Bloch harmonics connecting unit cells at a distance dR = bravais(h) * dn.\n\nbloch(h::Hamiltonian{<:Lattice})\n\nBuild the intra-cell Hamiltonian matrix of h, without adding any Bloch harmonics.\n\nbloch(h::Hamiltonian{<:Lattice}, œïs, axis::Int)\n\nA nonzero axis produces the derivative of the Bloch matrix respect to œïs[axis] (i.e. the velocity operator along this axis), ‚àÇH(œïs) = ‚àë -im * dn[axis] * exp(-im * œïs' * dn) h_dn\n\nbloch(h::Hamiltonian{<:Lattice}, œïs::NTuple{L,Real}, dnfunc::Function)\n\nGeneralization that applies a prefactor dnfunc(dn) * exp(im * œïs' * dn) to the dn harmonic.\n\nbloch(ph::ParametricHamiltonian, [pœïs, [axis]])\n\nBuild the Bloch matrix for ph. pœïs = (œïs, (;kw...)) or pœïs = (œïs..., (;kw...)) specifies both Bloch phases œïs and the parameters kw passed to ph(; kw...). If there are no œïs, the syntax pœïs = (;kw...) is also allowed, which is in that case equivalent to bloch(ph(; kw...)). Similarly, bloch(ph) is equivalent to bloch(ph()).\n\nh |> bloch(œïs, ...)\nph |> bloch(pœïs, ...)\n\nCurried forms of bloch, equivalent to bloch(h, œïs, ...) and bloch(ph, pœïs, ...)\n\nNotes\n\nbloch allocates a new matrix on each call. For a non-allocating version of bloch, see bloch!.\n\nbloch also supports slices of Hamiltonians and ParametricHamiltonians, produced with h[rows, cols], see the indexing section of hamiltonian and  parametric for details.\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |> hamiltonian(onsite(1) + hopping(2)) |> bloch((0, 0))\n2√ó2 SparseMatrixCSC{Complex{Float64},Int64} with 4 stored entries:\n  [1, 1]  =  1.0+0.0im\n  [2, 1]  =  6.0+0.0im\n  [1, 2]  =  6.0+0.0im\n  [2, 2]  =  1.0+0.0im\n\nSee also\n\n`bloch!`, `similarmatrix`\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.bloch!","page":"Reference","title":"Quantica.bloch!","text":"bloch!(matrix, h::Hamiltonian, [œïs, [axis]])\n\nIn-place version of bloch. Overwrite matrix with the Bloch Hamiltonian matrix of h for the specified Bloch phases œïs = (œï‚ÇÅ,œï‚ÇÇ,...) (see bloch for definition and API). A conventient way to obtain a matrix is to use similarmatrix(h,matrix_type), which will return an AbstractMatrix of the same type as the Hamiltonian's. Note, however, that matrix need not be of the same type (e.g. it can be dense with Number eltype for a sparse h with SMatrix block eltype).\n\nbloch!(matrix, ph::ParametricHamiltonian, [pœïs, [axis]])\n\nSame as above but with pœïs = (œïs, (;kw...)), pœïs = (œïs..., (;kw...)) or pœïs = (;kw...) (see bloch for details).\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |> hamiltonian(hopping(2I), orbitals = (Val(2), Val(1)));\n\njulia> bloch!(similarmatrix(h), h, (0, 0))\n2√ó2 SparseMatrixCSC{SMatrix{2, 2, ComplexF64, 4}, Int64} with 2 stored entries:\n                     ‚ãÖ                       [6.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]\n [6.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]                      ‚ãÖ                     \n\njulia> bloch!(similarmatrix(h, flatten), h, (0, 0))\n3√ó3 SparseMatrixCSC{ComplexF64, Int64} with 9 stored entries:\n 0.0+0.0im  0.0+0.0im  6.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im\n 6.0+0.0im  0.0+0.0im  0.0+0.0im\n\njulia> ph = parametric(h, @hopping!((t; Œ±, Œ≤ = 0) -> Œ± * t .+ Œ≤));\n\njulia> bloch!(similarmatrix(ph, flatten), ph, (0, 0, (; Œ± = 2)))\n3√ó3 SparseMatrixCSC{ComplexF64, Int64} with 9 stored entries:\n  0.0+0.0im  0.0+0.0im  12.0+0.0im\n  0.0+0.0im  0.0+0.0im   0.0+0.0im\n 12.0+0.0im  0.0+0.0im   0.0+0.0im\n\nSee also\n\n`bloch`, `similarmatrix`\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.bravais-Tuple{Quantica.AbstractLattice}","page":"Reference","title":"Quantica.bravais","text":"bravais(lat::Lattice)\nbravais(h::Hamiltonian)\n\nObtain the Bravais matrix of lattice lat or Hamiltonian h\n\nExamples\n\njulia> lat = lattice(sublat((0,0)), bravais = ((1.0, 2), (3, 4)));\n\njulia> bravais(lat)\n2√ó2 SMatrix{2, 2, Float64, 4} with indices SOneTo(2)√óSOneTo(2):\n 1.0  3.0\n 2.0  4.0\n\nSee also\n\n`lattice`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.chebyshev_filter","page":"Reference","title":"Quantica.chebyshev_filter","text":"`chebyshev!(b::DACPbuilder)`\n\ncomputes the action of a K'th order Chebyshev polynomial Tnk(ùîΩ) on a random ket b.œà0.  ùîΩ = (‚Ñç^2 - Ec)/E0 is the operator that maps the spectral window (a¬≤, Emax¬≤) of ‚Ñç^2 into the interval x ‚àà (-1, 1) where the Tnk(x) is cosine like. As a result of this  transformation, the ket components in the (0, a¬≤) interval of ‚Ñç¬≤ will be exponentially amplified.      -> Iterate over kets to increase performance eps != 0 adds performs the exponential filtering in a slighlty larger interval (this is to avoid subsampling at the edges of the spectrum) - desabled\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.combine-Tuple{Vararg{Quantica.Hamiltonian,N} where N}","page":"Reference","title":"Quantica.combine","text":"combine(hams::Hamiltonian...; coupling = missing)\n\nBuild a new Hamiltonian h that combines all hams as diagonal blocks, and applies coupling::Model, if provided, to build the off-diagonal couplings. Note that the diagonal blocks are not modified by the coupling model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.combine-Tuple{Vararg{Quantica.Lattice,N} where N}","page":"Reference","title":"Quantica.combine","text":"combine(lats::Lattice...)\n\nIf all lats have compatible Bravais vectors, combine them into a single lattice. Sublattice names are renamed to be unique if necessary.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.cuboid-Union{Tuple{Vararg{Tuple,L}}, Tuple{L}} where L","page":"Reference","title":"Quantica.cuboid","text":"cuboid(ticks...; subticks = 13)\n\nCreate a CuboidMesh of L-dimensional marching-tetrahedra over a cuboid aligned with the Cartesian axes. The dimension L is given by the number of ticks, each of the form (x‚ÇÅ, x‚ÇÇ,...). The interval between x‚±º and x‚±º‚Çä‚ÇÅ ticks in axis i are further subdivided to have a number of subticks including endpoints. The number is subticks if subticks is an Integer, subticks[i] if subticks = (s‚ÇÅ, s‚ÇÇ,...) or subticks[i][j] if subticks = ((s‚ÇÅ‚ÇÅ, s‚ÇÅ‚ÇÇ,...), (s‚ÇÇ‚ÇÅ, s‚ÇÇ‚ÇÇ,...), ...).\n\nExamples\n\njulia> cuboid((-œÄ, œÄ), (0, 2œÄ); subticks = 25)\nCuboidMesh{2}: a mesh of a 2D parameter cuboid\n  Ranges     : ((-3.141592653589793, 3.141592653589793), (0.0, 6.283185307179586))\n  Axes ticks : (25, 25)\n  Simplices  : (24, 24, 2) -> 1152\n\njulia> cuboid((-œÄ, œÄ), (0, 2œÄ); subticks = (10, 10))\nCuboidMesh{2}: a mesh of a 2D parameter cuboid\n  Ranges     : ((-3.141592653589793, 3.141592653589793), (0.0, 6.283185307179586))\n  Axes ticks : (10, 10)\n  Simplices  : (9, 9, 2) -> 162\n\nExternal links\n\nMarching tetrahedra (https://en.wikipedia.org/wiki/Marching_tetrahedra) in Wikipedia\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.deflate-Tuple{Any,Any,Any}","page":"Reference","title":"Quantica.deflate","text":"deflation procedure using two (Householder) QR factorisations with complete pivoting\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.degeneracy-Tuple{Quantica.Subspace}","page":"Reference","title":"Quantica.degeneracy","text":"degeneracy(s::Subspace)\n\nReturn the degeneracy of a given energy subspace. It is equal to size(s.basis, 2).\n\nSee also\n\n`spectrum`, `bandstructure`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.densityKPM-Tuple{Any,Any}","page":"Reference","title":"Quantica.densityKPM","text":"densityKPM(h::Hamiltonian, A; resolution = 2, ket = randomkets(1), kw...)\n\nCompute, using the Kernel Polynomial Method (KPM), the spectral density of A, œÅ·¥¨‚Çñ(œµ) = ‚ü®k|A Œ¥(œµ-h)|k‚ü© for a ket |k‚ü© = ket(ket::KetModel, h) or |k‚ü© = ket::Ket (depending on the type of ket). The result is a tuple of energy points œµ·µ¢::Vector spanning the band range, and real œÅ·¥¨‚Çñ(œµ·µ¢)::Vector values. The number of energy points œµ·µ¢ is order * resolution, rounded to the closest integer.\n\nIf ket is a collection of KetModels, the sum ‚àë‚ÇñœÅ·¥¨‚Çñ(Œµ) over all models will be computed. In the case of the default ket = randomkets(n), this results in an estimate of the average spectral density per orbital, computed through an stochastic trace, œÅ·¥¨(œµ) = ‚àë‚Çñ‚ü®k|Œ¥(œµ-h)A|k‚ü©/n ‚âà Tr[Œ¥(œµ-h)A]/N‚ÇÄ, where N‚ÇÄ is the total number of orbitals in the unit cell.\n\ndensityKPM(Œº::MomentaKPM; resolution = 2)\n\nSame as above with KPM momenta Œº as input.\n\nSee also\n\n`dosKPM`, `momentaKPM`, `averageKPM`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.diagonalizer-Tuple{Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian}}","page":"Reference","title":"Quantica.diagonalizer","text":"diagonalizer(h::Union{Hamiltonian,ParametricHamiltonian}; method = LinearAlgebraPackage(), mapping = missing)\n\nBuild a d::Diagonalizer object that, when called as d(œÜs) , uses the specified diagonalization method to produce the sorted eigenpairs (Œµs, œàs) of h at Bloch phases/parameters given by mapping. See bandstructure for further details.\n\nA 0D Hamiltonian h also supports d = diagonalizer(h). In this case d can be called with no arguments and gives the same information as spectrum, d() ‚âà Tuple(spectrum(h)).\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |> hamiltonian(hopping(1));\n\njulia> d = diagonalizer(h)\nDiagonalizer with method : LinearAlgebraPackage{NamedTuple{(), Tuple{}}}\n\njulia> d((0, 0)) |> first\n2-element Vector{Float64}:\n -3.0\n  3.0\n\njulia> h = wrap(h); d = diagonalizer(h);\n\njulia> d() .‚âà Tuple(spectrum(h))\n(true, true)\n\nSee also\n\n`bandstructure`, `spectrum`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.dims-Union{Tuple{Quantica.AbstractLattice{E,L,T} where T}, Tuple{L}, Tuple{E}} where L where E","page":"Reference","title":"Quantica.dims","text":"dims(lh::Union{Hamiltonian,AbstractLattice}) -> (E, L)\n\nReturn a tuple (E, L) of the embedding E and lattice dimensions L of AbstractLattice or Hamiltonian lh\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.dosKPM-Tuple{Any}","page":"Reference","title":"Quantica.dosKPM","text":"dosKPM(h::Hamiltonian; resolution = 2, ket = randomkets(1), kw...)\n\nCompute, using the Kernel Polynomial Method (KPM), the local density of states œÅ‚Çñ(œµ) = ‚ü®k|Œ¥(œµ-h)|k‚ü© for a ket |k‚ü© = ket(ket::KetModel, h) or |k‚ü© = ket::Ket (depending on the type of ket). The result is a tuple of energy points œµ·µ¢::Vector spanning the band range, and real œÅ‚Çñ(œµ·µ¢)::Vector values (any residual imaginary part in œÅ‚Çñ is dropped). The number of energy points œµ·µ¢ is order * resolution, rounded to the closest integer.\n\nIf ket is a collection of KetModels, the sum ‚àë‚ÇñœÅ‚Çñ(Œµ) over all models will be computed. In the case of the default ket = randomkets(n), this results in an estimate of the total density of states per orbital, computed through an stochastic trace, œÅ(œµ) = ‚àë‚Çñ‚ü®k|Œ¥(œµ-h)|k‚ü©/n ‚âà Tr[Œ¥(œµ-h)]/N‚ÇÄ, where N‚ÇÄ is the total number of orbitals in the unit cell.\n\ndosKPM is a particular case of densityKPM for an operator A = I and with any residual imaginary parts dropped\n\ndosKPM(Œº::MomentaKPM; resolution = 2)\n\nSame as above with KPM momenta Œº as input.\n\nSee also\n\n`momentaKPM`, `densityKPM`, `averageKPM`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.flatten-Tuple{}","page":"Reference","title":"Quantica.flatten","text":"flatten(h::Hamiltonian)\n\nFlatten a multiorbital Hamiltonian h into one with a single orbital per site. The associated lattice is flattened also, so that there is one site per orbital for each initial site (all at the same position). Note that in the case of sparse Hamiltonians, zeros in hopping/onsite matrices are preserved as structural zeros upon flattening.\n\nflatten(k::Ket)\n\nFlattens a multiorbital Ket to have a scalar eltype, instead of SVector.\n\nflatten(s::Subspace)\n\nRebuild s by flattening its basis to have a scalar eltype.\n\nx |> flatten()\n\nCurried form equivalent to flatten(x) or x |> flatten (included for consistency with the rest of the API).\n\nflatten(x, o::OrbitalStructure)\n\nFlatten object x, if applicable, using the orbital structure o, as obtained from a Hamiltonian h with orbitalstructure(h). x here is typically an AbstractArray of non-scalar eltype.\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |>\n           hamiltonian(hopping(@SMatrix[1; 2], range = 1/‚àö3, sublats = :A =>:B),\n           orbitals = (Val(1), Val(2)))\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 √ó 2\n  Orbitals         : ((:a,), (:a, :a))\n  Element type     : 2 √ó 2 blocks (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 3\n  Coordination     : 1.5\n\njulia> flatten(h)\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)\n  Harmonic size    : 3 √ó 3\n  Orbitals         : ((:flat,), (:flat,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 2.0\n\nSee also\n\n`unflatten`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.gap-Tuple{Quantica.Bandstructure{1,C,T,B,M} where M<:Quantica.Diagonalizer where B<:(Quantica.Band{1,C,T,S,S¬¥,D¬¥} where D¬¥ where S¬¥<:(AbstractArray{T,2} where T) where S<:AbstractArray{C,2}) where T where C,Any}","page":"Reference","title":"Quantica.gap","text":"gap(b::Bandstructure{1}, Œµ‚ÇÄ; refinesteps = 0)\n\nCompute the gap if a 1D bandstructure b around Œµ‚ÇÄ, if any.\n\nSee also:\n\n`gapedge`, `minima`, `maxima`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.gapedge-Tuple{Quantica.Bandstructure{1,C,T,B,M} where M<:Quantica.Diagonalizer where B<:(Quantica.Band{1,C,T,S,S¬¥,D¬¥} where D¬¥ where S¬¥<:(AbstractArray{T,2} where T) where S<:AbstractArray{C,2}) where T where C,Any}","page":"Reference","title":"Quantica.gapedge","text":"gapedge(b::Bandstructure{1}, Œµ‚ÇÄ; refinesteps = 0)\n\nFor a 1D bandstructure b, compute two tuples, (œÜ‚Çä, Œµ‚Çä) and (œÜ‚Çã, Œµ‚Çã), of band points closest in energy to Œµ‚ÇÄ, from above and below, respectively. If Œµ‚ÇÄ is inside a band or outside the global bandwidth, œÜ‚Çä and œÜ‚Çã will be missing. See minima or maxima for details about refinesteps.\n\ngapedge(b::Bandstructure{1}, Œµ‚ÇÄ, +; kw...)\ngapedge(b::Bandstructure{1}, Œµ‚ÇÄ, -; kw...)\n\nCompute only (œÜ‚Çä, Œµ‚Çä) or (œÜ‚Çã, Œµ‚Çã), respectively.\n\nSee also:\n\n`gap`, `minima`, `maxima`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.greens-Union{Tuple{L}, Tuple{Quantica.Hamiltonian{#s39,L,M,A,H,O} where O<:Quantica.OrbitalStructure where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where #s39,Any}} where L","page":"Reference","title":"Quantica.greens","text":"greens(h::Hamiltonian, solveobject; boundaries::NTuple{L,Integer} = missing)\n\nConstruct the Green's function g::GreensFunction of L-dimensional Hamiltonian h using the provided solveobject. Currently valid solveobjects are\n\nSchur1D() (single-shot generalized eigenvalue approach for 1D Hamiltonians)\n\nIf a boundaries = (n‚ÇÅ, n‚ÇÇ, ...) is provided, a reflecting boundary is assumed for each non-missing n·µ¢ perpendicular to Bravais vector i at a cell distance n·µ¢ from the origin.\n\nh |> greens(h -> solveobject(h), args...)\n\nCurried form equivalent to the above, giving greens(h, solveobject(h), args...).\n\ng(œâ, cells::Pair)\ng(œâ)[cells::Pair]\n\nFrom a constructed g::GreensFunction, obtain the retarded Green's function matrix at frequency œâ between unit cells src and dst, where src, dst are ::NTuple{L,Int} or SVector{L,Int}. If allowed by the used solveobject, g0=g(œâ) builds an solution object that can efficiently produce the Greens function between different cells at fixed œâ with g0[cells] without repeating cell-independent parts of the computation.\n\nExamples\n\njulia> g = LatticePresets.square() |> hamiltonian(hopping(-1)) |> unitcell((1,0), region = r->0<r[2]<3) |> greens(Schur1D())\nGreensFunction{Schur1DGreensSolver}: Green's function using the Schur1D method\n  Flat matrix size      : 2 √ó 2\n  Flat deflated size    : 2 √ó 2\n  Original element type : scalar (ComplexF64)\n  Boundaries            : (missing,)\n\njulia> g(0.2, 3=>2) ‚âà g(0.2)[3=>2]\ntrue\n\nSee also\n\n`Schur1D`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.hamiltonian-Tuple{Quantica.AbstractLattice,Vararg{Any,N} where N}","page":"Reference","title":"Quantica.hamiltonian","text":"hamiltonian(lat, model; orbitals, orbtype)\n\nCreate a Hamiltonian by applying model::TighbindingModel to the lattice lat (see hopping and onsite for details on building tightbinding models).\n\nlat |> hamiltonian(model; kw...)\n\nCurried form of hamiltonian equivalent to hamiltonian(lat, model; kw...).\n\nKeywords\n\nThe number of orbitals on each sublattice can be specified by the keyword orbitals (otherwise all sublattices have one orbital by default). The following, and obvious combinations, are possible formats for the orbitals keyword:\n\norbitals = :a                # all sublattices have 1 orbital named :a\norbitals = (:a,)             # same as above\norbitals = (:a, :b, 3)       # all sublattices have 3 orbitals named :a and :b and :3\norbitals = ((:a, :b), (:c,)) # first sublattice has 2 orbitals, second has one\norbitals = ((:a, :b), :c)    # same as above\norbitals = (Val(2), Val(1))  # same as above, with automatic names\norbitals = (:A => (:a, :b), :D => :c) # sublattice :A has two orbitals, :D and rest have one\norbitals = :D => Val(4)      # sublattice :D has four orbitals, rest have one\n\nThe matrix sizes of tightbinding model must match the orbitals specified. Internally, we define a block size N = max(num_orbitals). If N = 1 (all sublattices with one orbital) the Hamiltonian element type is orbtype. Otherwise it is SMatrix{N,N,orbtype} blocks, padded with the necessary zeros as required. Keyword orbtype is Complex{T} by default, where T is the number type of lat.\n\nIndexing\n\nIndexing into a Hamiltonian h works as follows. Access the HamiltonianHarmonic matrix at a given dn::NTuple{L,Int} with h[dn]. The special h[] syntax stands for h[(0...)] for the zero-harmonic. Assign v into element (i,j) of said matrix with h[dn][i,j] = v. Broadcasting with vectors of indices is and js is supported, h[dn][is, js] = v_matrix.\n\nA slicing syntax h[rows, cols] (without specifying dn) is also available, that creates a special hs::Slice{<:Hamiltonian} object that represents a slice of the Hamiltonian matrix restricted to rows and cols. Here, rows and cols are collections of site indices, or alternatively SiteSelectors (see siteselectors for details). If rows::Integer or cols::Integer, they will be converted to a single-element range (to preserve always a matrix-like slice, unlike for AbstractArray indexing). Slices support bloch and bloch! to produce the corresponding matrices, and can also be indexed as hs[dn::Tuple] that produces the equivalent to h[dn][rows, cols].\n\nTo add an empty harmonic with a given dn::NTuple{L,Int}, do push!(h, dn). To delete it, do deleteat!(h, dn).\n\nExamples\n\njulia> h = hamiltonian(LatticePresets.honeycomb(), hopping(@SMatrix[1 2; 3 4], range = 1/‚àö3), orbitals = Val(2))\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 √ó 2\n  Orbitals         : ((:a, :a), (:a, :a))\n  Element type     : 2 √ó 2 blocks (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 3.0\n\njulia> push!(h, (3,3)) # Adding a new Hamiltonian harmonic (if not already present)\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 6 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 √ó 2\n  Orbitals         : ((:a, :a), (:a, :a))\n  Element type     : 2 √ó 2 blocks (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 3.0\n\njulia> h[(3,3)][1,1] = @SMatrix[1 2; 2 1]; h[(3,3)] # element assignment\n2√ó2 SparseMatrixCSC{SMatrix{2, 2, ComplexF64, 4}, Int64} with 1 stored entry:\n [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]                      ‚ãÖ                     \n                     ‚ãÖ                                           ‚ãÖ                     \n\njulia> h[(3,3)][[1,2],[1,2]] .= Ref(@SMatrix[1 2; 2 1])\n2√ó2 SparseMatrixCSC{SMatrix{2, 2, ComplexF64, 4}, Int64} with 4 stored entries:\n [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]\n [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]\n\n julia> h = unitcell(h); h[]\n2√ó2 SparseMatrixCSC{SMatrix{2, 2, ComplexF64, 4}, Int64} with 2 stored entries:\n                     ‚ãÖ                       [1.0+0.0im 2.0+0.0im; 3.0+0.0im 4.0+0.0im]\n [1.0+0.0im 2.0+0.0im; 3.0+0.0im 4.0+0.0im]                      ‚ãÖ                     \n\n\nSee also\n\n`onsite`, `hopping`, `bloch`, `bloch!`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.hopping-Tuple{Any}","page":"Reference","title":"Quantica.hopping","text":"hopping(t; range = nrange(1), dn = missing, sublats = missing, indices = missing, region = missing, plusadjoint = false)\n\nCreate an TightbindingModel with a single HoppingTerm that applies a hopping t to a Lattice when creating a Hamiltonian with hamiltonian.\n\nThe hopping amplitude t can be a number, an SMatrix, a UniformScaling (e.g. 3*I) or a function of the form (r, dr) -> ... for a position-dependent hopping (r is the bond center, and dr the bond vector). If sublats is specified as a sublattice name pair, or tuple thereof, hopping is only applied between sublattices with said names.\n\nThe dimension of t::AbstractMatrix must match the orbital dimension of applicable sublattices (see also orbitals option for hamiltonian). If t::UniformScaling it will be converted to a (possibly rectangular) identity matrix of the appropriate size when applied to multiorbital sublattices. Similarly, if t::SMatrix it will be truncated or padded to the appropriate size.\n\nOnsiteTerms and HoppingTerms created with onsite or hopping can be added or substracted together to build more complicated TightbindingModels.\n\nhopping(model::TightbindingModel; kw...)\n\nReturn a TightbindingModel with only the hopping terms of model. Any non-missing kw is applied to all such terms.\n\nKeyword arguments\n\nMost keywords are the same as for hopselector. Only hoppings between two sites at positions r‚ÇÅ = r - dr/2 and r‚ÇÇ = r + dr, belonging to unit cells at integer distance dn¬¥ and to sublattices s‚ÇÅ and s‚ÇÇ will be selected if: region(r, dr) && s in sublats && dn¬¥ in dn && norm(dr) <= range. If any of these is missing it will not be used to constraint the selection.\n\nThe keyword range admits the following possibilities\n\nmax_range                   # i.e. `norm(dr) <= max_range`\n(min_range, max_range)      # i.e. `min_range <= norm(dr) <= max_range`\n\nBoth max_range and min_range can be a Real or a NeighborRange created with nrange(n). The latter represents the distance of n-th nearest neighbors. Note that the range default for hopping (unlike for the more general hopselector) is nrange(1), i.e. first-nearest-neighbors.\n\nThe keyword dn can be a Tuple/Vector/SVector of Ints, or a tuple thereof. The keyword sublats allows the following formats:\n\nsublats = :A => :B                 # Hopping from :A to :B sublattices\nsublats = (:A => :B,)              # Same as above\nsublats = (:A => :B, :C => :D)     # Hopping from :A to :B or :C to :D\nsublats = (:A, :C) .=> (:B, :D)    # Broadcasted pairs, same as above\nsublats = (:A, :C) => (:B, :D)     # Direct product, (:A=>:B, :A=:D, :C=>:B, :C=>D)\n\nThe keyword plusadjoint produces a model with the input hopping term plus its adjoint. Note that this substitution is made before multiplying by any coefficient, so that im*hopping(..., plusadjoint = true) == im*(hopping(...) + hopping(...)').\n\nCombining models\n\nOnsiteTerms and HoppingTerms created with onsite or hopping can added or substracted together or be multiplied by scalars to build more complicated TightbindingModels, e.g. onsite(1) - 3 * hopping(2)\n\nExamples\n\njulia> model = 3 * onsite(1) - hopping(2, dn = ((1,2), (0,0)), sublats = :A=>:B)\nTightbindingModel{2}: model with 2 terms\n  OnsiteTerm{Int64}:\n    Sublattices      : any\n    Coefficient      : 3\n  HoppingTerm{Int64}:\n    Sublattice pairs : :A => :B\n    dn cell distance : ([1, 2], [0, 0])\n    Hopping range    : NeighborRange(1)\n    Coefficient      : -1\n\njulia> newmodel = onsite(model) + hopping(model, range = 2)\nTightbindingModel{2}: model with 2 terms\n  OnsiteTerm{Int64}:\n    Sublattices      : any\n    Coefficient      : 3\n  HoppingTerm{Int64}:\n    Sublattice pairs : :A => :B\n    dn cell distance : ([1, 2], [0, 0])\n    Hopping range    : 2.0\n    Coefficient      : -1\n\njulia> LatticePresets.honeycomb() |> hamiltonian(hopping((r,dr) -> cos(r[1]), sublats = (:A,:B) => (:A,:B)))\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 √ó 2\n  Orbitals         : ((:a,), (:a,))\n  Element type     : scalar (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 3.0\n\nSee also\n\n`onsite`, `nrange`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.hopselector-Tuple{}","page":"Reference","title":"Quantica.hopselector","text":"hopselector(; range = missing, dn = missing, sublats = missing, indices = missing, region = missing)\n\nReturn a HopSelector object that can be used to select hops between two sites in a lattice. Only hops between two sites, with indices ipair = src => dst, at positions r‚ÇÅ = r - dr/2 and r‚ÇÇ = r + dr, belonging to unit cells at integer distance dn¬¥ and to sublattices s‚ÇÅ and s‚ÇÇ will be selected if:\n\n`region(r, dr) && s in sublats && dn¬¥ in dn && norm(dr) <= range && ipair in indices`\n\nIf any of these is missing it will not be used to constraint the selection.\n\nThe keyword range admits the following possibilities\n\nmax_range                   # i.e. `norm(dr) <= max_range`\n(min_range, max_range)      # i.e. `min_range <= norm(dr) <= max_range`\n\nBoth max_range and min_range can be a Real or a NeighborRange created with nrange(n). The latter represents the distance of n-th nearest neighbors.\n\nThe keyword dn can be a Tuple/Vector/SVector of Ints, or a tuple thereof.\n\nThe keyword sublats allows the following formats:\n\nsublats = :A => :B                  # Hopping from :A to :B sublattices, but not from :B to :A\nsublats = (:A => :B,)               # Same as above\nsublats = (:A => :B, :C => :D)      # Hopping from :A to :B or :C to :D\nsublats = (:A, :C) .=> (:B, :D)     # Broadcasted pairs, same as above\nsublats = (:A, :C) => (:B, :D)      # Direct product, (:A=>:B, :A=:D, :C=>:B, :C=>D)\n\nThe keyword indices accepts a single src => dest pair or a collection thereof. Any src == dest will be neglected. Possible combinations:\n\nindices = 1 => 2                    # Hopping from site 1 to 2, but not from 2 to 1\nindices = (1 => 2, 2 => 1)          # Hoppings from 1 to 2 or from 2 to 1\nindices = [1 => 2, 2 => 1]          # Same as above\nindices = [(1, 2) .=> (2, 1)]       # Broadcasted pairs, same as above\nindices = [1:10 => 20:25, 3 => 30]  # Direct product, any hopping from sites 1:10 to sites 20:25, or from 3 to 30\n\nAdditionally, indices or sublattices can be wrapped in not to exclude them (see not):\n\nsublats = not(:A => :B, :B => :A)   # Any sublat pairs different from :A => :B or :B => :A\nsublats = not(:A) => :B             # Any sublat pair s1 => s2 with s1 different from :A and s2 equal to :B\nindices = not(8 => 9)               # Any site indices different from 8 => 9\nindices = 1 => not(3:4)             # Any site pair 1 => s with s different from 3, 4\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.ijselector-NTuple{4,Any}","page":"Reference","title":"Quantica.ijselector","text":"auxvec is organized s.t. {1, Tk1-2, Tk1-1, Tk1, Tk1+1, Tk2-1, ...}, given two indices  (i,j), ijselector(i, j) returns  a couple of indices x+y, abs(x-y) for the calculation of s and h see eq (22) of scipost20210600048v3.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.isinband-Tuple{Quantica.Bandstructure,Any}","page":"Reference","title":"Quantica.isinband","text":"isinband(b::Bandstructure, Œµ)\nisinband(b::Band, Œµ)\n\nReturns true if Œµ is contained within a band, false otherwise.\n\nSee also:\n\n`gap`, `minima`, `maxima`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.iterateDACP_f!-NTuple{4,Any}","page":"Reference","title":"Quantica.iterateDACP_f!","text":"action of the chebyshev iteration of the operator F on a state x\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.iterateDACP_g!-NTuple{4,Any}","page":"Reference","title":"Quantica.iterateDACP_g!","text":"action of the chebyshev iteration of the operator G on a state x\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.iterate_chebyshev-Tuple{Any,Array{Array{Complex{Float64},2},1},Any,Any,Any}","page":"Reference","title":"Quantica.iterate_chebyshev","text":"`iterate_chebyshev(K, œà0::Vector{Matrix{ComplexF64}}, œà1, hsquared, bounds)`\n\nreturns the action TK(ùîΩ)|œà0‚ü© on a block of random vectors œà0 see: semicircle_filter(). numkets Cheby loops are required. \n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.ket-Tuple{AbstractArray{T,1} where T,Quantica.OrbitalStructure}","page":"Reference","title":"Quantica.ket","text":"ket(m::AbstractArray, o::OrbitalStructure)\nket(m::AbstractArray, h::Hamiltonian)\n\nConstruct a Ket |k‚ü© with amplitudes ‚ü®i|k‚ü© = m[i], which can be scalars or SVectors depending on the number of orbitals on site i. If m is an AbstractMatrix instead of an AbstractVector, the Ket represents a multi-column ket (i.e. a collection of kets |k‚±º‚ü©, one per column), such that ‚ü®i|k‚±º‚ü© = m[i,j]. The orbitals per sublattice are encoded in o = orbitalstructure(h).\n\nket(km::KetModel, h::Hamiltonian)\n\nConstruct a Ket by applying model km to Hamiltonian h (see also ketmodel for details).\n\nket(h::Hamiltonian)\n\nConstruct a zero ket, equivalent to ket(0, h; maporbitals = true, normalization = missing)\n\nSee also\n\n`ketmodel`, `ket!`, `onsite`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.ketmodel-Tuple{Any}","page":"Reference","title":"Quantica.ketmodel","text":"ketmodel(a; region = missing, sublats = missing, normalization = 1, maporbitals = false, singlesitekets = false)\n\nCreate an KetModel of amplitude a on any site in the specified region and sublats. For single-column kets, the amplitude a can be a Number, an AbstractVector, or for a position-dependent amplitude a function of the form r -> ... returning either. For multi-column kets, make a an AbstractMatrix{<:Number} or a function returning one, which will be sliced into each ket column as appropriate. An error will be thrown if the slicing is impossible, due e.g. to a mismatch of size(a, 1) and the number of orbitals in an applicable sublattice.\n\nKeyword arguments\n\nIf keyword normalization is not missing or false, each column of the ket will be rescaled to have norm normalization when the KetModel is applied to a specific Hamiltonian. If a ket column iszero, however, it will not be normalized.\n\nIf keyword maporbitals = true and amplitude a is a scalar or a scalar function, a will be applied to each orbital independently. This is particularly useful in multiorbital systems with random amplitudes, e.g. a = r -> randn(). If a is not a scalar and maporbitals == true, an error will be thrown.\n\nIf keyword singlesitekets = true, then the model represents a multicolumn ket, where each column (or block of columns for a::AbstractMatrix) has amplitude a on a single site of those selected by region and sublats (as opposed to having the same amplitude a on all said sites if singlesitekets = false). This is useful e.g. to build a basis for the selected sites.\n\nKeywords region and sublats are the same as for siteselector. Only sites at position r in sublattice with name s::NameType will be selected if region(r) && s in sublats is true. Any missing region or sublat will not be used to constraint the selection.\n\nThe keyword sublats allows the following formats:\n\nsublats = :A           # Onsite on sublat :A only\nsublats = (:A,)        # Same as above\nsublats = (:A, :B)     # Onsite on sublat :A and :B\n\nKet algebra\n\nKetModels created with ket can added or substracted together or be multiplied by scalars to build more elaborate KetModels, e.g. ket(1) - 3 * ket(2, region = r -> norm(r) < 10). Only models with the same maporbitals can be combined. When combining two models with different singlesitekets, the result has singlesitekets = true.\n\nExamples\n\njulia> k = ketmodel(1, sublats=:A) - ketmodel(1, sublats=:B)\nKetModel{2}: model with 2 terms\n  Normalization : 1\n  Map orbitals  : Val{false}()\n  OnsiteTerm{Int64}:\n    Sublattices      : A\n    Coefficient      : 1\n  OnsiteTerm{Int64}:\n    Sublattices      : B\n    Coefficient      : -1\n\nSee also\n\n`ket`, `onsite`, `orbitalstructure`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.lattice-Tuple{Vararg{Quantica.Sublat,N} where N}","page":"Reference","title":"Quantica.lattice","text":"lattice(sublats::Sublat...; bravais = (), dim::Val{E}, type::T, names = missing)\n\nCreate a Lattice{E,L,T} with Bravais vectors bravais and sublattices sublats converted to a common  E-dimensional embedding space and type T. To override the embedding  dimension E, use keyword dim = Val(E). Similarly, override type T with type = T.\n\nThe keyword bravais indicates one or more Bravais vectors in the form of tuples or other iterables. It can also be an AbstractMatrix of dimension E√óL. The default bravais = () corresponds to a bounded lattice with no Bravais vectors.\n\nA keyword names can be used to rename sublats. Given names can be replaced to ensure that all sublattice names are unique.\n\nlattice(lat::AbstractLattice; bravais = missing, dim = missing, type = missing, names = missing)\n\nCreate a new lattice by applying any non-missing kw to lat. For performance, allocations will be avoided if possible (depends on kw), so the result can share memory of lat. To avoid that, do lattice(copy(lat); kw...).\n\nSee also LatticePresets for built-in lattices.\n\nExamples\n\njulia> lattice(sublat((0, 0)), sublat((0, Float32(1))); bravais = (1, 0), dim = Val(3))\nLattice{3,1,Float32} : 1D lattice in 3D space\n  Bravais vectors : ((1.0f0, 0.0f0, 0.0f0),)\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (1, 1) --> 2 total per unit cell\n\njulia> LatticePresets.honeycomb(names = (:C, :D))\nLattice{2,2,Float64} : 2D lattice in 2D space\n  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))\n  Sublattices     : 2\n    Names         : (:C, :D)\n    Sites         : (1, 1) --> 2 total per unit cell\n\njulia> LatticePresets.cubic(bravais = ((1, 0), (0, 2)))\nLattice{3,2,Float64} : 2D lattice in 3D space\n  Bravais vectors : ((1.0, 0.0, 0.0), (0.0, 2.0, 0.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (1) --> 1 total per unit cell\n\nSee also\n\n`LatticePresets`, `bravais`, `sublat`, `supercell`, `intracell`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.maxima-Union{Tuple{Quantica.Bandstructure{1,#s35,T,B,M} where M<:Quantica.Diagonalizer where B<:(Quantica.Band{1,#s35,T,S,S¬¥,D¬¥} where D¬¥ where S¬¥<:(AbstractArray{T,2} where T) where S<:AbstractArray{#s35,2}) where #s35}, Tuple{T}} where T","page":"Reference","title":"Quantica.maxima","text":"maxima(b::Bandstructure{1}; refinesteps = 0)\n\nFor a 1D bandstructure b, compute a vector of Vector{Tuple{T,T}}s (one per band), containing pairs (œÜ, Œµ) of Bloch phase and energy where the band, as sampled, has a local maximum. The maxima will be further refined by a number refinesteps of bisections steps. Only band vertices with one neighbors on each side will be considered as potential local maximum.\n\nSee also:\n\n`minima`, `gapedge`, `gap`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.minima-Union{Tuple{Quantica.Bandstructure{1,#s35,T,B,M} where M<:Quantica.Diagonalizer where B<:(Quantica.Band{1,#s35,T,S,S¬¥,D¬¥} where D¬¥ where S¬¥<:(AbstractArray{T,2} where T) where S<:AbstractArray{#s35,2}) where #s35}, Tuple{T}} where T","page":"Reference","title":"Quantica.minima","text":"minima(b::Bandstructure{1}; refinesteps = 0)\n\nFor a 1D bandstructure b, compute a vector of Vector{Tuple{T,T}}s (one per band), containing pairs (œÜ, Œµ) of Bloch phase and energy where the band, as sampled, has a local minimum. The minima will be further refined by a number refinesteps of bisections steps. Only band vertices with one neighbors on each side will be considered as potential local minimum.\n\nSee also:\n\n`maxima`, `gapedge`, `gap`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.momentaKPM","page":"Reference","title":"Quantica.momentaKPM","text":"momentaKPM(h::Hamiltonian, A = I; ket = randomkets(1), order = 10, bandrange = missing, flat = Val(true))\n\nCompute the Kernel Polynomial Method (KPM) momenta Œº‚Çô = ‚ü®k|T‚Çô(h) A|k‚ü©, where |k‚ü© = ket(ket::KetModel, h) or |k‚ü© = ket::Ket (depending on the type of ket), A is an observable (Hamiltonian or AbstractMatrix) and T‚Çô(h) is the order-n Chebyshev polynomial of the Hamiltonian h.\n\nket can be a single KetModel or Ket, as above, or a collection of them, as in the default ket = randomkets(n). In the latter case, Œº‚Çô is summed over all models/kets, Œº‚Çô = ‚àë_k ‚ü®k|T‚Çô(h) A|k‚ü©. If ket::Ket is a multi-column ket, a sum over columns will similarly be performed. A ket = randomkets(n) produces a lazy collection of n random KetModels that is useful to estimate momenta of normalized traces using the stochastic trace approach, whereby Œº_n = Tr[A T_n(h)]/N‚ÇÄ ‚âà ‚àë‚Çñ‚ü®k|A T_n(h)|k‚ü©. Here the |k‚ü©s are n random kets of norm 1/‚àön and N‚ÇÄ is the total number of orbitals per unit cell of h (see randomkets).\n\nThe order of the Chebyshev expansion is order. The bandbrange = (œµmin, œµmax) should completely encompass the full bandwidth of hamiltonian. If missing it is computed automatically using ArnoldiMethod (must be loaded using ArnoldiMethod). flat indicates whether, in the case of multiorbital systems, the internal computations are to be performed using flattened arrays, typically increasing performace by making use of external linear algebra libraries (e.g. MKL or OpenBLAS).\n\nExamples\n\njulia> h = LatticePresets.cubic() |> hamiltonian(hopping(1)) |> unitcell(region = RegionPresets.sphere(10));\n\njulia> momentaKPM(h, bandrange = (-6,6)).mulist |> length\n11\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.mul_f!-NTuple{4,Any}","page":"Reference","title":"Quantica.mul_f!","text":"returns the action of the operator F on a state x\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.mul_g!-NTuple{4,Any}","page":"Reference","title":"Quantica.mul_g!","text":"returns the action of the operator G on a state x\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.not-Tuple{Any}","page":"Reference","title":"Quantica.not","text":"not(i)\n\nWrapper indicating the negation or complement of i, typically used to encode excluded site indices. See siteselector and hopselector for applications.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.nrange-Tuple{Int64}","page":"Reference","title":"Quantica.nrange","text":"nrange(n::Int)\n\nCreate a NeighborRange that represents a hopping range to distances corresponding to the n-th nearest neighbors in a given lattice. Such distance is obtained by finding the n-th closest pairs of sites in a lattice, irrespective of their sublattice.\n\nnrange(n::Int, lat::AbstractLattice)\n\nObtain the actual nth-nearest-neighbot distance between sites in lattice lat.\n\nSee also\n\n`hopping`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.offdiagonal-Tuple{Quantica.TightbindingModel,Any,Any}","page":"Reference","title":"Quantica.offdiagonal","text":"offdiagonal(model, lat, nsublats::NTuple{N,Int})\n\nBuild a restricted version of model that applies only to off-diagonal blocks formed by sublattice groups of size nsublats.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.onsite-Tuple{Any}","page":"Reference","title":"Quantica.onsite","text":"onsite(o; region = missing, sublats = missing)\n\nCreate an TightbindingModel with a single OnsiteTerm that applies an onsite energy o to a Lattice when creating a Hamiltonian with hamiltonian.\n\nThe onsite energy o can be a number, an SMatrix, a UniformScaling (e.g. 3*I) or a function of the form r -> ... for a position-dependent onsite energy.\n\nThe dimension of o::AbstractMatrix must match the orbital dimension of applicable sublattices (see also orbitals option for hamiltonian). If o::UniformScaling it will be converted to an identity matrix of the appropriate size when applied to multiorbital sublattices. Similarly, if o::SMatrix it will be truncated or padded to the appropriate size.\n\nonsite(model::TightbindingModel; kw...)\n\nReturn a TightbindingModel with only the onsite terms of model. Any non-missing kw is applied to all such terms.\n\nKeyword arguments\n\nKeywords are the same as for siteselector. Only sites at position r in sublattice with name s::NameType will be selected if region(r) && s in sublats is true. Any missing region or sublat will not be used to constraint the selection.\n\nThe keyword sublats allows the following formats:\n\nsublats = :A           # Onsite on sublat :A only\nsublats = (:A,)        # Same as above\nsublats = (:A, :B)     # Onsite on sublat :A and :B\n\nCombining models\n\nOnsiteTerms and HoppingTerms created with onsite or hopping can added or substracted together or be multiplied by scalars to build more complicated TightbindingModels, e.g. onsite(1) - 3 * hopping(2)\n\nExamples\n\njulia> model = onsite(1, sublats = (:A,:B)) - 2 * hopping(2, sublats = :A=>:A)\nTightbindingModel{2}: model with 2 terms\n  OnsiteTerm{Int64}:\n    Sublattices      : (:A, :B)\n    Coefficient      : 1\n  HoppingTerm{Int64}:\n    Sublattice pairs : :A => :A\n    dn cell distance : any\n    Hopping range    : NeighborRange(1)\n    Coefficient      : -2\n\njulia> newmodel = onsite(model; sublats = :A) + hopping(model)\nTightbindingModel{2}: model with 2 terms\n  OnsiteTerm{Int64}:\n    Sublattices      : A\n    Coefficient      : 1\n  HoppingTerm{Int64}:\n    Sublattice pairs : :A => :A\n    dn cell distance : any\n    Hopping range    : NeighborRange(1)\n    Coefficient      : -2\n\njulia> LatticePresets.honeycomb() |> hamiltonian(onsite(r -> @SMatrix[1 2; 3 4]), orbitals = Val(2))\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 1 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 √ó 2\n  Orbitals         : ((:a, :a), (:a, :a))\n  Element type     : 2 √ó 2 blocks (ComplexF64)\n  Onsites          : 2\n  Hoppings         : 0\n  Coordination     : 0.0\n\nSee also\n\n`hopping`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.orbitalstructure-Tuple{Quantica.Hamiltonian}","page":"Reference","title":"Quantica.orbitalstructure","text":"orbitalstructure(x::Union{Hamiltonian,ParametricHamiltonian})\norbitalstructure(x::Subspace)\n\nReturn an OrbitalStructure containing information about the orbital structure of x\n\nExamples\n\njulia> sp = spectrum(LP.honeycomb() |> hamiltonian(hopping(I), orbitals = (:up,:down)) |> unitcell);\n\njulia> sp[around = -1] |> orbitalstructure\nOrbitalStructure:\n  Orbital Type  : SVector{2, ComplexF64}\n  Orbitals      : ((:up, :down), (:up, :down))\n  Sublattices   : 2\n  Dimensions    : 2\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.parameters-Tuple{Quantica.ParametricHamiltonian}","page":"Reference","title":"Quantica.parameters","text":"parameters(ph::ParametricHamiltonian)\n\nReturn the names of the parameter that ph depends on\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.parameters-Tuple{Vararg{Quantica.AbstractModifier,N} where N}","page":"Reference","title":"Quantica.parameters","text":"parameters(p::AbstractModifier...)\n\nReturn the parameter names for one or several AbstractModifier created with @onsite!, @hopping! or @block!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.parametric-Tuple{Quantica.Hamiltonian,Vararg{Quantica.AbstractModifier,N} where N}","page":"Reference","title":"Quantica.parametric","text":"parametric(h::Hamiltonian, modifiers::AbstractModifier...; check = true)\n\nBuilds a ParametricHamiltonian that can be used to efficiently apply modifiers to h. modifiers can be any number of @onsite!(args -> body; kw...) and @hopping!(args -> body; kw...) transformations, each with a set of parameters ps given as keyword arguments of functions f = (...; ps...) -> body.\n\nFor sparse h (the default), parametric only modifies existing onsites and hoppings in h, so be sure to add zero onsites and/or hoppings to h if they are originally not present but you need to apply modifiers to them.\n\nph(; ps...)\n\nFor a ph::ParametricHamiltonian, return the corresponding Hamiltonian with parameters ps applied.\n\nh |> parametric(modifiers::AbstractModifier...; kw...)\n\nFunction form of parametric, equivalent to parametric(h, modifiers...; kw...).\n\nKeywords\n\nIf the keyword argument check = true a check is performed upon each call h = ph(; ps...) to ensure that the harmonics of the produced Hamiltonian are all internally consistent with the orbital structure of h (i.e. if the provided modifiers do not create incorrect matrix elements). Unless the number of orbitals of h is the same in all sublattices, this check can have a substantial performance impact, so it is advisable to disable it with check = false once the user has confirmed that ph(; ps...) throws no error with check = true.\n\nIndexing\n\nIndexing into a ParametricHamiltonian, as in ph[rows, cols] creates a Slice{<:ParametricHamiltonian}, which is the parametric version of Slice{<:Hamiltonian}, see hamiltonian for details.\n\nExamples\n\njulia> ph = LatticePresets.honeycomb() |> hamiltonian(onsite(0) + hopping(1, range = 1/‚àö3)) |>\n       unitcell(10) |> parametric(@onsite!((o; Œº) -> o - Œº))\nParametricHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)\n  Harmonic size    : 200 √ó 200\n  Orbitals         : ((:a,), (:a,))\n  Element type     : scalar (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 600\n  Coordination     : 3.0\n  Parameters       : (:Œº,)\n  Check each call  : true\n\njulia> ph(Œº = 2)\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)\n  Harmonic size    : 200 √ó 200\n  Orbitals         : ((:a,), (:a,))\n  Element type     : scalar (ComplexF64)\n  Onsites          : 200\n  Hoppings         : 600\n  Coordination     : 3.0\n\nSee also\n\n`@onsite!`, `@hopping!`, `@block!`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.proj_DACP-Tuple{Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian},Any}","page":"Reference","title":"Quantica.proj_DACP","text":"given a h::Union{ParametricHamiltonian, Hamiltonian} returns the projection of h and of the overlap matrix, s to a lower subspace ùïÉ with eigenvalues inside the energy interval: (-a, a).  The dimension of the desired subspace must be given as an input d and  a < min(Emax, |Emin|)\n\nREMARKS:     - Validity is conditioned to the requirement a << emax     - in order to accurately span ùïÉ, we form a basis by Chebyshev evolution of          œàe using n = (l*d-1)/2 states with l>=1 (set by default to l = 1.5).     - for a given d, a must be appropriately chosen to ensure that the number of         eigenstates in [-a, a] is a little less than the dimension of constructed basis,          i.e. < 2n + 1 (overestimation). This requires prior knowledge about the spectrum         edges. However, the subspace dimension, d, can be efficiently determined using          the KPM method. \n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.proj_h_s-Tuple{Quantica.DACPsubspace,Any,Missing,Any}","page":"Reference","title":"Quantica.proj_h_s","text":"computes the reduced h and s matrices\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.qz_diag-Tuple{Any,Any}","page":"Reference","title":"Quantica.qz_diag","text":"codepath with schur diagonalization and a brute force rank revealing factorization\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.randomkets","page":"Reference","title":"Quantica.randomkets","text":"randomkets(n, a = r -> cis(2pi*rand()); kw...)\n\nCreate a lazy collection of n KetModels of amplitude a, and normalization = 1/‚àön. Other keyword arguments are forwarded to ketmodel.\n\nThis type of ket model is useful e.g. in stochastic trace evaluation of KPM methods, where the amplitude is chosen as a random function with ‚ü®a‚ü© = 0, ‚ü®aa‚ü© = 0 and ‚ü®a'a‚ü© = 1. The default a is a uniform random phase on each site, which satisties these conditions. Then, the normalized trace of an operator A can be estimated with Tr[A]/N‚ÇÄ ‚âà ‚àë‚ü®ket|A|ket‚ü©, where the sum is taken over the n random kets |ket‚ü© of norm 1/‚àön produced by randomkets, and N‚ÇÄ is the total number of orbitals in the full unit cell.\n\nTo apply it to a multiorbital system with a maximum of N orbitals per site, a must in general be adapted to produce the desired random SVector{N} (unless maporbitals = true), with the above statistical properties for each orbital. Example: to have independent, complex, normally-distributed random components of two orbitals use randomkets(n, r -> randn(SVector{2,ComplexF64})), or alternatively randomkets(n, r -> randn(ComplexF64), maporbitals = true).\n\nSee also\n\n`ket`\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.rank","page":"Reference","title":"Quantica.rank","text":"computes the rank of matrix of a given matrix A, using RA, an upper triangular matrix which comes from the A = QA R_A. A QR factorisation with complete pivoting\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.semicircle_filter-Tuple{Quantica.ParametricHamiltonian,Any}","page":"Reference","title":"Quantica.semicircle_filter","text":"`semicircle_filter(h::ParametricHamiltonian, a)`\n\nGiven an energy cutoff a::Float64, which defines the spectral window (-a, a), a  hamiltonian H, and a random ket œà s.t. |œà‚ü© = ‚àë·µ¢c·µ¢|œï·µ¢‚ü© + ‚àë‚±ºd‚±º|œá‚±º‚ü© where {|œï·µ¢‚ü©} and {|œáj‚ü©} are eigenstates in a subspace of H with energies inside (-a, a), it returns œà_e s.t. |œà‚Çë‚ü© ‚âà ‚àë·µ¢ c'·µ¢|œà·µ¢‚ü©, that is some linear combination of eigenstates that live in the ùïÉ  subspace by means of an exponential filter implemented by means of a Chebyshev iteration\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.similarmatrix","page":"Reference","title":"Quantica.similarmatrix","text":"similarmatrix(h::Hamiltonian)\n\nCreate an uninitialized matrix of the same type and size of the Hamiltonian's matrix.\n\nsimilarmatrix(h::Hamiltonian, T::Type{<:AbstractMatrix})\n\nMake the matrix of type B<:T. Can be used to specify a different eltype from h's, (e.g. T=SparseMatrixCSC{Float64} with a multiorbital h)\n\nsimilarmatrix(h::Hamiltonian, flatten)\n\nCreate an unitialized matrix of the same type as a flattened version of h's, i.e. with a scalar eltype as in the example above.\n\nsimilarmatrix(h::Hamiltonian, T::AbstractDiagonalizeMethod)\n\nAdapts the type of the matrix (e.g. dense/sparse) to the specified method\n\nsimilarmatrix(x::Union{ParametricHamiltonian, GreensFunction}, ...)\n\nEquivalent to the above, but adapted to the more general type of x.\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |> hamiltonian(hopping(I), orbitals = Val(2));\n\njulia> similarmatrix(h) |> summary\n\"2√ó2 SparseMatrixCSC{SMatrix{2, 2, ComplexF64, 4}, Int64}\"\n\njulia> similarmatrix(h, Matrix{Int}) |> summary\n\"4√ó4 Matrix{Int64}\"\n\njulia> similarmatrix(h, flatten) |> summary\n\"4√ó4 SparseMatrixCSC{ComplexF64, Int64}\"\n\njulia> similarmatrix(h, LinearAlgebraPackage()) |> summary\n\"4√ó4 Matrix{ComplexF64}\"\n\nSee also\n\n`bloch!`\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.siteindices-Tuple{Quantica.AbstractLattice}","page":"Reference","title":"Quantica.siteindices","text":"siteindices(lat::AbstractLattice; kw...)\nsiteindices(h::Hamiltonian; kw...)\nsiteindices(lat_or_h, s::SiteSelector)\n\nBuild a generator of the unique indices of sites in the lattice unitcell. Only sites specified by siteselector(kw...) are selected, see siteselector for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.sitepositions-Tuple{Quantica.AbstractLattice}","page":"Reference","title":"Quantica.sitepositions","text":"sitepositions(lat::AbstractLattice; kw...)\nsitepositions(h::Hamiltonian; kw...)\n\nBuild a generator of the positions of sites in the lattice unitcell. Only sites specified by siteselector(kw...) are selected, see siteselector for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.siteselector-Tuple{}","page":"Reference","title":"Quantica.siteselector","text":"siteselector(; region = missing, sublats = missing, indices = missing)\n\nReturn a SiteSelector object that can be used to select sites in a lattice contained within the specified region and sublattices. Only sites with index i, at position r and belonging to a sublattice with name s::NameType will be selected if\n\n`region(r) && s in sublats && i in indices`\n\nAny missing region, sublat or indices will not be used to constraint the selection.\n\nThe keyword sublats allows the following formats:\n\nsublats = :A                    # Sites on sublat :A only\nsublats = (:A,)                 # Same as above\nsublats = (:A, :B)              # Sites on sublat :A and :B\n\nThe keyword indices accepts a single integer, or a collection thereof. If several collections are given, they are flattened into a single one. Possible combinations:\n\nindices = 1                     # Site 1 only\nindices = (1, )                 # Same as above\nindices = (1, 2, 3)             # Sites 1, 2 or 3\nindices = [1, 2, 3]             # Same as above\nindices = 1:3                   # Same as above\nindices = (1:3, 7, 8)           # Sites 1, 2, 3, 7 or 8\n\nAdditionally, indices or sublattices can be wrapped in not to exclude them (see not):\n\nsublats = not(:A)               # Any sublat different from :A\nsublats = not(:A, :B)           # Any sublat different from :A and :B\nindices = not(8)                # Any site index different from 8\nindices = not(1, 3:4)           # Any site index different from 1, 3 or 4\nindices = (not(3:4), 4:6)       # Any site different from 3 and 4, *or* equal to 4, 5 or 6\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.spectrum-Tuple{Any}","page":"Reference","title":"Quantica.spectrum","text":"spectrum(h; method = LinearAlgebraPackage(), transform = missing)\n\nCompute the spectrum of a 0D Hamiltonian h (or alternatively of the bounded unit cell of a finite dimensional h) using one of the following methods\n\nmethod                    diagonalization function\n--------------------------------------------------------------\nLinearAlgebraPackage()     LinearAlgebra.eigen!\nArpackPackage()            Arpack.eigs (must be `using Arpack`)\n\nThe option transform = Œµ -> f(Œµ) allows to transform eigenvalues by f in the returned spectrum (useful for performing shifts or other postprocessing).\n\nIndexing\n\nThe eigenenergies Œµv::Vector and eigenstates œàm::Matrix in a s::Spectrum object can be accessed via destructuring, Œµv, œàm = sp, or Œµv, œàm = Tuple(sp), or Œµv = first(sp) = sp.energies, œàm = last(sp) = sp.states. Any degenerate energies appear repeated in Œµv. Alternatively, one can access one or more complete sub::Subspaces (eigenenergy together with its eigenstates, including all degenerates) via the indexing syntax,\n\ns[1]                   : first `Subspace`\ns[2:4]                 : subspaces 2, 3 and 4\ns[[2,5,6]]             : subspaces 2, 5 and 6\ns[around = 0.2]        : single subspace with energy closest to 0.2\ns[around = (0.2, 10)]  : the ten subspaces with energies closest to 0.2\n\nThe eigenenergy Œµ and subspace basis œàs of a sub::Subspace can be obtained via destructuring, Œµ, œàs = sub, or Œµ = first(sub) = sub.energy, œàs = last(sub) = sub.basis. For performance reasons œàs is a SubArray view of the appropriate columns of œàm, not an independent copy.\n\nSee also\n\n`bandstructure`, `diagonalizer`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.splitbands-Tuple{Quantica.Bandstructure}","page":"Reference","title":"Quantica.splitbands","text":"splitbands(bs::Bandstructure)\n\nSplits the bands in bs into disconnected subbands that share no vertices. See also splitbands option in bandstructure.\n\nSee also\n\n`bandstructure`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.sublat-Tuple{AbstractArray{#s39,1} where #s39<:(StaticArrays.SArray{Tuple{S},T,1,S} where T where S)}","page":"Reference","title":"Quantica.sublat","text":"sublat(sites...; name::Symbol)\nsublat(sites::Vector{<:SVector}; name::Symbol)\n\nCreate a Sublat{E,T,D} that adds a sublattice, of name name, with sites at positions sites in E dimensional space. Sites can be entered as tuples or SVectors.\n\nExamples\n\njulia> sublat((0.0, 0), (1, 1), (1, -1), name = :A)\nSublat{2,Float64} : sublattice of Float64-typed sites in 2D space\n  Sites    : 3\n  Name     : :A\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.subspace_dimension-Tuple{Any,Any}","page":"Reference","title":"Quantica.subspace_dimension","text":"\"     subspace_dimension(h, b) performs the numerical integration of the dos inside the interval (-a,a). dos is  computed using the KPM, see dosKPM with a number of momenta N enough to resolve the  interval (-a, a), i.e. N = bandwidth/a Arguments: b::DACPbuilder\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.supercell-Tuple","page":"Reference","title":"Quantica.supercell","text":"supercell(lat::AbstractLattice{E,L}, v::NTuple{L,Integer}...; seed = missing, kw...)\nsupercell(lat::AbstractLattice{E,L}, sc::SMatrix{L,L¬¥,Int}; seed = missing, kw...)\n\nGenerates a Superlattice from an L-dimensional lattice lat with Bravais vectors br¬¥= br * sc, where sc::SMatrix{L,L¬¥,Int} is the integer supercell matrix with the L¬¥ vectors vs as columns. If no v are given, the superlattice will be bounded.\n\nOnly sites selected by siteselector(; kw...) will be included in the supercell (see siteselector for details on the available keywords kw). The search for included sites will start from point seed::Union{Tuple,SVector}, or the origin if seed = missing. If no keyword region is given in kw, a Bravais unit cell perpendicular to the v axes will be selected for the L-L¬¥ non-periodic directions.\n\nsupercell(lattice::AbstractLattice{E,L}, factor::Integer; kw...)\n\nCalls supercell with a uniformly scaled sc = SMatrix{L,L}(factor * I)\n\nsupercell(lattice::AbstractLattice, factors::Integer...; kw...)\n\nCalls supercell with different scaling along each Bravais vector (diagonal supercell with factors along the diagonal)\n\nlat |> supercell(v...; kw...)\n\nCurried syntax, equivalent to `supercell(lat, v...; kw...)\n\nsupercell(h::Hamiltonian, v...; kw...)\n\nPromotes the Lattice of h to a Superlattice without changing the Hamiltonian itself, which always refers to the unitcell of the lattice.\n\nExamples\n\njulia> supercell(LatticePresets.honeycomb(), region = RegionPresets.circle(300))\nSuperlattice{2,2,Float64,0} : 2D lattice in 2D space, filling a 0D supercell\n  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (1, 1) --> 2 total per unit cell\n  Supercell{2,0} for 0D superlattice of the base 2D lattice\n    Supervectors  : ()\n    Supersites    : 652966\n\njulia> supercell(LatticePresets.triangular(), (1,1), (1, -1))\nSuperlattice{2,2,Float64,2} : 2D lattice in 2D space, filling a 2D supercell\n  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (1) --> 1 total per unit cell\n  Supercell{2,2} for 2D superlattice of the base 2D lattice\n    Supervectors  : ((1, 1), (1, -1))\n    Supersites    : 2\n\njulia> LatticePresets.square() |> supercell(3)\nSuperlattice{2,2,Float64,2} : 2D lattice in 2D space, filling a 2D supercell\n  Bravais vectors : ((1.0, 0.0), (0.0, 1.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (1) --> 1 total per unit cell\n  Supercell{2,2} for 2D superlattice of the base 2D lattice\n    Supervectors  : ((3, 0), (0, 3))\n    Supersites    : 9\n\nSee also\n\n`unitcell`, `siteselector`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.transform!-Tuple{Any,Quantica.Bandstructure}","page":"Reference","title":"Quantica.transform!","text":"transform!(f::Function, b::Bandstructure)\n\nTransform the energies of all bands in b by applying f to them in place.\n\ntransform!((fk, fŒµ), b::Bandstructure)\n\nTransform Bloch phases and energies of all bands in b by applying fk and fŒµ to them in place, respectively. If any of them is missing, it will be ignored.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.transform!-Tuple{Any,Quantica.Hamiltonian}","page":"Reference","title":"Quantica.transform!","text":"transform!(f::Function, h::Hamiltonian)\n\nTransform the site positions of the Hamiltonian's lattice in place without modifying the Hamiltonian harmonics.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.transform!-Tuple{Any,Quantica.Spectrum}","page":"Reference","title":"Quantica.transform!","text":"transform!(f::Function, s::Spectrum)\n\nTransform the energies of s by applying f to them in place.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.transform!-Tuple{Function}","page":"Reference","title":"Quantica.transform!","text":"x |> transform!(f::Function)\n\nCurried version of transform!, equivalent to transform!(f, x)\n\ntransform!(f::Function, lat::Lattice)\n\nTransform the site positions of lat by applying f to them in place.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.twoqr_diag-Tuple{Array{Complex{Float64},2},Array{Complex{Float64},2}}","page":"Reference","title":"Quantica.twoqr_diag","text":"codepath with QRfactorizations; P(A,B) œà = (A + Œª B) œà = 0\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.unflatten-Tuple{Quantica.OrbitalStructure}","page":"Reference","title":"Quantica.unflatten","text":"unflatten(x, o::OrbitalStructure)\n\nRebuild object x performing the inverse of flatten(x) or flatten(x, o). The target o is required.\n\nx |> unflatten(o::OrbitalStructure)\n\nCurried form equivalent to unflatten(x, o) (included for consistency with the rest of the API).\n\nExamples\n\njulia> h = LP.honeycomb() |> hamiltonian(hopping(I), orbitals = (:up,:down)) |> unitcell;\n\njulia> psi = spectrum(h)[around = -1]\nSubspace{0}: eigenenergy subspace on a 0D manifold\n  Energy       : -0.9999999999999989\n  Degeneracy   : 2\n  Bloch/params : Float64[]\n  Basis eltype : SVector{2, ComplexF64}\n\njulia> psiflat = flatten(psi)\nSubspace{0}: eigenenergy subspace on a 0D manifold\n  Energy       : -0.9999999999999989\n  Degeneracy   : 2\n  Bloch/params : Float64[]\n  Basis eltype : ComplexF64\n\njulia> unflatten(psiflat, orbitalstructure(psi))\nSubspace{0}: eigenenergy subspace on a 0D manifold\n  Energy       : -0.9999999999999989\n  Degeneracy   : 2\n  Bloch/params : Float64[]\n  Basis eltype : SVector{2, ComplexF64}\n\njulia> k = ket(ketmodel(1, sublats = :up), h) |> flatten\nKet{ComplexF64}: ket with a 4 √ó 1 amplitude matrix\n  OrbitalStructure:\n    Orbital Type  : ComplexF64\n    Orbitals      : ((:flat,), (:flat,))\n    Sublattices   : 2\n    Dimensions    : 4\n\njulia> unflatten(k, orbitalstructure(h))\nKet{SVector{2, ComplexF64}}: ket with a 2 √ó 1 amplitude matrix\n  OrbitalStructure:\n    Orbital Type  : SVector{2, ComplexF64}\n    Orbitals      : ((:up, :down), (:up, :down))\n    Sublattices   : 2\n    Dimensions    : 2\n\nSee also\n\n`flatten`, `orbitalstructure`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.unitcell-Tuple{Vararg{Union{Integer, Tuple, StaticArrays.SArray{Tuple{S},T,1,S} where T where S, StaticArrays.SArray{Tuple{S1,S2},T,2,L} where L where T where S2 where S1},N} where N}","page":"Reference","title":"Quantica.unitcell","text":"unitcell(lat::Lattice{E,L}, v::NTuple{L,Integer}...; seed = missing, kw...)\nunitcell(lat::Lattice{E,L}, uc::SMatrix{L,L¬¥,Int}; seed = missing, kw...)\n\nGenerates a Lattice from an L-dimensional lattice lat and a larger unit cell, such that its Bravais vectors are br¬¥= br * uc. Here uc::SMatrix{L,L¬¥,Int} is the integer unitcell matrix, with the L¬¥ vectors vs as columns. If no v are given, the new lattice will be bounded.\n\nOnly sites selected by siteselector(; kw...) will be included in the supercell (see siteselector for details on the available keywords kw). The search for included sites will start from point seed::Union{Tuple,SVector}, or the origin if seed = missing. If no keyword region is given in kw, a Bravais unit cell perpendicular to the v axes will be selected for the L-L¬¥ non-periodic directions.\n\nunitcell(lattice::Lattice{E,L}, factor::Integer; kw...)\n\nCalls unitcell with a uniformly scaled uc = SMatrix{L,L}(factor * I)\n\nunitcell(lattice::Lattice{E,L}, factors::Integer...; kw...)\n\nCalls unitcell with different scaling along each Bravais vector (diagonal supercell with factors along the diagonal)\n\nunitcell(slat::Superlattice)\n\nConvert Superlattice slat into a lattice with its unit cell matching slat's supercell.\n\nunitcell(h::Hamiltonian, v...; mincoordination, modifiers = (), kw...)\n\nTransforms the Lattice of h to have a larger unitcell, while expanding the Hamiltonian accordingly.\n\nA nonzero mincoordination indicates a minimum number of nonzero hopping neighbors required for sites to be included in the resulting unit cell. Sites with inferior coordination will be removed recursively, until all remaining satisfy mincoordination.\n\nThe modifiers (a tuple of ElementModifiers, either @onsite! or @hopping! with no free parameters) will be applied to onsite and hoppings as the hamiltonian is expanded. See @onsite! and @hopping! for details.\n\nNote: for performance reasons, in sparse hamiltonians only the stored onsites and hoppings will be transformed by ElementModifiers, so you might want to add zero onsites or hoppings when building h to have a modifier applied to them later.\n\nlat_or_h |> unitcell(v...; kw...)\n\nCurried syntax, equivalent to unitcell(lat_or_h, v...; kw...)\n\nExamples\n\njulia> unitcell(LatticePresets.honeycomb(), region = RegionPresets.circle(300))\nLattice{2,0,Float64} : 0D lattice in 2D space\n  Bravais vectors : ()\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (326483, 326483) --> 652966 total per unit cell\n\njulia> unitcell(LatticePresets.triangular(), (1,1), (1, -1))\nLattice{2,2,Float64} : 2D lattice in 2D space\n  Bravais vectors : ((0.0, 1.732051), (1.0, 0.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (2) --> 2 total per unit cell\n\njulia> LatticePresets.square() |> unitcell(3)\nLattice{2,2,Float64} : 2D lattice in 2D space\n  Bravais vectors : ((3.0, 0.0), (0.0, 3.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (9) --> 9 total per unit cell\n\njulia> supercell(LatticePresets.square(), 3) |> unitcell\nLattice{2,2,Float64} : 2D lattice in 2D space\n  Bravais vectors : ((3.0, 0.0), (0.0, 3.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (9) --> 9 total per unit cell\n\nSee also\n\n`supercell`, `siteselector`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.vertices-Tuple{Quantica.Bandstructure,Any}","page":"Reference","title":"Quantica.vertices","text":"vertices(bs::Bandstructure, i)\n\nReturn the vertices (k..., œµ) of the i-th band in bs, in the form of a Vector{SVector{L+1}}, where L is the lattice dimension.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.wrap-Tuple{Quantica.Hamiltonian,Int64}","page":"Reference","title":"Quantica.wrap","text":"wrap(h::Hamiltonian, axes; phases = missing)\n\nBuild a new Hamiltonian from h reducing its dimensions from L to L - length(axes) by wrapping the specified Bravais axes into a loop. axes can be an integer ‚àà 1:L or a tuple of such integers. If phases are given (with length(axes) == length(phases)), the wrapped hoppings at a cell distance dn along axes will be multiplied by a factor cis(-dot(phases, dn)). This is useful, for example, to represent a flux Œ¶ through a loop, using a single axes = 1 and phases = 2œÄ * Œ¶/Œ¶‚ÇÄ.\n\nwrap(h::Hamiltonian; kw...)\n\nWrap all axes of h, yielding a compactified zero-dimensional Hamiltonian.\n\nh |> wrap(axes; kw...)\n\nCurried form equivalent to wrap(h, axes; kw...).\n\nExamples\n\njulia> LatticePresets.honeycomb() |> hamiltonian(hopping(1, range = 1/‚àö3)) |>\n       unitcell((1,-1), (10, 10)) |> wrap(2)\nHamiltonian{<:Lattice} : Hamiltonian on a 1D Lattice in 2D space\n  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)\n  Harmonic size    : 40 √ó 40\n  Orbitals         : ((:a,), (:a,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 120\n  Coordination     : 3.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.@block!-Tuple{Any,Any,Any,Vararg{Any,N} where N}","page":"Reference","title":"Quantica.@block!","text":"@block!((block; params...) -> modified_block, sites; dn = missing)\n@block!((block; params...) -> modified_block, (rows, cols); dn = missing)\n\nCreate an BlockModifier <: AbstractModifier, to be used with parametric, that applies f = (block; ...) -> ... to a block h[dn][sites, sites] or h[dn][rows, cols] of hamiltonian h. Keyword arguments params are optional, and include any parameters that modified_block depends on that the user may want to tune. If the keyword dn = missing, the dn in h[dn] will be restricted to dn = (0...). Otherwise the specified dn's will be modified (e.g. when dn = (1,0) or dn = ((1,0), (-1,0))).\n\nUpon construction of a ParametricHamiltonian with a @block! modifier, a check is performed that the whole block specified by (rows, cols) is stored in the sparse Hamiltonian harmonics. If it is not, any non-zero element in modified_block will fail to be applied to the harmonic in question, so a warning is issued. The warning can be ignored if the user knows that all non-zero elements in modified_block are indeed stored in the harmonic, either as finite matrix elements or structural zeros.\n\nSpecial care should be taken when using @block! on Hamiltonians with different number of orbitals in different sublattices. To avoid type-instabities in this case, the internal representation of Hamiltonian harmonics uses a uniform eltype that is an SMatrix{N,N} with N the maximum number of orbitals among the different sublattices (padded with zeros in sublattices with less than N orbitals). The matrix modified_block should have this same uniform eltype.\n\nSee also\n\n`@onsite!`, `@hopping!`, `parametric`\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Quantica.@hopping!-Tuple{Any,Any}","page":"Reference","title":"Quantica.@hopping!","text":"@hopping!(args -> body; kw...)\n\nCreate an ElementModifier <: AbstractModifier, to be used with parametric, that applies f = args -> body to hoppings energies specified by kw (see hopping for details on possible kws). The form of args -> body may be (t; params...) -> ... or (t, r, dr; params...) -> ... if the modification is position (r, dr) dependent. Keyword arguments params are optional, and include any parameters that body depends on that the user may want to tune.\n\nNote: unlike onsite and hopping, ElementModifiers cannot be combined (i.e. you cannot do @onsite!(...) + @hopping!(...)). ElementModifiers are not model terms but transformations of an existing Hamiltonian that are meant to be applied sequentially (the order of application usually matters).\n\nSee also\n\n`@onsite!`, `@block!`, `parametric`\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Quantica.@onsite!-Tuple{Any,Any}","page":"Reference","title":"Quantica.@onsite!","text":"@onsite!(args -> body; kw...)\n\nCreate an ElementModifier <: AbstractModifier, to be used with parametric, that applies f = args -> body to onsite energies specified by kw (see onsite for details on possible kws). The form of args -> body may be (o; params...) -> ... or (o, r; params...) -> ... if the modification is position (r) dependent. Keyword arguments params are optional, and include any parameters that body depends on that the user may want to tune.\n\nNote: unlike onsite and hopping, ElementModifiers cannot be combined (i.e. you cannot do @onsite!(...) + @hopping!(...)). ElementModifiers are not model terms but transformations of an existing Hamiltonian that are meant to be applied sequentially (the order of application usually matters).\n\nSee also\n\n`@hopping!`, `@block!`, `parametric`\n\n\n\n\n\n","category":"macro"},{"location":"#Quantica.jl","page":"Home","title":"Quantica.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Quantica.jl is a Julia package for building generic tight-binding models and computing various spectral and transport properties.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Important information\nThis package supersedes Elsa.jl, which will soon be deprecated.","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"tutorial.md\",\n    \"examples.md\",\n    \"reference.md\",\n]\nDepth = 1","category":"page"},{"location":"#Current-functionality","page":"Home","title":"Current functionality","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Build arbitrary lattices (periodic or bounded in any dimension and with any unit cell)\nDefine generic model Hamiltonians by applying a model onto a lattice\nUse models with arbitrary orbital structure, spatial dependence and coordination (e.g. normal/superconducting, spin-orbit coupling, etc.)\nDefine parametric Hamiltonians that efficiently implement external parameters dependencies\nEfficiently compute the Bloch Hamiltonian matrix at arbitrary wave vector\nCompute the band structure or spectrum of a Hamiltonian, using advanced meshing and co-diagonalization techniques to resolve degeneracies and extract subbands\nUse Order-N Kernel polynomial methods to compute spectral and transport properties efficiently","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Funding\nThis work has been partly funded by the Spanish Ministry of Economy and Competitiveness under Grant Nos. FIS2015-65706-P, PCI2018-093026, and the CSIC Intramural Project 201760I086.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"}]
}
