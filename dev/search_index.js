var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = Quantica","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Quantica]","category":"page"},{"location":"api/#Quantica.EigenSolvers","page":"API","title":"Quantica.EigenSolvers","text":"EigenSolvers is a Quantica submodule containing several pre-defined eigensolvers. The alias ES can be used in place of EigenSolvers. Currently supported solvers are\n\nES.LinearAlgebra(; kw...)       # Uses `eigen(mat; kw...)` from the `LinearAlgebra` package\nES.Arpack(; kw...)              # Uses `eigs(mat; kw...)` from the `Arpack` package\nES.KrylovKit(params...; kw...)  # Uses `eigsolve(mat, params...; kw...)` from the `KrylovKit` package\nES.ArnoldiMethod(; kw...)       # Uses `partialschur(mat; kw...)` from the `ArnoldiMethod` package\n\nAdditionally, to compute interior eigenvalues, we can use a shift-invert method around energy ϵ0 (uses LinearMaps and a LinearSolve.lu factorization), combined with any solver s from the list above:\n\nES.ShiftInvert(s, ϵ0)           # Perform a lu-based shift-invert with solver `s`\n\nIf the required packages are not already available, they will be automatically loaded when calling these solvers.\n\nExamples\n\njulia> h = HP.graphene(t0 = 1) |> supercell(10);\n\njulia> spectrum(h, (0,0), ES.ShiftInvert(ES.ArnoldiMethod(nev = 4), 0.0)) |> energies\n4-element Vector{ComplexF64}:\n -0.38196601125010465 + 3.686368662666227e-16im\n  -0.6180339887498938 + 6.015655020129746e-17im\n   0.6180339887498927 + 2.6478518218421853e-16im\n  0.38196601125010476 - 1.741261108320361e-16im\n\nSee also\n\n`spectrum`, `bands`\n\n\n\n\n\n","category":"module"},{"location":"api/#Quantica.GreenSolvers","page":"API","title":"Quantica.GreenSolvers","text":"GreenSolvers is a Quantica submodule containing several pre-defined Green function solvers. The alias GS can be used in place of GS. Currently supported solvers and their possible keyword arguments are\n\nGS.SparseLU() : Direct inversion solver for 0D Hamiltonians using a SparseArrays.lu(hmat) factorization\nGS.Schur(; boundary = Inf) : Solver for 1D Hamiltonians based on a deflated, generalized Schur factorization\nboundary : 1D cell index of a boundary cell, or Inf for no boundaries. Equivalent to removing that specific cell from the lattice when computing the Green function.\nGS.KPM(; order = 100, bandrange = missing, kernel = I) : Kernel polynomial method solver for 0D Hamiltonians\norder : order of the expansion in Chebyshev polynomials Tₙ(h) of the Hamiltonian h (lowest possible order is n = 0).\nbandrange : a (min_energy, max_energy)::Tuple interval that encompasses the full band of the Hamiltonian. If missing, it is computed automatically.\nkernel : generalization that computes momenta as μₙ = Tr[Tₙ(h)*kernel], so that the local density of states (see ldos) becomes the density of the kernel operator.\nThis solver does not allow arbitrary indexing of the resulting g::GreenFunction, only on contacts g[contact_ind::Integer]. If the system has none, we can add a dummy contact using attach(h, nothing; sites...), see attach.\n\nTODO\n\nStill in the TODO list is a bandstructure/spectrum-based solver, valid for Hamiltonians of any dimension with and without boundaries\n\n\n\n\n\n","category":"module"},{"location":"api/#Quantica.HamiltonianPresets","page":"API","title":"Quantica.HamiltonianPresets","text":"HamiltonianPresets is a Quantica submodule containing several pre-defined Hamiltonians. The alias HP can be used in place of LatticePresets. Currently supported hamiltonians are\n\nHP.graphene(; kw...)\nHP.twisted_bilayer_graphene(; kw...)\n\nFor details on the keyword arguments kw see the corresponding docstring\n\njulia> HamiltonianPresets.twisted_bilayer_graphene(twistindices = (30, 1))\nHamiltonian{Float64,3,2}: Hamiltonian on a 2D Lattice in 3D space\n  Bloch harmonics  : 7\n  Harmonic size    : 11164 × 11164\n  Orbitals         : [1, 1, 1, 1]\n  Element type     : scalar (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 315684\n  Coordination     : 28.27696\n\nSee also\n\n`LatticePresets`, `RegionPresets`\n\n\n\n\n\n","category":"module"},{"location":"api/#Quantica.LatticePresets","page":"API","title":"Quantica.LatticePresets","text":"LatticePresets is a Quantica submodule containing several pre-defined lattices. The alias LP can be used in place of LatticePresets. Currently supported lattices are\n\nLP.linear(; a0 = 1, kw...)      # linear lattice in 1D\nLP.square(; a0 = 1, kw...)      # square lattice in 2D\nLP.triangular(; a0 = 1, kw...)  # triangular lattice in 2D\nLP.honeycomb(; a0 = 1, kw...)   # honeycomb lattice in 2D\nLP.cubic(; a0 = 1, kw...)       # cubic lattice in 3D\nLP.fcc(; a0 = 1, kw...)         # face-centered-cubic lattice in 3D\nLP.bcc(; a0 = 1, kw...)         # body-centered-cubic lattice in 3D\nLP.hcp(; a0 = 1, kw...)         # hexagonal-closed-packed lattice in 3D\n\nIn all cases a0 denotes the lattice constant, and kw... are extra keywords forwarded to lattice.\n\nExamples\n\njulia> LatticePresets.honeycomb(names = (:C, :D))\nLattice{Float64,2,2} : 2D lattice in 2D space\n  Bravais vectors : [[0.5, 0.866025], [-0.5, 0.866025]]\n  Sublattices     : 2\n    Names         : (:C, :D)\n    Sites         : (1, 1) --> 2 total per unit cell\n\njulia> LatticePresets.cubic(bravais = ((1, 0), (0, 2)))\nLattice{Float64,3,2} : 2D lattice in 3D space\n  Bravais vectors : [[1.0, 0.0, 0.0], [0.0, 2.0, 0.0]]\n  Sublattices     : 1\n    Names         : (:A,)\n    Sites         : (1,) --> 1 total per unit cell\n\nSee also\n\n`RegionPresets`, `HamiltonianPresets`\n\n\n\n\n\n","category":"module"},{"location":"api/#Quantica.RegionPresets","page":"API","title":"Quantica.RegionPresets","text":"RegionPresets is a Quantica submodule containing several pre-defined regions of type Region{E}, where E is the space dimension. The alias RP can be used in place of RegionPresets. Supported regions are\n\nRP.circle(radius = 10, center = (0, 0))                         # 2D\nRP.ellipse((rx, ry) = (10, 15), center = (0, 0))                # 2D\nRP.square(side = 10, center = (0, 0))                           # 2D\nRP.rectangle((sx, sy) = (10, 15), center = (0, 0))              # 2D\nRP.sphere(radius = 10, center = (0, 0, 0))                      # 3D\nRP.spheroid((rx, ry, rz) = (10, 15, 20), center = (0, 0, 0))    # 3D\nRP.cube(side = 10, center = (0, 0, 0))                          # 3D\nRP.cuboid((sx, sy, sz) = (10, 15, 20), center = (0, 0, 0))      # 3D\n\nCalling a f::Region{E} object on a r::Tuple or r::SVector with f(r) or f(r...) returns true or false if r is inside the region or not. Note that only the first E coordinates of r will be checked. Arbitrary boolean functions can also be wrapped in Region{E} to create custom regions, e.g. f = Region{2}(r -> r[1]^2 < r[2]).\n\nBoolean combinations of Regions are supported using &, |, xor and ! operators, such as annulus = RP.circle(10) & !RP.circle(5).\n\nExamples\n\njulia> RegionPresets.circle(10)(20, 0, 0)\nfalse\n\njulia> RegionPresets.circle(10)(0, 0, 20)\ntrue\n\nSee also\n\n`LatticePresets`, `HamiltonianPresets`\n\n\n\n\n\n","category":"module"},{"location":"api/#Quantica.BoxIterator","page":"API","title":"Quantica.BoxIterator","text":"BoxIterator(seed::SVector{N,Int}; maxiterations = TOOMANYITERS)\n\nCartesian iterator iter over SVector{N,Int}s (cells) that starts at seed and grows outwards in the form of a box of increasing sides (not necesarily equal) until it encompasses a certain N-dimensional region. To signal that a cell is in the desired region the user calls acceptcell!(iter, cell).\n\n\n\n\n\n","category":"type"},{"location":"api/#LinearAlgebra.ishermitian","page":"API","title":"LinearAlgebra.ishermitian","text":"ishermitian(h::Hamiltonian)\n\nCheck whether h is Hermitian. This is not supported for h::ParametricHamiltonian, as the result can depend of the specific values of its parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.attach","page":"API","title":"Quantica.attach","text":"attach(h::AbstractHamiltonian, args..; sites...)\nattach(h::OpenHamiltonian, args...; sites...)\n\nBuild an h´::OpenHamiltonian by attaching (adding) a Σ::SelfEnergy to a finite number of sites in h specified by siteselector(; sites...). This also defines a \"contact\" on said sites that can be referred to (with index i::Integer for the i-th attached contact) when slicing Green functions later. Self-energies are taken into account when building the Green function g(ω) = (ω - h´ - Σ(ω))⁻¹ of the resulting h´, see greenfunction.\n\nSelf-energy forms\n\nThe different forms of args yield different types of self-energies Σ. Currently supported forms are:\n\nattach(h, gs::GreenSlice, coupling::AbstractModel; sites...)\n\nAdds a generic self-energy Σ(ω) = V´⋅gs(ω)⋅V on h's sites, where V and V´ are couplings, given by coupling, between said sites and the LatticeSlice in gs. Allowed forms of gs include both g[bath_sites...] and g[contactind::Integer]m where g is any GreenFunction.\n\nattach(h, model::ParametricModel; sites...)\n\nAdd self-energy Σᵢⱼ(ω) defined by a model composed of parametric terms (@onsite and @hopping) with ω as first argument, as in e.g. @onsite((ω, r) -> Σᵢᵢ(ω, r)) and @hopping((ω, r, dr) -> Σᵢⱼ(ω, r, dr))\n\nattach(h, nothing; sites...)\n\nAdd null self-energy Σᵢⱼ(ω) = 0 on selected sites, which in effect simply amounts to defining a contact on said sites, but does not lead to any dressing the Green function. This is useful for some GreenFunction solvers such as GS.KPM (see greenfunction), which need to know the sites of interest beforehand (the contact sites in this case).\n\nattach(h, g1D::GreenFunction; reverse = false, transform = identity, sites...)\n\nAdd a self-energy Σ(ω) = h₋₁⋅g1D(ω)[surface]⋅h₁ corresponding to a semi-infinite 1D lead (i.e. with a finite boundary, see greenfunction), where h₁ and h₋₁ are intercell couplings, and g1D is the lead GreenFunction. The g1D(ω) is taken at the suface unitcell, either adjacent to the boundary on its positive side (if reverse = false) or on its negative side (if reverse = true). The selected sites in h must match, geometrically, those of the lead unit cell after applying transform to the latter. If they don't, use the attach syntax below.\n\nAdvanced: If the g1D does not have any self-energies, the produced self-energy is in fact an ExtendedSelfEnergy, which is numerically more stable than a naive implementation of RegularSelfEnergy's, since g1D(ω)[surface] is never actually computed. Conversely, if g1D has self-energies attached, a RegularSelfEnergy is produced.\n\nattach(h, g1D::GreenFunction, coupling::AbstractModel; reverse = false, transform = identity,  sites...)\n\nAdd a self-energy Σ(ω) = V´⋅g1D(ω)[surface]⋅V corresponding to a 1D lead (semi-infinite or infinite), but with couplings V and V´, defined by coupling, between sites and the surface lead unitcell (or the one with index zero if there is no boundary) . See also Advanced note above.\n\nCurrying\n\nh |> attach(args...; sites...)\n\nCurried form equivalent to attach(h, args...; sites...).\n\nExamples\n\njulia> # A graphene flake with two out-of-plane cubic-lattice leads\n\njulia> g1D = LP.cubic() |> hamiltonian(hopping(1)) |> supercell((0,0,1), region = RP.square(4)) |> greenfunction(GS.Schur(boundary = 0));\n\njulia> coupling = hopping(1, range = 2);\n\njulia> gdisk = HP.graphene(a0 = 1, dim = 3) |> supercell(region = RP.circle(10)) |> attach(g1D, coupling; region = RP.square(4)) |> attach(g1D, coupling; region = RP.square(4), reverse = true) |> greenfunction;\n\n\nSee also\n\n`greenfunction`, `GreenSolvers`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.bands","page":"API","title":"Quantica.bands","text":"bands(h::AbstractHamiltonian, xcolᵢ...; kw...)\n\nConstruct a Bandstructure object, which contains in particular a collection of continuously connected Subbands of h, obtained by diagonalizing the matrix h(ϕs; params...) on an M-dimensional mesh of points (x₁, x₂, ..., xₘ), where each xᵢ takes values in the collection xcolᵢ. The mapping between points in the mesh points and values of (ϕs; params...) is defined by keyword mapping (identity by default, see Keywords). Diagonalization is multithreaded and will use all available Julia threads (start session with julia -t N to have N threads).\n\nbands(f::Function, xcolᵢ...; kw...)\n\nLike the above using f(ϕs)::AbstractMatrix in place of h(ϕs; params...), and returning a Vector{<:Subband} instead of a Bandstructure object. This is provided as a lower level driver without the added slicing functionality of a full Bandstructure object, see below.\n\nKeywords\n\nsolver: eigensolver to use for each diagonalization (see Eigensolvers). Default: ES.LinearAlgebra()\nmapping: a function of the form (x, y, ...) -> ϕs or (x, y, ...) -> ftuple(ϕs...; params...) that translates points (x, y, ...) in the mesh to Bloch phases ϕs or phase+parameter FrankenTuples ftuple(ϕs...; params...). See also linecuts below. Default: identity\ntransform: function to apply to each eigenvalue after diagonalization. Default: identity\ndegtol::Real: maximum distance between to nearby eigenvalue so that they are classified as degenerate. Default: sqrt(eps)\nsplit::Bool: whether to split bands into disconnected subbands. Default: true\nwarn::Bool: whether to emit warning when band dislocations are encountered\nshowprogress::Bool: whether to show or not a progress bar. Default: true\ndefects: (experimental) a collection of extra points to add to the mesh, typically the location of topological band defects such as Dirac points, so that interpolation avoids creating dislocation defects in the bands. You need to also increase patches to repair the subband dislocations using the added defect vertices.\npatches::Integer: (experimental) if a dislocation is encountered, attempt to patch it by searching for the defect recursively to a given order, or using the provided defects (preferred). Default: 0\n\nBand linecuts\n\nTo do a linecut of a bandstructure along a polygonal path in the L-dimensional Brillouin zone, mapping a set of 1D points xs to a set of nodes, with pts interpolation points in each segment, one can use the following convenient syntax\n\nbands(h, subdiv(xs, pts); mapping = (xs => nodes))\n\nHere nodes can be a collection of SVector{L} or of named Brillouin zone points from the list (:Γ,:K, :K´, :M, :X, :Y, :Z). If mapping = nodes, then xs defaults to 0:length(nodes)-1. See also subdiv for its alternative methods.\n\nIndexing\n\nb[i]\n\nExtract i-th subband from b::Bandstructure. i can also be a Vector, an AbstractRange or any other argument accepted by getindex(subbands::Vector, i)\n\nb[slice::Tuple]\n\nCompute a section of b::Bandstructure with a \"plane\" defined by slice = (ϕ₁, ϕ₂,..., ϕₗ[, ϵ]), where each ϕᵢ or ϵ can be a real number (representing a fixed momentum or energy) or a : (unconstrained along that dimension). For bands of an L-dimensional lattice, slice will be padded to an L+1-long tuple with : if necessary. The result is a collection of of sliced Subbands.\n\nExamples\n\njulia> phis = range(0, 2pi, length = 50); h = LP.honeycomb() |> hamiltonian(@hopping((; t = 1) -> t));\n\njulia> bands(h(t = 1), phis, phis)\nBandstructure{Float64,3,2}: 3D Bandstructure over a 2-dimensional parameter space of type Float64\n  Subbands  : 1\n  Vertices  : 5000\n  Edges     : 14602\n  Simplices : 9588\n\njulia> bands(h, phis, phis; mapping = (x, y) -> ftuple(0, x; t = y/2π))\nBandstructure{Float64,3,2}: 3D Bandstructure over a 2-dimensional parameter space of type Float64\n  Subbands  : 1\n  Vertices  : 4950\n  Edges     : 14553\n  Simplices : 9604\n\njulia> bands(h(t = 1), subdiv((0, 2, 3), (20, 30)); mapping = (0, 2, 3) => (:Γ, :M, :K))\nBandstructure{Float64,2,1}: 2D Bandstructure over a 1-dimensional parameter space of type Float64\n  Subbands  : 1\n  Vertices  : 97\n  Edges     : 96\n  Simplices : 96\n\nSee also\n\n`spectrum`, `subdiv`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.bravais_matrix","page":"API","title":"Quantica.bravais_matrix","text":"bravais_matrix(lat::Lattice)\nbravais_matrix(h::AbstractHamiltonian)\n\nReturn the Bravais matrix of lattice lat or AbstractHamiltonian h, with Bravais vectors as its columns.\n\nExamples\n\njulia> lat = lattice(sublat((0,0)), bravais = ((1.0, 2), (3, 4)));\n\njulia> bravais_matrix(lat)\n2×2 SMatrix{2, 2, Float64, 4} with indices SOneTo(2)×SOneTo(2):\n 1.0  3.0\n 2.0  4.0\n\n\nSee also\n\n`lattice`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.combine","page":"API","title":"Quantica.combine","text":"combine(lats::Lattice...)\n\nIf all lats have compatible Bravais vectors, combine them into a single lattice. If necessary, sublattice names are renamed to remain unique.\n\ncombine(hams::AbstractHamiltonians...; coupling = TighbindingModel())\n\nCombine a collection hams of hamiltonians into one by combining their corresponding lattices, and optionally by adding a coupling between them, given by the hopping terms in coupling.\n\nNote that the `coupling` model will be applied to the combined lattice (which may have renamed sublattices to avoid name collissions). However, only hopping terms between different `hams` blocks will be applied.\n\nExamples\n\njulia> # Building Bernal-stacked bilayer graphene\n\njulia> hbot = HP.graphene(a0 = 1, dim = 3); htop = translate(hbot, (0, 1/√3, 1/√3));\n\njulia> h2 = combine(hbot, htop; coupling = hopping(1, sublats = :B => :C) |> plusadjoint))\n┌ Warning: Renamed repeated sublattice :A to :C\n└ @ Quantica ~/.julia/dev/Quantica/src/types.jl:60\n┌ Warning: Renamed repeated sublattice :B to :D\n└ @ Quantica ~/.julia/dev/Quantica/src/types.jl:60\nHamiltonian{Float64,3,2}: Hamiltonian on a 2D Lattice in 3D space\n  Bloch harmonics  : 5\n  Harmonic size    : 4 × 4\n  Orbitals         : [1, 1, 1, 1]\n  Element type     : scalar (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 14\n  Coordination     : 3.5\n\nSee also\n\n`hopping`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.conductance","page":"API","title":"Quantica.conductance","text":"conductance(gs::GreenSlice; nambu = false)\n\nGiven a slice gs = g[i::Integer, j::Integer] of a g::GreenFunction, build a partially evaluated object G::Conductance representing the zero-temperature, linear, differential conductance Gᵢⱼ = dIᵢ/dVⱼ between contacts i and j at arbitrary bias ω = eV in units of e^2/h. Gᵢⱼ is given by\n\n  Gᵢⱼ =  e^2/h × Tr{[im*δᵢⱼ(gʳ-gᵃ)Γⁱ-gʳΓⁱgᵃΓʲ]}         (nambu = false)\n  Gᵢⱼ =  e^2/h × Tr{[im*δᵢⱼ(gʳ-gᵃ)Γⁱτₑ-gʳΓⁱτ₃gᵃΓʲτₑ]}   (nambu = true)\n\nHere gʳ = g(ω) and gᵃ = (gʳ)' = g(ω') are the retarded and advanced Green function of the system, and Γⁱ = im * (Σⁱ - Σⁱ') is the decay rate at contact i. For Nambu systems (nambu = true), the matrices τₑ=[I 0; 0 0] and τ₃ = [I 0; 0 -I] ensure that charge reversal in Andreev reflections is properly taken into account. For normal systems (nambu = false), the total current at finite bias and temperatures is given by Iᵢ = eh   dω ⱼ fᵢ(ω) - fⱼ(ω) Gᵢⱼ(ω), where fᵢ(ω) is the Fermi distribution in lead i.\n\nKeywords\n\nnambu : whether to consider the Hamiltonian of the system is written in a Nambu basis, each site containing N electron orbitals followed by N hole orbitals.\n\nFull evaluation\n\nG(ω; params...)\n\nCompute the conductance at the specified contacts.\n\njulia> # A central system g0 with two 1D leads and transparent contacts\n\njulia> glead = LP.square() |> hamiltonian(hopping(1)) |> supercell((1,0), region = r->-2<r[2]<2) |> greenfunction(GS.Schur(boundary = 0));\n\njulia> g0 = LP.square() |> hamiltonian(hopping(1)) |> supercell(region = r->-2<r[2]<2 && r[1]≈0) |> attach(glead, reverse = true) |> attach(glead) |> greenfunction;\n\njulia> G = conductance(g0[1])\nConductance{Float64}: Zero-temperature conductance dIᵢ/dVⱼ from contacts i,j, in units of e^2/h\n  Current contact  : 1\n  Bias contact     : 1\n\njulia> G(0.2)\n2.999999999999999\n\nSee also\n\n`greenfunction`, `ldos`, `current`, `josephson`, `transmission`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.current","page":"API","title":"Quantica.current","text":"current(gs::GreenSlice; charge = -I, direction = missing)\n\nBuild Js::CurrentDensitySlice, a partially evaluated object representing the equilibrium local current density Jᵢⱼ(ω) at arbitrary energy ω from site j to site i, both taken from a specific lattice slice. The current is computed along a given direction (see Keywords).\n\ncurrent(gω::GreenSolution; charge = -I, direction = missing)\n\nBuild Jω::CurrentDensitySolution, as above, but for Jᵢⱼ(ω) at a fixed ω and arbitrary sites i, j. See also greenfunction for details on building a GreenSlice and GreenSolution.\n\nThe local current density is defined here as Jᵢⱼ(ω) = (2h) rᵢⱼ Re Tr(Hᵢⱼgⱼᵢ(ω) - gᵢⱼ(ω)Hⱼᵢ) * charge, with the integrated local current given by Jᵢⱼ =  f(ω) Jᵢⱼ(ω) dω. Here Hᵢⱼ is the hopping from site j at rⱼ to i at rᵢ, rᵢⱼ = rᵢ - rⱼ, charge is the charge of carriers in orbital space (see Keywords), and gᵢⱼ(ω) is the retarded Green function between said sites.\n\nKeywords\n\ncharge : for multiorbital sites, charge can be a general matrix, which allows to compute arbitrary currents, such as spin currents.\ndirection: as defined above, Jᵢⱼ(ω) is a vector. If direction is missing the norm |Jᵢⱼ(ω)| is returned. If it is an u::Union{SVector,Tuple}, u⋅Jᵢⱼ(ω) is returned. If an n::Integer, Jᵢⱼ(ω)[n] is returned.\n\nFull evaluation\n\nJω[sites...]\nJs(ω; params...)\n\nGiven a partially evaluated Jω::CurrentDensitySolution or ρs::CurrentDensitySlice, build a sparse matrix Jᵢⱼ(ω) along the specified direction of fully evaluated local current densities.\n\nExample\n\njulia> # A semi-infinite 1D lead with a magnetic field `B`\n\njulia> g = LP.square() |> hamiltonian(@hopping((r, dr; B = 0.1) -> cis(B * dr' * SA[r[2],-r[1]]))) |> supercell((1,0), region = r->-2<r[2]<2) |> greenfunction(GS.Schur(boundary = 0));\n\njulia> J = current(g[cells = SA[1]])\nCurrentDensitySlice{Float64} : current density at a fixed location and arbitrary energy\n  charge      : LinearAlgebra.UniformScaling{Int64}(-1)\n  direction   : missing\n\njulia> J(0.2; B = 0.1)\n3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n  ⋅         0.0290138   ⋅\n 0.0290138   ⋅         0.0290138\n  ⋅         0.0290138   ⋅\n\njulia> J(0.2; B = 0.0)\n3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n  ⋅           7.77156e-16   ⋅\n 7.77156e-16   ⋅           5.55112e-16\n  ⋅           5.55112e-16   ⋅\n\n\nSee also\n\n`greenfunction`, `ldos`, `conductance`, `josephson`, `transmission`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.energies","page":"API","title":"Quantica.energies","text":"energies(sp::Spectrum)\n\nReturns the energies in sp as a vector of Numbers (not necessarily real). Equivalent to first(sp).\n\nSee also\n\n`spectrum`, `bands`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.greenfunction","page":"API","title":"Quantica.greenfunction","text":"greenfunction(h::Union{AbstractHamiltonian,OpenHamiltonian}, solver::GreenSolver)\n\nBuild a g::GreenFunction of Hamiltonian h using solver. See GreenSolvers for available solvers. If solver is not provided, a default solver is chosen automatically based on the type of h.\n\nCurrying\n\nh |> greenfunction(solver)\n\nCurried form equivalent to greenfunction(h, solver).\n\nPartial evaluation\n\nGreenFunctions allow independent, partial evaluation of their positions (producing a GreenSlice) and energy/parameters (producing a GreenSolution). Depending on the solver, this may avoid repeating calculations unnecesarily when sweeping over either of these with the other fixed.\n\ng[ss]\ng[siteselector(; ss...)]\n\nBuild a gs::GreenSlice that represents a Green function at arbitrary energy and parameter values, but at specific sites on the lattice defined by siteselector(; ss...), with ss::NamedTuple (see siteselector).\n\ng[contact_index::Integer]\n\nBuild a GreenSlice equivalent to g[contact_sites...], where contact_sites... correspond to sites in contact number contact_index (must have 1<= contact_index <= number_of_contacts). See attach for details on attaching contacts to a Hamiltonian.\n\ng[:]\n\nBuild a GreenSlice over all contacts.\n\ng[dst, src]\n\nBuild a gs::GreenSlice between sites specified by src and dst, which can take any of the forms above. Therefore, all the previous slice forms correspond to a diagonal block g[i, i].\n\ng(ω; params...)\n\nBuild a gω::GreenSolution that represents a retarded Green function at arbitrary points on the lattice, but at fixed energy ω and system parameter values param. If ω is complex, the retarded or advanced Green function is returned, depending on sign(imag(ω)). If ω is Real, a small, positive imaginary part is automatically added internally to produce the retarded g.\n\ngω[i]\ngω[i, j]\ngs(ω; params...)\n\nFor any gω::GreenSolution or gs::GreenSlice, build the Green function matrix fully evaluated at fixed energy, parameters and positions. The matrix is dense and has scalar elements, so that any orbital structure on each site is flattened.\n\nExample\n\njulia> g = LP.honeycomb() |> hamiltonian(@hopping((; t = 1) -> t)) |> supercell(region = RP.circle(10)) |> greenfunction(GS.SparseLU())\nGreenFunction{Float64,2,0}: Green function of a Hamiltonian{Float64,2,0}\n  Solver          : AppliedSparseLUGreenSolver\n  Contacts        : 0\n  Contact solvers : ()\n  Contact sizes   : ()\n  ParametricHamiltonian{Float64,2,0}: Parametric Hamiltonian on a 0D Lattice in 2D space\n    Bloch harmonics  : 1\n    Harmonic size    : 726 × 726\n    Orbitals         : [1, 1]\n    Element type     : scalar (ComplexF64)\n    Onsites          : 0\n    Hoppings         : 2098\n    Coordination     : 2.88981\n    Parameters       : [:t]\n\njulia> gω = g(0.1; t = 2)\nGreenSolution{Float64,2,0}: Green function at arbitrary positions, but at a fixed energy\n\njulia> ss = (; region = RP.circle(2), sublats = :B);\n\njulia> gs = g[ss]\nGreenSlice{Float64,2,0}: Green function at arbitrary energy, but at a fixed lattice positions\n\njulia> gω[ss] == gs(0.1; t = 2)\ntrue\n\nSee also\n\n`GreenSolvers`, `ldos`, `conductance`, `current`, `josephson`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.hamiltonian","page":"API","title":"Quantica.hamiltonian","text":"hamiltonian(lat::Lattice, model; orbitals = 1)\n\nCreate a Hamiltonian or ParametricHamiltonian by applying model to the lattice lat (see onsite, @onsite, hopping and @hopping for details on building tight-binding models).\n\nhamiltonian(lat::Lattice, model, modifiers...; orbitals = 1)\nhamiltonian(h::AbstractHamiltonian, modifiers...; orbitals = 1)\n\nCreate a ParametricHamiltonian where all onsite and hopping terms in model can be parametrically modified through the provided modifiers (see @onsite! and @hopping! for details on defining modifiers).\n\nKeywords\n\norbitals: number of orbitals per sublattice. If an Integer (or a Val{<:Integer} for type-stability), all sublattices will have the same number of orbitals. A collection of values indicates the orbitals on each sublattice.\n\nCurrying\n\nlat |> hamiltonian(model[, modifiers...]; kw...)\n\nCurried form of hamiltonian equivalent to hamiltonian(lat, model, modifiers...; kw...).\n\nIndexing\n\nh[dn::SVector{L,Int}]\nh[dn::NTuple{L,Int}]\n\nReturn the Bloch harmonic of an h::AbstractHamiltonian in the form of a SparseMatrixCSC with complex scalar eltype. This matrix is \"flat\", in the sense that it contains matrix elements between indivisual orbitals, not sites. This distinction is only relevant for multiorbital Hamiltonians. To access the non-flattened matrix use h[unflat(dn)] (see also unflat).\n\nh[()]\n\nSpecial syntax equivalent to h[(0...)], which access the fundamental Bloch harmonic.\n\nCall syntax\n\nph(; params...)\n\nReturn a h::Hamiltonian from a ph::ParametricHamiltonian by applying specific values to its parameters params. If ph is a non-parametric Hamiltonian instead, this is a no-op.\n\nh(φs; params...)\n\nReturn the flat, sparse Bloch matrix of h::AbstractHamiltonian at Bloch phases φs, with applied parameters params if h is a ParametricHamiltonian. The Bloch matrix is defined as H = ∑_dn exp(-im φs⋅dn) H_dn, where H_dn = h[dn] is the dn flat Bloch harmonic of h, and φs[i] = k⋅aᵢ in terms of the wavevector k and the Bravais vectors aᵢ.\n\nExamples\n\njulia> h = hamiltonian(LP.honeycomb(), hopping(SA[0 1; 1 0], range = 1/√3), orbitals = 2)\nHamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5\n  Harmonic size    : 2 × 2\n  Orbitals         : [2, 2]\n  Element type     : 2 × 2 blocks (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 3.0\n\njulia> h((0,0))\n4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:\n     ⋅          ⋅      0.0+0.0im  3.0+0.0im\n     ⋅          ⋅      3.0+0.0im  0.0+0.0im\n 0.0+0.0im  3.0+0.0im      ⋅          ⋅    \n 3.0+0.0im  0.0+0.0im      ⋅          ⋅    \n\nSee also\n\n`lattice`, `onsite`, `hopping`, `@onsite`, `@hopping`, `@onsite!`, `@hopping!`, `ishermitian`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.hopping","page":"API","title":"Quantica.hopping","text":"hopping(t; hops...)\nhopping((r, dr) -> t(r, dr); hops...)\n\nBuild a TighbindingModel representing a uniform or a position-dependent hopping amplitude, respectively, on hops selected by hopselector(; hops...) (see hopselector for details).\n\nHops from a site at position r₁ to another at r₂ are described using the hop center r = (r₁ + r₂)/2 and the hop vector dr = r₂ - r₁. Hopping amplitudes t can be a Number (for hops between single-orbital sites), a UniformScaling (e.g. 2I) or an AbstractMatrix (use SMatrix for performance) of dimensions matching the number of orbitals in the selected sites. Models may be applied to a lattice lat to produce an Hamiltonian with hamiltonian(lat, model; ...), see hamiltonian. Position dependent models are forced to preserve the periodicity of the lattice.\n\nhopping(m::Union{TighbindingModel,ParametricModel}; hops...)\n\nConvert m into a new model with just hopping terms acting on hops.\n\nModel algebra\n\nModels can be combined using +, - and *, or conjugated with ', e.g. onsite(1) - 2 * hopping(1)'.\n\nExamples\n\njulia> model = hopping((r, dr) -> cis(dot(SA[r[2], -r[1]], dr)); dcells = (0,0)) + onsite(r -> rand())\nTightbindingModel: model with 2 terms\n  HoppingTerm{Function}:\n    Region            : any\n    Sublattice pairs  : any\n    Cell distances    : (0, 0)\n    Hopping range     : Neighbors(1)\n    Reverse hops      : false\n    Coefficient       : 1\n  OnsiteTerm{Function}:\n    Region            : any\n    Sublattices       : any\n    Cells             : any\n    Coefficient       : 1\n\njulia> LP.honeycomb() |> supercell(2) |> hamiltonian(model)\nHamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 1\n  Harmonic size    : 8 × 8\n  Orbitals         : [1, 1]\n  Element type     : scalar (ComplexF64)\n  Onsites          : 8\n  Hoppings         : 16\n  Coordination     : 2.0\n\nSee also\n\n`onsite`, `@onsite`, `@hopping`, `@onsite!`, `@hopping!`, `hamiltonian`, `plusadjoint`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.hopselector","page":"API","title":"Quantica.hopselector","text":"hopselector(; range = neighbors(1), dcells = missing, sublats = missing, region = missing)\n\nReturn a HopSelector object that can be used to select a finite set of hops between sites in a lattice. Hops between two sites at positions r₁ = r - dr/2 and r₂ = r + dr, belonging to unit cells with a cell distance dn::SVector{L,Int} and to a sublattices with names s₁::Symbol and s₂::Symbol will be selected only if\n\n`region(r, dr) && (s₁ => s₂ in sublats) && (dcell in dcells) && (norm(dr) <= range)`\n\nIf any of these is missing it will not be used to constraint the selection.\n\nGeneralization\n\nWhile range is usually a Real, and sublats and dcells are usually collections of Pair{Symbol}s and SVectors, respectively, they also admit other possibilities:\n\nsublats = :A                       # Hops from :A to :A\nsublats = :A => :B                 # Hops from :A to :B sublattices, but not from :B to :A\nsublats = (:A => :B,)              # Same as above\nsublats = (:A => :B, :C => :D)     # Hopping from :A to :B or :C to :D\nsublats = (:A, :C) .=> (:B, :D)    # Broadcasted pairs, same as above\nsublats = (:A, :C) => (:B, :D)     # Direct product, (:A=>:B, :A=>:D, :C=>:B, :C=>D)\nsublats = 1 => 2                   # Hops from 1st to 2nd sublat. All the above patterns also admit Ints\nsublats = (spec₁, spec₂, ...)      # Hops matching any of the specs with any of the above forms\n\ndcells  = dn::SVector{L,Integer}   # Hops between cells separated by `dn`\ndcells  = dn::NTuple{L,Integer}    # Hops between cells separated by `SVector(dn)`\ndcells  = f::Function              # Hops between cells separated by `dn` such that `f(dn) == true`\n\nrange   = neighbors(n)             # Hops within the `n`-th nearest neighbor distance in the lattice\nrange   = (min, max)               # Hops at distance inside the `[min, max]` closed interval (bounds can also be `neighbors(n)`)\n\nUsage\n\nAlthough the constructor hopselector(; kw...) is exported, the end user does not usually need to call it directly. Instead, the keywords kw are input into different functions that allow filtering hops, which themselves call hopselector internally as needed. Some of these functions are\n\n- hopping(...; kw...)   : hopping model term to be applied to site pairs specified by `kw`\n- @hopping(...; kw...)  : parametric hopping model term to be applied to site pairs specified by `kw`\n- @hopping!(...; kw...) : hopping modifier to be applied to site pairs specified by `kw`\n\nExamples\n\njulia> h = LP.honeycomb() |> hamiltonian(hopping(1, range = neighbors(2), sublats = (:A, :B) .=> (:A, :B)))\nHamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 7\n  Harmonic size    : 2 × 2\n  Orbitals         : [1, 1]\n  Element type     : scalar (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 12\n  Coordination     : 6.0\n\njulia> h = LP.honeycomb() |> hamiltonian(hopping(1, range = (neighbors(2), neighbors(3)), sublats = (:A, :B) => (:A, :B)))\nHamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 9\n  Harmonic size    : 2 × 2\n  Orbitals         : [1, 1]\n  Element type     : scalar (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 18\n  Coordination     : 9.0\n\nSee also\n\n`siteselector`, `lattice`, `hopping`, `@hopping`, `@hopping!`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.josephson","page":"API","title":"Quantica.josephson","text":"josephson(gs::GreenSlice, ωmax; kBT = 0.0, phases = missing, imshift = missing, slope = 1, post = real, quadgk_opts...)\n\nFor a gs = g[i::Integer] slice of the g::GreenFunction of a hybrid junction, build a partially evaluated object J::Integrator representing the equilibrium (static) Josephson current I_J flowing into g through contact i, integrated from -ωmax to ωmax (or from -ωmax to 0 at zero temperature kBT = 0). The result of I_J is given in units of qe/h (q is the dimensionless carrier charge). I_J can be written as I_J = Re  dω f(ω) j(ω), where j(ω) = (qeh)  2Tr(ΣʳᵢGʳ - GʳΣʳᵢ)τz.\n\nFull evaluation\n\nJ(; params...)\n\nEvaluate the Josephson current I_J for the given g parameters params, if any.\n\nKeywords\n\nkBT : temperature in same energy units as the Hamiltonian\nphases : collection of superconducting phase biases to apply to the contact, so as to efficiently compute the full current-phase relation [I_J(ϕ) for ϕ in phases]. Note that each phase bias ϕ is applied by a [cis(-ϕ/2) 0; 0 cis(ϕ/2)] rotation to the self energy, which is almost free. If missing, a single I_J is returned.\nimshift: if missing the initial and final integration points ± ωmax are shifted by im * sqrt(eps(ωmax)), to avoid the real axis. Otherwise a shift im*imshift is applied (may be zero if ωmax is greater than the bandwidth).\nslope: if non-zero, the integration will be performed along a piecewise-linear path in the complex plane (-ωmax, -ωmax/2 * (1+slope*im), 0, ωmax/2 * (1+slope*im), ωmax), taking advantage of the holomorphic integrand f(ω) j(ω) and the Cauchy Integral Theorem for faster convergence.\npost: function to apply to the result of ∫ dω f(ω) j(ω) to obtain the result, post = real by default.\nquadgk_opts : extra keyword arguments to pass on to the function QuadGK.quadgk that is used for the integration.\n\nExamples\n\njulia> glead = LP.square() |> hamiltonian(onsite(0.0005 * SA[0 1; 1 0]) + hopping(SA[1 0; 0 -1]), orbitals = 2) |> supercell((1,0), region = r->-2<r[2]<2) |> greenfunction(GS.Schur(boundary = 0));\n\njulia> g0 = LP.square() |> hamiltonian(hopping(SA[1 0; 0 -1]), orbitals = 2) |> supercell(region = r->-2<r[2]<2 && r[1]≈0) |> attach(glead, reverse = true) |> attach(glead) |> greenfunction;\n\njulia> J = josephson(g0[1], 4; phases = subdiv(0, pi, 10))\nIntegrator: Complex-plane integrator\n  Integration path    : (-4.0 + 1.4901161193847656e-8im, -2.0 + 2.000000014901161im, 0.0 + 1.4901161193847656e-8im)\n  Integration options : ()\n  Integrand:          :\n  JosephsonDensity{Float64} : Equilibrium (dc) Josephson current observable before integration over energy\n    kBT                     : 0.0\n    Contact                 : 1\n    Number of phase shifts  : 10\n\njulia> J()\n10-element Vector{Float64}:\n -6.751348391359149e-16\n  0.0016315088241546964\n  0.003213820056117238\n  0.004699191781510955\n  0.0060427526322931946\n  0.0072038354411029185\n  0.008147188939639644\n  0.008844017741703502\n  0.009272686515034255\n -1.7744618723033526e-12\n\nSee also\n\n`greenfunction`,`ldos`, `current`, `conductance`, `transmission`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.lattice","page":"API","title":"Quantica.lattice","text":"lattice(sublats::Sublat...; bravais = (), dim, type, names)\nlattice(sublats::AbstractVector{<:Sublat}; bravais = (), dim, type, names)\n\nCreate a Lattice{T,E,L} from sublattices sublats, where L is the number of Bravais vectors given by bravais, T = type is the AbstractFloat type of spatial site coordinates, and dim = E is the spatial embedding dimension.\n\nlattice(lat::Lattice; bravais = missing, dim = missing, type = missing, names = missing)\n\nCreate a new lattice by applying any non-missing keywords to lat.\n\nlattice(x)\n\nReturn the parent lattice of object x, of type e.g. LatticeSlice, Hamiltonian, etc.\n\nKeywords\n\nbravais: a collection of one or more Bravais vectors of type NTuple{E} or SVector{E}. It can also be an AbstractMatrix of dimension E×L. The default bravais = () corresponds to a bounded lattice with no Bravais vectors.\nnames: a collection of Symbols. Can be used to rename sublats. Any repeated names will be replaced if necessary by :A, :B etc. to ensure that all sublattice names are unique.\n\nIndexing\n\nlat[kw...]\n\nIndexing into a lattice lat with keywords returns LatticeSlice representing a finite collection of sites selected by siteselector(; kw...). See siteselector for details on possible kw, and sites to obtain site positions.\n\nlat[]\n\nSpecial case equivalent to lat[cells = (0,...)] that returns a LatticeSlice of the zero-th unitcell.\n\nExamples\n\njulia> lat = lattice(sublat((0, 0)), sublat((0, 1)); bravais = (1, 0), type = Float32, dim = 3, names = (:up, :down))\nLattice{Float32,3,1} : 1D lattice in 3D space\n  Bravais vectors : Vector{Float32}[[1.0, 0.0, 0.0]]\n  Sublattices     : 2\n    Names         : (:up, :down)\n    Sites         : (1, 1) --> 2 total per unit cell\n\njulia> lattice(lat; type = Float64, names = (:A, :B), dim = 2)\nLattice{Float64,2,1} : 1D lattice in 2D space\n  Bravais vectors : [[1.0, 0.0]]\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (1, 1) --> 2 total per unit cell\n\nSee also\n\n`LatticePresets`, `sublat`, `sites`, `supercell`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.ldos","page":"API","title":"Quantica.ldos","text":"ldos(gs::GreenSlice; kernel = I)\n\nBuild ρs::LocalSpectralDensitySlice, a partially evaluated object representing the local density of states ρᵢ(ω) at specific sites i but at arbitrary energy ω.\n\nldos(gω::GreenSolution; kernel = I)\n\nBuild ρω::LocalSpectralDensitySolution, as above, but for ρᵢ(ω) at a fixed ω and arbitrary sites i. See also greenfunction for details on building a GreenSlice and GreenSolution.\n\nThe local density of states is defined here as ρᵢ(ω) = -Tr(gᵢᵢ(ω))π, where gᵢᵢ(ω) is the retarded Green function at a given site i.\n\nKeywords\n\nkernel : for multiorbital sites, kernel allows to compute a generalized ldos ρᵢ(ω) = -Tr(gᵢᵢ(ω) * kernel)/π, where gᵢᵢ(ω) is the retarded Green function at site i and energy ω.\n\nFull evaluation\n\nρω[sites...]\nρs(ω; params...)\n\nGiven a partially evaluated ρω::LocalSpectralDensitySolution or ρs::LocalSpectralDensitySlice, build a vector [ρ₁(ω), ρ₂(ω)...] of fully evaluated local densities of states.\n\nExample\n\njulia> g = HP.graphene(a0 = 1, t0 = 1) |> supercell(region = RP.circle(20)) |> attach(nothing, region = RP.circle(1)) |> greenfunction(GS.KPM(order = 300, bandrange = (-3.1, 3.1)))\nGreenFunction{Float64,2,0}: Green function of a Hamiltonian{Float64,2,0}\n  Solver          : AppliedKPMGreenSolver\n  Contacts        : 1\n  Contact solvers : (SelfEnergyEmptySolver,)\n  Contact sizes   : (6,)\n  Hamiltonian{Float64,2,0}: Hamiltonian on a 0D Lattice in 2D space\n    Bloch harmonics  : 1\n    Harmonic size    : 2898 × 2898\n    Orbitals         : [1, 1]\n    Element type     : scalar (ComplexF64)\n    Onsites          : 0\n    Hoppings         : 8522\n    Coordination     : 2.94065\n\njulia> ldos(g(0.2))[1]\n6-element Vector{Float64}:\n 0.036802204179316955\n 0.034933055722650375\n 0.03493305572265026\n 0.03493305572265034\n 0.03493305572265045\n 0.036802204179317045\n\nSee also\n\n`greenfunction`, `current`, `conductance`, `josephson`, `transmission`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.neighbors","page":"API","title":"Quantica.neighbors","text":"neighbors(n::Int)\n\nCreate a Neighbors(n) object that represents a hopping range to distances corresponding to the n-th nearest neighbors in a given lattice, irrespective of their sublattice. Neighbors at equal distance do not count towards n.\n\nneighbors(n::Int, lat::Lattice)\n\nObtain the actual nth-nearest-neighbot distance between sites in lattice lat.\n\nSee also\n\n`hopping`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.onsite","page":"API","title":"Quantica.onsite","text":"onsite(o; sites...)\nonsite(r -> o(r); sites...)\n\nBuild a TighbindingModel representing a uniform or a position-dependent onsite potential, respectively, on sites selected by siteselector(; sites...) (see siteselector for details).\n\nSite positions are r::SVector{E}, where E is the embedding dimension of the lattice. The onsite potential o can be a Number (for single-orbital sites), a UniformScaling (e.g. 2I) or an AbstractMatrix (use SMatrix for performance) of dimensions matching the number of orbitals in the selected sites. Models may be applied to a lattice lat to produce a Hamiltonian with hamiltonian(lat, model; ...), see hamiltonian. Position dependent models are forced to preserve the periodicity of the lattice.\n\nonsite(m::{TighbindingModel,ParametricModel}; sites...)\n\nConvert m into a new model with just onsite terms acting on sites.\n\nModel algebra\n\nModels can be combined using +, - and *, or conjugated with ', e.g. onsite(1) - 2 * hopping(1)'.\n\nExamples\n\njulia> model = onsite(r -> norm(r) * SA[0 1; 1 0]; sublats = :A) - hopping(I; range = 2)\nTightbindingModel: model with 2 terms\n  OnsiteTerm{Function}:\n    Region            : any\n    Sublattices       : A\n    Cells             : any\n    Coefficient       : 1\n  HoppingTerm{LinearAlgebra.UniformScaling{Bool}}:\n    Region            : any\n    Sublattice pairs  : any\n    Cell distances    : any\n    Hopping range     : 2.0\n    Reverse hops      : false\n    Coefficient       : -1\n\njulia> LP.cubic() |> supercell(4) |> hamiltonian(model, orbitals = 2)\nHamiltonian{Float64,3,3}: Hamiltonian on a 3D Lattice in 3D space\n  Bloch harmonics  : 27\n  Harmonic size    : 64 × 64\n  Orbitals         : [2]\n  Element type     : 2 × 2 blocks (ComplexF64)\n  Onsites          : 64\n  Hoppings         : 2048\n  Coordination     : 32.0\n\nSee also\n\n`hopping`, `@onsite`, `@hopping`, `@onsite!`, `@hopping!`, `hamiltonian`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.plusadjoint","page":"API","title":"Quantica.plusadjoint","text":"plusadjoint(t::Model)\n\nReturns a model t + t'. This is a convenience function analogous to the + h.c. notation.\n\nExample\n\njulia> model = hopping(im, sublats = :A => :B) |> plusadjoint\nTightbindingModel: model with 2 terms\n  HoppingTerm{Complex{Bool}}:\n    Region            : any\n    Sublattice pairs  : :A => :B\n    Cell distances    : any\n    Hopping range     : Neighbors(1)\n    Reverse hops      : false\n    Coefficient       : 1\n  HoppingTerm{Complex{Int64}}:\n    Region            : any\n    Sublattice pairs  : :A => :B\n    Cell distances    : any\n    Hopping range     : Neighbors(1)\n    Reverse hops      : true\n    Coefficient       : 1\n\njulia> h = hamiltonian(LP.honeycomb(), model)\nHamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5\n  Harmonic size    : 2 × 2\n  Orbitals         : [1, 1]\n  Element type     : scalar (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 3.0\n\njulia> h((0,0))\n2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅      0.0-3.0im\n 0.0+3.0im      ⋅\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.sites","page":"API","title":"Quantica.sites","text":"sites(lat::Lattice[, sublat])\n\nReturn a collection of site positions in the unit cell of lattice lat. If a sublat::Symbol or sublat::Int is specified, only sites for the specified sublattice are returned.\n\nsites(ls::LatticeSlice)\n\nReturn a collection of positions of a LatticeSlice, generally obtained by indexing a lattice lat[sel...] with some siteselector keywords sel. See also lattice.\n\nNote: the returned collections can be of different types (vectors, generators, views...)\n\nExamples\n\njulia> sites(LatticePresets.honeycomb(), :A)\n1-element view(::Vector{SVector{2, Float64}}, 1:1) with eltype SVector{2, Float64}:\n [0.0, -0.2886751345948129]\n\nSee also\n\n`lattice`, `siteselector`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.siteselector","page":"API","title":"Quantica.siteselector","text":"siteselector(; region = missing, sublats = missing, cells = missing)\n\nReturn a SiteSelector object that can be used to select a finite set of sites in a lattice. Sites at position r::SVector{E}, belonging to a cell of index n::SVector{L,Int} and to a sublattice with name s::Symbol will be selected only if\n\n`region(r) && s in sublats && n in cells`\n\nAny missing region, sublat or cells will not be used to constraint the selection.\n\nGeneralization\n\nWhile sublats and cells are usually collections of Symbols and SVectors, respectively, they also admit other possibilities:\n\nIf either cells or sublats are a single cell or sublattice, they will be treated as single-element collections\nIf sublat is a collection of Integers, it will refer to sublattice numbers.\nIf cells is an i::Integer, it will be converted to an SVector{1}\nIf cells is a collection, each element will be converted to an SVector.\nIf cells is a boolean function, n in cells will be the result of cells(n)\n\nUsage\n\nAlthough the constructor siteselector(; kw...) is exported, the end user does not usually need to call it directly. Instead, the keywords kw are input into different functions that allow filtering sites, which themselves call siteselector internally as needed. Some of these functions are\n\ngetindex(lat::Lattice; kw...) : return a LatticeSlice with sites specified by kw (also lat[kw...])\nsupercell(lat::Lattice; kw...) : returns a bounded lattice with the sites specified by kw\nonsite(...; kw...) : onsite model term to be applied to sites specified by kw\n@onsite!(...; kw...) : onsite modifier to be applied to sites specified by kw\n\nSee also\n\n`hopselector`, `lattice`, `supercell`, `onsite`, `@onsite`, `@onsite!`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.spectrum","page":"API","title":"Quantica.spectrum","text":"spectrum(h::AbstractHamiltonian, ϕs; solver = EigenSolvers.LinearAlgebra()], transform = missing, params...)\n\nCompute the Spectrum of the Bloch matrix h(ϕs; params...) using the specified eigensolver, with transform applied to the resulting eigenenergies, if not missing. Eigenpairs are sorted by the real part of their energy. See EigenSolvers for available solvers and their options.\n\nspectrum(h::AbstractHamiltonian; kw...)\n\nFor a 0D h, equivalent to spectrum(h, (); kw...)\n\nspectrum(m::AbstractMatrix; solver = EigenSolvers.LinearAlgebra()], transform = missing)\n\nCompute the Spectrum of matrix m using solver and transform.\n\nspectrum(b::Bandstructure, ϕs)\n\nCompute the Spectrum corresponding to slicing the bandstructure b at point ϕs of its base mesh (see bands for details).\n\nIndexing and destructuring\n\nEigenenergies ϵs::Tuple and eigenstates ψs::Matrix can be extracted from a spectrum sp using any of the following\n\nϵs, ψs = sp\nϵs = first(sp)\nϵs = energies(sp)\nψs = last(sp)\nψs = states(sp)\n\nIn addition, one can extract the n eigenpairs closest (in real energy) to a given energy ϵ₀ with\n\nϵs, ψs = sp[1:n, around = ϵ₀]\n\nMore generally, sp[inds, around = ϵ₀] will take the eigenpairs at position given by inds after sorting by increasing distance to ϵ₀, or the closest eigenpair in inds is missing. If around is omitted, the ordering in sp is used.\n\nExamples\n\njulia> h = HP.graphene(t0 = 1); spectrum(h, (0,0))\nSpectrum{Float64,ComplexF64} :\nEnergies:\n2-element Vector{ComplexF64}:\n -2.9999999999999982 + 0.0im\n  2.9999999999999982 + 0.0im\nStates:\n2×2 Matrix{ComplexF64}:\n -0.707107+0.0im  0.707107+0.0im\n  0.707107+0.0im  0.707107+0.0im\n\nSee also\n\n`EigenSolvers`, `bands`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.states","page":"API","title":"Quantica.states","text":"states(sp::Spectrum)\n\nReturns the eigenstates in sp as columns of a matrix. Equivalent to last(sp).\n\nSee also\n\n`spectrum`, `bands`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.subdiv","page":"API","title":"Quantica.subdiv","text":"subdiv((x₁, x₂, ..., xₙ), (p₁, p₂, ..., pₙ₋₁))\n\nBuild a vector of values between x₁ and xₙ containing all xᵢ such that in each interval [xᵢ, xᵢ₊₁] there are pᵢ equally space values.\n\nsubdiv((x₁, x₂, ..., xₙ), p)\n\nSame as above with all pᵢ = p\n\nsubdiv(x₁, x₂, p)\n\nEquivalent to subdiv((x₁, x₂), p) == collect(range(x₁, x₂, length = p))\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.sublat","page":"API","title":"Quantica.sublat","text":"sublat(sites...; name::Symbol = :A)\nsublat(sites::AbstractVector; name::Symbol = :A)\n\nCreate a Sublat{E,T} that adds a sublattice, of name name, with sites at positions sites in E dimensional space. Sites positions can be entered as Tuples or SVectors.\n\nExamples\n\njulia> sublat((0.0, 0), (1, 1), (1, -1), name = :A)\nSublat{2,Float64} : sublattice of Float64-typed sites in 2D space\n  Sites    : 3\n  Name     : :A\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.supercell","page":"API","title":"Quantica.supercell","text":"supercell(lat::Lattice{E,L}, v::NTuple{L,Integer}...; seed = missing, kw...)\nsupercell(lat::Lattice{E,L}, uc::SMatrix{L,L´,Int}; seed = missing, kw...)\n\nGenerate a new Lattice from an L-dimensional lattice lat with a larger unit cell, such that its Bravais vectors are br´= br * uc. Here uc::SMatrix{L,L´,Int} is the integer supercell matrix, with the L´ vectors vs as its columns. If no v are given, the new lattice will have no Bravais vectors (i.e. it will be bounded, with its shape determined by keywords kw...). Likewise, if L´ < L, the resulting lattice will be bounded along L´ - L directions, as dictated by kw....\n\nOnly sites selected by siteselector(; kw...) will be included in the supercell (see siteselector for details on the available keywords kw). If no keyword region is given in kw, a single Bravais unit cell perpendicular to the v axes will be selected along the L-L´ bounded directions.\n\nsupercell(lattice::Lattice{E,L}, factors::Integer...; seed = missing, kw...)\n\nCall supercell with different scaling along each Bravais vector, so that supercell matrix uc is Diagonal(factors). If a single factor is given, uc = SMatrix{L,L}(factor * I)\n\nsupercell(h::Hamiltonian, v...; mincoordination = 0, seed = missing, kw...)\n\nTransform the Lattice of h to have a larger unit cell, while expanding the Hamiltonian accordingly.\n\nKeywords\n\nseed::NTuple{L,Integer}: starting cell index to perform search of included sites. By default seed = missing, which makes search start from the zero-th cell.\nmincoordination::Integer: minimum number of nonzero hopping neighbors required for sites to be included in the supercell. Sites with less coordination will be removed recursively, until all remaining sites satisfy mincoordination.\n\nCurrying\n\nlat_or_h |> supercell(v...; kw...)\n\nCurried syntax, equivalent to supercell(lat_or_h, v...; kw...)\n\nExamples\n\njulia> LatticePresets.square() |> supercell((1, 1), region = r -> 0 < r[1] < 5)\nLattice{Float64,2,1} : 1D lattice in 2D space\n  Bravais vectors : [[1.0, 1.0]]\n  Sublattices     : 1\n    Names         : (:A,)\n    Sites         : (8,) --> 8 total per unit cell\n\njulia> LatticePresets.honeycomb() |> supercell(3)\nLattice{Float64,2,2} : 2D lattice in 2D space\n  Bravais vectors : [[1.5, 2.598076], [-1.5, 2.598076]]\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (9, 9) --> 18 total per unit cell\n\nSee also\n\n`supercell`, `siteselector`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.transform","page":"API","title":"Quantica.transform","text":"transform(lat_or_h::Union{Lattice,AbstractHamiltonian}, f::Function)\n\nBuild a new lattice or hamiltonian transforming each site positions r into f(r).\n\nCurrying\n\nx |> transform(f::Function)\n\nCurried version of transform, equivalent to transform(f, x)\n\nNote: Unexported `Quantica.transform!` is also available for in-place transforms. Use with care, as aliasing (i.e. several objects sharing the modified one) can produce unexpected results.\n\nExamples\n\njulia> LatticePresets.square() |> transform(r -> 3r)\nLattice{Float64,2,2} : 2D lattice in 2D space\n  Bravais vectors : [[3.0, 0.0], [0.0, 3.0]]\n  Sublattices     : 1\n    Names         : (:A,)\n    Sites         : (1,) --> 1 total per unit cell\n\nSee also\n\n`translate`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.translate","page":"API","title":"Quantica.translate","text":"translate(lat::Lattice, δr)\n\nBuild a new lattice translating each site positions from r to r + δr, where δr can be a NTuple or an SVector in embedding space.\n\nCurrying\n\nx |> translate(δr)\n\nCurried version of translate, equivalent to translate(x, δr)\n\nNote: Unexported `Quantica.translate!` is also available for in-place translations. Use with care, as aliasing (i.e. several objects sharing the modified one) can produce unexpected results.\n\nExamples\n\njulia> LatticePresets.square() |> translate((3,3)) |> sites\n1-element Vector{SVector{2, Float64}}:\n [3.0, 3.0]\n\n\nSee also\n\n`transform`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.transmission","page":"API","title":"Quantica.transmission","text":"transmission(gs::GreenSlice)\n\nGiven a slice gs = g[i::Integer, j::Integer] of a g::GreenFunction, build a partially evaluated object T::Transmission representing the normal transmission probability Tᵢⱼ(ω) from contact j to i at energy ω. It can be written as Tᵢⱼ = TrgʳΓⁱgᵃΓʲ. Here gʳ = g(ω) and gᵃ = (gʳ)' = g(ω') are the retarded and advanced Green function of the system, and Γⁱ = im * (Σⁱ - Σⁱ') is the decay rate at contact i\n\nFull evaluation\n\nT(ω; params...)\n\nCompute the transmission Tᵢⱼ(ω) at a given ω and for the specified params of g.\n\nExamples\n\njulia> # A central system g0 with two 1D leads and transparent contacts\n\njulia> glead = LP.honecycomb() |> hamiltonian(hopping(1)) |> supercell((1,-1), region = r->-2<r[2]<2) |> greenfunction(GS.Schur(boundary = 0));\n\njulia> g0 = LP.honecycomb() |> hamiltonian(hopping(1)) |> supercell(region = r->-2<r[2]<2 && r[1]≈0) |> attach(glead, reverse = true) |> attach(glead) |> greenfunction;\n\njulia> T = transmission(g0[2, 1])\nTransmission: total transmission probability between two different contacts\n  From contact  : 1\n  To contact    : 2\n\njulia> T(0.2)   # The difference from 3 is due to the automatic `im*sqrt(eps(Float64))` added to `ω`\n2.9999999410323537\n\njulia> T(0.2 + 0.00000000000001im)\n2.999999999999961\n\nSee also\n\n`greenfunction`, `conductance`, `ldos`, `current`, `josephson`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.unflat","page":"API","title":"Quantica.unflat","text":"unflat(dn)\n\nConstruct an u::Unflat object wrapping some indices dn. This object is meant to be used to index into a h::AbstractHamiltonian as h[u], which returns an non-flattened version of the Bloch harmonic h[dn]. Each element in the matrix h[u] is an SMatrix block representing onsite or hoppings between whole sites, in contrast to h[dn] where they are scalars representing single orbitals. This is only relevant for multi-orbital Hamiltonians h.\n\nunflat()\n\nEquivalent to unflat(())\n\nExamples\n\njulia> h = HP.graphene(orbitals = 2); h[unflat(0,0)])\n2×2 SparseArrays.SparseMatrixCSC{SMatrix{2, 2, ComplexF64, 4}, Int64} with 2 stored entries:\n                     ⋅                       [2.7+0.0im 0.0+0.0im; 0.0+0.0im 2.7+0.0im]\n [2.7+0.0im 0.0+0.0im; 0.0+0.0im 2.7+0.0im]                      ⋅                     \n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.wrap","page":"API","title":"Quantica.wrap","text":"wrap(h::AbstractHamiltonian, (ϕ₁, ϕ₂,...))\n\nFor an h of lattice dimension L and a set of L Bloch phases ϕ = (ϕ₁, ϕ₂,...), contruct a new zero-dimensional h´::AbstractHamiltonian for all Bravais vectors have been eliminated by wrapping the lattice onto itself along the corresponding Bravais vector. Intercell hoppings along wrapped directions will pick up a Bloch phase exp(-iϕ⋅dn).\n\nIf a number L´ of phases ϕᵢ are : instead of numbers, the corresponding Bravais vectors will not be wrapped, and the resulting h´ will have a finite lattice dimension L´.\n\nExamples\n\njulia> h2D = HP.graphene(); h1D = wrap(h2D, (:, 0.2))\nHamiltonian{Float64,2,1}: Hamiltonian on a 1D Lattice in 2D space\n  Bloch harmonics  : 3\n  Harmonic size    : 2 × 2\n  Orbitals         : [1, 1]\n  Element type     : scalar (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 4\n  Coordination     : 2.0\n\njulia> h2D((0.3, 0.2)) ≈ h1D(0.3)\ntrue\n\nSee also\n\n`hamiltonian`, `supercell`\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantica.@hopping","page":"API","title":"Quantica.@hopping","text":"@hopping((; params...) -> t(; params...); hops...)\n@hopping((r, dr; params...) -> t(r; params...); hops...)\n\nBuild a ParametricModel representing a uniform or a position-dependent hopping amplitude, respectively, on hops selected by hopselector(; hops...) (see hopselector for details).\n\nHops from a site at position r₁ to another at r₂ are described using the hop center r = (r₁ + r₂)/2 and the hop vector dr = r₂ - r₁. Hopping amplitudes t can be a Number (for hops between single-orbital sites), a UniformScaling (e.g. 2I) or an AbstractMatrix (use SMatrix for performance) of dimensions matching the number of site orbitals in the selected sites. Parametric models may be applied to a lattice lat to produce a ParametricHamiltonian with hamiltonian(lat, model; ...), see hamiltonian. Position dependent models are forced to preserve the periodicity of the lattice.\n\nThe difference between regular and parametric tight-binding models (see onsite and hopping) is that parametric models may depend on arbitrary parameters, specified by the params keyword arguments. These are inherited by h::ParametricHamiltonian, which can then be evaluated very efficiently for different parameter values by callling h(; params...), to obtain a regular Hamiltonian without reconstructing it from scratch.\n\n@hopping((ω; params...) -> Σᵢⱼ(ω; params...); hops...)\n@hopping((ω, r, dr; params...) -> Σᵢⱼ(ω, r, dr; params...); hops...)\n\nSpecial form of a parametric hopping amplitude meant to model a self-energy (see attach).\n\nModel algebra\n\nParametric models can be combined using +, - and *, or conjugated with ', e.g. @onsite((; o=1) -> o) - 2 * hopping(1)'. The combined parametric models can share parameters.\n\nExamples\n\njulia> model = @hopping((r, dr; t = 1, A = Returns(SA[0,0])) -> t * cis(-dr' * A(r)))\nParametricModel: model with 1 term\n  ParametricHoppingTerm{ParametricFunction{2}}\n    Region            : any\n    Sublattice pairs  : any\n    Cell distances    : any\n    Hopping range     : Neighbors(1)\n    Reverse hops      : false\n    Coefficient       : 1\n    Parameters        : [:t, :A]\n\njulia> LP.honeycomb() |> supercell(2) |> hamiltonian(model)\nParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5\n  Harmonic size    : 8 × 8\n  Orbitals         : [1, 1]\n  Element type     : scalar (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 24\n  Coordination     : 3.0\n  Parameters       : [:A, :t]\n\nSee also\n\n`onsite`, `hopping`, `@onsite`, `@onsite!`, `@hopping!`, `attach`, `hamiltonian`\n\n\n\n\n\n","category":"macro"},{"location":"api/#Quantica.@hopping!","page":"API","title":"Quantica.@hopping!","text":"@hopping!((t; params...) -> t´(t; params...); hops...)\n@hopping!((t, r, dr; params...) -> t´(t, r, dr; params...); hops...)\n\nBuild a uniform or position-dependent hopping term modifier, respectively, acting on hops selected by hopselector(; hops...) (see hopselector for details).\n\nHops from a site at position r₁ to another at r₂ are described using the hop center r = (r₁ + r₂)/2 and the hop vector dr = r₂ - r₁. The original hopping amplitude is t, and the modified hopping is t´, which is a function of t and possibly r, dr. It may optionally also depend on parameters, enconded in params.\n\nModifiers are meant to be applied to an h:AbstractHamiltonian to obtain a ParametricHamiltonian (with hamiltonian(h, modifiers...) or hamiltonian(lat, model, modifiers...), see hamiltonian). Modifiers will affect only pre-existing model terms. In particular, if no onsite model has been applied to a specific site, its onsite potential will be zero, and will not be modified by any @onsite! modifier. Conversely, if an onsite model has been applied, @onsite! may modify the onsite potential even if it is zero. The same applies to @hopping!.\n\nExamples\n\njulia> model = hopping(1); peierls = @hopping!((t, r, dr; A = r -> SA[0,0]) -> t * cis(-dr' * A(r)))\nOnsiteModifier{ParametricFunction{3}}:\n  Region            : any\n  Sublattice pairs  : any\n  Cell distances    : any\n  Hopping range     : Neighbors(1)\n  Reverse hops      : false\n  Parameters        : [:A]\n\njulia> LP.honeycomb() |> hamiltonian(model) |> supercell(10) |> hamiltonian(peierls)\nParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5\n  Harmonic size    : 200 × 200\n  Orbitals         : [1, 1]\n  Element type     : scalar (ComplexF64)\n  Onsites          : 0\n  Hoppings         : 600\n  Coordination     : 3.0\n  Parameters       : [:A]\n\nSee also\n\n`onsite`, `hopping`, `@onsite`, `@hopping`, `@onsite!`, `hamiltonian`\n\n\n\n\n\n","category":"macro"},{"location":"api/#Quantica.@onsite","page":"API","title":"Quantica.@onsite","text":"@onsite((; params...) -> o(; params...); sites...)\n@onsite((r; params...) -> o(r; params...); sites...)\n\nBuild a ParametricModel representing a uniform or a position-dependent onsite potential, respectively, on sites selected by siteselector(; sites...) (see siteselector for details).\n\nSite positions are r::SVector{E}, where E is the embedding dimension of the lattice. The onsite potential o can be a Number (for single-orbital sites), a UniformScaling (e.g. 2I) or an AbstractMatrix (use SMatrix for performance) of dimensions matching the number of orbitals in the selected sites. Parametric models may be applied to a lattice lat to produce a ParametricHamiltonian with hamiltonian(lat, model; ...), see hamiltonian. Position dependent models are forced to preserve the periodicity of the lattice.\n\nThe difference between regular and parametric tight-binding models (see onsite and hopping) is that parametric models may depend on arbitrary parameters, specified by the params keyword arguments. These are inherited by h::ParametricHamiltonian, which can then be evaluated very efficiently for different parameter values by callling h(; params...), to obtain a regular Hamiltonian without reconstructing it from scratch.\n\n@onsite((ω; params...) -> Σᵢᵢ(ω; params...); sites...)\n@onsite((ω, r; params...) -> Σᵢᵢ(ω, r; params...); sites...)\n\nSpecial form of a parametric onsite potential meant to model a self-energy (see attach).\n\nModel algebra\n\nParametric models can be combined using +, - and *, or conjugated with ', e.g. @onsite((; o=1) -> o) - 2 * hopping(1)'. The combined parametric models can share parameters.\n\nExamples\n\njulia> model = @onsite((r; dμ = 0) -> (r[1] + dμ) * I; sublats = :A) + @onsite((; dμ = 0) -> - dμ * I; sublats = :B)\nParametricModel: model with 2 terms\n  ParametricOnsiteTerm{ParametricFunction{1}}\n    Region            : any\n    Sublattices       : A\n    Cells             : any\n    Coefficient       : 1\n    Parameters        : [:dμ]\n  ParametricOnsiteTerm{ParametricFunction{0}}\n    Region            : any\n    Sublattices       : B\n    Cells             : any\n    Coefficient       : 1\n    Parameters        : [:dμ]\n\njulia> LP.honeycomb() |> supercell(2) |> hamiltonian(model, orbitals = 2)\nParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 1\n  Harmonic size    : 8 × 8\n  Orbitals         : [2, 2]\n  Element type     : 2 × 2 blocks (ComplexF64)\n  Onsites          : 8\n  Hoppings         : 0\n  Coordination     : 0.0\n  Parameters       : [:dμ]\n\nSee also\n\n`onsite`, `hopping`, `@hopping`, `@onsite!`, `@hopping!`, `attach`, `hamiltonian`\n\n\n\n\n\n","category":"macro"},{"location":"api/#Quantica.@onsite!","page":"API","title":"Quantica.@onsite!","text":"@onsite!((o; params...) -> o´(o; params...); sites...)\n@onsite!((o, r; params...) -> o´(o, r; params...); sites...)\n\nBuild a uniform or position-dependent onsite term modifier, respectively, acting on sites selected by siteselector(; sites...) (see siteselector for details).\n\nSite positions are r::SVector{E}, where E is the embedding dimension of the lattice. The original onsite potential is o, and the modified potential is o´, which is a function of o and possibly r. It may optionally also depend on parameters, enconded in params.\n\nModifiers are meant to be applied to an h:AbstractHamiltonian to obtain a ParametricHamiltonian (with hamiltonian(h, modifiers...) or hamiltonian(lat, model, modifiers...), see hamiltonian). Modifiers will affect only pre-existing model terms. In particular, if no onsite model has been applied to a specific site, its onsite potential will be zero, and will not be modified by any @onsite! modifier. Conversely, if an onsite model has been applied, @onsite! may modify the onsite potential even if it is zero. The same applies to @hopping!.\n\nExamples\n\njulia> model = onsite(0); disorder = @onsite!((o; W = 0) -> o + W * rand())\nOnsiteModifier{ParametricFunction{1}}:\n  Region            : any\n  Sublattices       : any\n  Cells             : any\n  Parameters        : [:W]\n\njulia> LP.honeycomb() |> hamiltonian(model) |> supercell(10) |> hamiltonian(disorder)\nParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 1\n  Harmonic size    : 200 × 200\n  Orbitals         : [1, 1]\n  Element type     : scalar (ComplexF64)\n  Onsites          : 200\n  Hoppings         : 0\n  Coordination     : 0.0\n  Parameters       : [:W]\n\nSee also\n\n`onsite`, `hopping`, `@onsite`, `@hopping`, `@hopping!`, `hamiltonian`\n\n\n\n\n\n","category":"macro"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Welcome to the Quantica.jl manual!","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Here you will read about using Quantica.jl to build and compute properties of tight-binding models. This includes","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Defining general lattices in arbitrary dimensions\nDefining generic tight-binding models with arbitrary parameter dependences\nBuilding Hamiltonians of mono or multiorbital systems by combining lattices and models\nComputing bandstructures of Hamiltonians using a range of solvers\nCreating \"open Hamiltonians\" by attaching self-energies of different types to Hamiltonians, representing e.g. leads\nComputing Green functions of Hamiltonians or open Hamiltonians using a range of solvers\nComputing observables from Green functions, such as spectral densities, current densities, local and nonlocal conductances, Josephson currents, critical currents, transmission probabilities, etc.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"tip: Check the docstrings\nFull usage instructions on all Quantica functions can be obtained within the Julia REPL by querying its docstrings. For example, to obtained details on the hamiltonian function or on the available LatticePresets, just type ?hamiltonian or ?LatticePresets.","category":"page"},{"location":"manual/#Glossary","page":"Manual","title":"Glossary","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Sublat: a sublattice, representing a number of identical sites within the unit cell of a bounded or unbounded lattice. Each site has a position in an E-dimensional space (E is called the embedding dimension). All sites in a given Sublat will be able to hold the same number of orbitals, and they can be thought of as identical atoms. Each Sublat in a Lattice can be given a unique name, by default :A, :B, etc.\nLattice: a collection of Sublats plus a collection of L Bravais vectors that define the periodicity of the lattice. A bounded lattice has L=0, and no Bravais vectors. A Lattice with L > 0 can be understood as a periodic (unbounded) set of unit cells, each containing a set of sites, each of which belongs to a different sublattice.\nSiteSelector: a rule that defines a subset of sites in a Lattice\nHopSelector: a rule that defines a subset of site pairs in a Lattice\nLatticeSlice: a finite subset of sites in a Lattice, defined by their cell index (an L-dimensional integer vector) and their site index (an integer) within the unit cell. Can be obtained by combining a Lattice and a (bounded) SiteSelector.\nAbstractModel: either a TightBindingModel or a ParametricModel\nTightBindingModel: a set of HoppingTerms and OnsiteTerms\nOnsiteTerm: a rule that, applied to a single site, produces a scalar or a (square) matrix that represents the intra-site Hamiltonian elements (single or multi-orbital)\nHoppingTerm: a rule that, applied to a pair of sites, produces a scalar or a matrix that represents the inter-site Hamiltonian elements (single or multi-orbital)\nParametricOnsiteTerm and ParametricHoppingTerm: like the above, but dependent on some parameters that can be adjusted.\nAbstractHamiltonian: either a Hamiltonian or a ParametricHamiltonian\nHamiltonian: a Lattice combined with a TightBindingModel, with a specification of the number of orbitals in each Sublat in the Lattice. It represents a tight-binding Hamiltonian sharing the same periodicity as the Lattice (it is translationally invariant under Bravais vector shifts).\nParametricHamiltonian: like the above, but using a ParametricModel, which makes it dependent on a set of parameters.\nSelfEnergy: an operator defined to act on a LatticeSlice of an AbstractHamiltonian.\nOpenHamiltonian: an AbstractHamiltonian combined with a set of SelfEnergies\nGreenFunction: an OpenHamiltonian combined with a GreenSolver, which is an algorithm that can compute the Green function at any energy between any subset of sites of the underlying lattice.\nGreenSlice: a GreenFunction evaluated on a specific set of sites, but at an unspecified energy\nGreenSolution: a GreenFunction evaluated at a specific energy, but on an unspecified set of sites","category":"page"},{"location":"manual/#Building-Lattices","page":"Manual","title":"Building Lattices","text":"","category":"section"},{"location":"manual/#Constructing-a-Lattice-from-scratch","page":"Manual","title":"Constructing a Lattice from scratch","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Consider a lattice like graphene's. It has two sublattices, A and B, forming a honeycomb pattern in space. The position of the single A site inside the unitcell is [0, -a0/√3], with the B site at [0, a0/√3]. The i=1,2 Bravais vectors are Aᵢ = [± cos(π/3), sin(π/3)]. If we set the lattice constant a0 = 1, one way to build this lattice would be","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> A = (cos(π/3), sin(π/3)), (-cos(π/3), sin(π/3));\n\njulia> sA = sublat((0, -1/√3), name = :A);\n\njulia> sB = sublat((0,  1/√3), name = :B);\n\njulia> lattice(sA, sB, bravais = A)\nLattice{Float64,2,2} : 2D lattice in 2D space\n  Bravais vectors : [[0.5, 0.866025], [-0.5, 0.866025]]\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (1, 1) --> 2 total per unit cell","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"tip: Tuple, SVector and SMatrix\nNote that we have used Tuples, such as (0, 1/√3) instead of Vectors, like [0, 1/√3]. In Julia small-length Tuples are much more efficient than Vectors, since their length is known and fixed at compile time. Static vectors (SVector) and matrices (SMatrix) are also available to Quantica, which are just as efficient as Tuples. They be entered as SA[0, 1/√3] and SA[1 0; 0 1], respectively. Always use Tuple, SVector and SMatrix in Quantica where possible.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If we don't plan to address the two sublattices individually, we could also fuse them into one with","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> lat = lattice(sublat((0, 1/√3), (0, -1/√3)), bravais = A)\nLattice{Float64,2,2} : 2D lattice in 2D space\n  Bravais vectors : [[0.5, 0.866025], [-0.5, 0.866025]]\n  Sublattices     : 1\n    Names         : (:A,)\n    Sites         : (2,) --> 2 total per unit cell","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"This lattice has type Lattice{T,E,L}, with T = Float64 the numeric type of position coordinates, E = 2 the dimension of embedding space, and L = 2 the number of Bravais vectors (i.e. the lattice dimension). Both T and E, and even the Sublat names can be overridden when creating a lattice. One can also provide the Bravais vectors as a matrix, with each Aᵢ as a column","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> Amat = SA[-cos(π/3) cos(π/3); sin(π/3) sin(π/3)];\n\njulia> lat´ = lattice(sA, sB, bravais = Amat, type = Float32, dim = 3, names = (:C, :D))\nLattice{Float32,3,2} : 2D lattice in 3D space\n  Bravais vectors : Vector{Float32}[[-0.5, 0.866025, 0.0], [0.5, 0.866025, 0.0]]\n  Sublattices     : 2\n    Names         : (:C, :D)\n    Sites         : (1, 1) --> 2 total per unit cell","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"tip: Advanced: static `dim` with `Val`\nFor the dim keyword above we can alternatively use dim = Val(3), which is slightly more efficient, because the value is encoded as a type. This is a Julia thing (the concept of type stability), and can be ignored upon a first contact with Quantica.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"One can also convert an existing lattice like the above to have a different type, embedding dimension, bravais vectors, Sublat names with","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> lat´´ = lattice(lat´, bravais = √3 * Amat, type = Float16, dim = 2, names = (:Boron, :Nitrogen))\nLattice{Float16,2,2} : 2D lattice in 2D space\n  Bravais vectors : Vector{Float16}[[-0.866, 1.5], [0.866, 1.5]]\n  Sublattices     : 2\n    Names         : (:Boron, :Nitrogen)\n    Sites         : (1, 1) --> 2 total per unit cell","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"A list of site positions in a lattice lat can be obtained with sites(lat), or sites(lat, sublat) to restrict to a specific sublattice","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> sites(lat´´)\n2-element Vector{SVector{2, Float16}}:\n [0.0, -0.5]\n [0.0, 0.5]\n\njulia> sites(lat´´, :Nitrogen)\n1-element view(::Vector{SVector{2, Float16}}, 2:2) with eltype SVector{2, Float16}:\n [0.0, 0.5]","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Similarly, the Bravais matrix of a lat can be obtained with bravais_matrix(lat).","category":"page"},{"location":"manual/#Lattice-presets","page":"Manual","title":"Lattice presets","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"We can also use a collection of pre-built lattices in different dimensions, which are defined in the submodule LatticePresets, also called LP. These presets currently include","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"LP.linear: linear 1D lattice\nLP.square: square 2D lattice\nLP.honeycomb: square 2D lattice\nLP.cubic: cubic 3D lattice\nLP.bcc: body-centered cubic 3D lattice\nLP.fcc: face-centered cubic 3D lattice","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"One can modify any of these presets by passing a bravais, type, dim, names and also a new keyword a0 for the lattice constant. The last lattice above can thus be also obtained with","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> lat´´ = LP.honeycomb(a0 = √3, type = Float16, names = (:Boron, :Nitrogen))\nLattice{Float16,2,2} : 2D lattice in 2D space\n  Bravais vectors : Vector{Float16}[[0.866, 1.5], [-0.866, 1.5]]\n  Sublattices     : 2\n    Names         : (:Boron, :Nitrogen)\n    Sites         : (1, 1) --> 2 total per unit cell","category":"page"},{"location":"manual/#Visualizing-lattices","page":"Manual","title":"Visualizing lattices","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"To produce an interactive visualization of Lattices or other Quantica object you need to load GLMakie, CairoMakie or some other plotting backend from the Makie repository (i.e. do using GLMakie, see also Installation). Then, a number of new plotting functions will become available. The main one is qplot. A Lattice is represented, by default, as the sites in a unitcell plus the Bravais vectors.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> using GLMakie\n\njulia> lat = LP.honeycomb()\n\njulia> qplot(lat, hide = ())","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"<img src=\"../assets/honeycomb_lat.png\" alt=\"Honeycomb lattice\" width=\"250\" />","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"qplot accepts a large number of keywords to customize your plot. In the case of lattice, most of these are passed over to the function plotlattice, specific to lattices and Hamiltonians. In the case above, hide = () means \"don't hide any element of the plot\". See the qplot and plotlattice docstrings for details.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"tip: GLMakie vs CairoMakie\nGLMakie is optimized for interactive GPU-accelerated, rasterized plots. If you need to export to PDF for publications or in a Jupyter notebook, use CairoMakie instead, which in general renders non-interactive, but vector-based plots.","category":"page"},{"location":"manual/#SiteSelectors","page":"Manual","title":"SiteSelectors","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"A central concept in Quantica is that of a \"selector\". There are two types of selectors, SiteSelectors and HopSelectors. SiteSelectors are a set of directives or rules that can be applied to a lattice to select a subset of its sites. Similarly, HopSelectors can be used to select a number of site pairs, and will be used later to define tight-binding models and Hamiltonians.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Let us define a SiteSelector that picks all sites belonging to the :B sublattice of a given lattice within a circle of radius 10","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> s = siteselector(region = r -> norm(r) <= 10, sublats = :B)\nSiteSelector: a rule that defines a finite collection of sites in a lattice\n  Region            : Function\n  Sublattices       : B\n  Cells             : any","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Note that this selector is defined independently of the lattice. To apply it to a lattice lat we do lat[s], which results in a LatticeSlice","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> lat = LP.honeycomb(); lat[s]\nLatticeSlice{Float64,2,2} : collection of subcells for a 2D lattice in 2D space\n  Cells       : 363\n  Cell range  : ([-11, -11], [11, 11])\n  Total sites : 363","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The Cell range above are the corners of a bounding box in cell-index space that contains all unit cell indices with at least one selected site. Let's plot it","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> qplot(lat[s], hide = ())","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"<img src=\"../assets/latslice.png\" alt=\"A LatticeSlice\" width=\"400\" />","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"tip: Sites of a LatticeSlice\nCollect the site positions of a LatticeSlice with collect(sites(ls)). If you do sites(ls) instead, you will get a lazy iterator that can be used to iterate efficiently among site positions without allocating them in memory","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Apart from region and sublats we can also restrict the unitcells by their cell index. For example, to select all sites in unit cells within the above bounding box we can do","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> s´ = siteselector(cells = CartesianIndices((-11:11, -11:11)))\nSiteSelector: a rule that defines a finite collection of sites in a lattice\n  Region            : any\n  Sublattices       : any\n  Cells             : CartesianIndices((-11:11, -11:11))\n\njulia> lat[s´]\nLatticeSlice{Float64,2,2} : collection of subcells for a 2D lattice in 2D space\n  Cells       : 529\n  Cell range  : ([-11, -11], [11, 11])\n  Total sites : 1058","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We can also omit constructing the SiteSelector altogether by passing the keywords directly","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> ls = lat[cells = n -> 0 <= n[1] <= 2 && abs(n[2]) < 3, sublats = :A]\nLatticeSlice{Float64,2,2} : collection of subcells for a 2D lattice in 2D space\n  Cells       : 15\n  Cell range  : ([0, -2], [2, 2])\n  Total sites : 15","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Selectors are very expressive and powerful. Do check siteselector and hopselector docstrings for more details.","category":"page"},{"location":"manual/#Transforming-lattices","page":"Manual","title":"Transforming lattices","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"To transform a lattice, so that site positions r become f(r) use transform","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> f(r) = SA[0 1; 1 0] * r\nf (generic function with 1 method)\n\njulia> rotated_honeycomb = transform(LP.honeycomb(a0 = √3), f)\nLattice{Float64,2,2} : 2D lattice in 2D space\n  Bravais vectors : [[1.5, 0.866025], [1.5, -0.866025]]\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (1, 1) --> 2 total per unit cell\n\njulia> sites(rotated_honeycomb)\n2-element Vector{SVector{2, Float64}}:\n [-0.5, 0.0]\n [0.5, 0.0]","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"To translate a lattice by a displacement vector δr use translate ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> δr = SA[0, 1];\n\njulia> sites(translate(rotated_honeycomb, δr))\n2-element Vector{SVector{2, Float64}}:\n [-0.5, 1.0]\n [0.5, 1.0]","category":"page"},{"location":"manual/#Currying:-chaining-transformations-with-the-operator","page":"Manual","title":"Currying: chaining transformations with the |> operator","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Many functions in Quantica have a \"curried\" version that allows them to be chained together using the pipe operator |>.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"note: Definition of currying\nThe curried version of a function f(x1, x2...) is f´ = x1 -> f(x2...), so that the curried form of f(x1, x2...) is x2 |> f´(x2...), or f´(x2...)(x1). This gives the first argument x1 a privileged role. Users of object-oriented languages such as Python may find this use of the |> operator somewhat similar to the way the dot operator works there (i.e. x1.f(x2...)).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The last example above can then be written as","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> LP.honeycomb(a0 = √3) |> transform(f) |> translate(δr) |> sites\n2-element Vector{SVector{2, Float64}}:\n [-0.5, 1.0]\n [0.5, 1.0]","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"This type of curried syntax is supported by most Quantica functions, and will be used extensively in this manual.","category":"page"},{"location":"manual/#Extending-lattices-with-supercells","page":"Manual","title":"Extending lattices with supercells","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"As a periodic structure, the choice of the unitcell in an unbounded lattice is to an extent arbitrary. Given a lattice lat we can obtain another with a unit cell 3 times larger with supercell(lat, 3)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> lat = LP.honeycomb() |> supercell(3)\nLattice{Float64,2,2} : 2D lattice in 2D space\n  Bravais vectors : [[1.5, 2.598076], [-1.5, 2.598076]]\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (9, 9) --> 18 total per unit cell","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"More generally, given a lattice lat with Bravais matrix Amat = bravais_matrix(lat), we can obtain a larger one with Bravais matrix Amat´ = Amat * S, where S is a square matrix of integers. In the example above, S = SA[3 0; 0 3]. The columns of S represent the coordinates of the new Bravais vectors in the basis of the old Bravais vectors. A more general example with e.g. S = SA[3 1; -1 2] can be written either in terms of S or of its columns","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> supercell(lat, SA[3 1; -1 2]) == supercell(lat, (3, -1), (1, 2))\ntrue","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We can also use supercell to reduce the number of Bravais vectors, and hence the lattice dimensionality. To construct a new lattice with a single Bravais vector A₁´ = 3A₁ - A₂, just omit the second one","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> supercell(lat, (3, -1))\nLattice{Float64,2,1} : 1D lattice in 2D space\n  Bravais vectors : [[6.0, 5.196152]]\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (27, 27) --> 54 total per unit cell","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Its important to note that the lattice in the directions perpendicular to the new Bravais vector is bounded. With the syntax above, the new unitcell will be minimal. We may however define how many sites to include in the new unitcell by adding a SiteSelector directive to be applied in the non-periodic directions. For example, to create a 10-site wide, square-lattice nanoribbon we can do","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> LP.square() |> supercell((1,0), region = r -> 0 <= r[2] < 10)\nLattice{Float64,2,1} : 1D lattice in 2D space\n  Bravais vectors : [[1.0, 0.0]]\n  Sublattices     : 1\n    Names         : (:A,)\n    Sites         : (10,) --> 10 total per unit cell","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"tip: No need to build selectors explicitly\nAs discussed in the SiteSelector section, we don't build a siteselector(region = ...) object to then pass it to supercell: as shown above we instead pass the corresponding keywords directly to supercell, which takes care to build the selector internally.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Quantica.jl logo)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Quantica.jl is a Julia package for building generic tight-binding models and computing spectral and transport properties.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"manual.md\",\n    \"examples.md\",\n    \"api.md\",\n]\nDepth = 1","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"Quantica\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Quantica.jl requires Julia v1.9 or later. Some of its functionality, notably plotting, will become available only after using GLMakie, or some other plotting package from the Makie.jl family. Install GLMakie with","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"GLMakie\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, to begin using Quantica, just load it by doing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Quantica","category":"page"},{"location":"","page":"Home","title":"Home","text":"(and possibly also e.g. using GLMakie if you need to plot Quantica objects).","category":"page"},{"location":"#Asking-questions,-reporting-bugs","page":"Home","title":"Asking questions, reporting bugs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you encounter problems, please read the manual and examples, your question is probably answered there. You can also check the docstring of each Quantica function within the Julia REPL, by entering the function preceded by a ?, e.g. ?hamiltonian.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are still stuck, you may sometimes find me (@pablosanjose) at the Julia Slack or Julia Discourse.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you believe you found a bug in Quantica.jl, please don't hesitate to file a GitHub issue, preferably with detailed instructions to reproduce it. Pull requests are also welcome!","category":"page"}]
}
