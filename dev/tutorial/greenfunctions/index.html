<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GreenFunctions · Quantica.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://pablosanjose.github.io/Quantica.jl/tutorial/greenfunctions/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Quantica.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Quantica.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Quantica.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../tutorial/">Welcome</a></li><li><a class="tocitem" href="../glossary/">Glossary</a></li><li><a class="tocitem" href="../lattices/">Lattices</a></li><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../hamiltonians/">Hamiltonians</a></li><li class="is-active"><a class="tocitem" href>GreenFunctions</a><ul class="internal"><li><a class="tocitem" href="#A-simple-example"><span>A simple example</span></a></li><li><a class="tocitem" href="#GreenSolvers"><span>GreenSolvers</span></a></li><li><a class="tocitem" href="#Attaching-Contacts"><span>Attaching Contacts</span></a></li><li><a class="tocitem" href="#A-more-advanced-example"><span>A more advanced example</span></a></li></ul></li><li><a class="tocitem" href="../observables/">Observables</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>GreenFunctions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>GreenFunctions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pablosanjose/Quantica.jl/blob/master/docs/src/tutorial/greenfunctions.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GreenFunctions"><a class="docs-heading-anchor" href="#GreenFunctions">GreenFunctions</a><a id="GreenFunctions-1"></a><a class="docs-heading-anchor-permalink" href="#GreenFunctions" title="Permalink"></a></h1><p>Up to now we have seen how to define Lattices, Models, Hamiltonians and Bandstructures. Most problems require the computation of different physical observables for these objects, e.g. the local density of states or various transport coefficients. We reduce this general problem to the computation of the retarded Green function</p><p><span>$G^r_{ij}(\omega) = \langle i|(\omega-H-\Sigma(\omega))^{-1}|j\rangle$</span></p><p>where <code>i, j</code> are orbitals, <code>H</code> is the (possibly infinite) Hamiltonian matrix, and <code>Σ(ω)</code> is the self-energy coming from any coupling to other systems (typically described by their own <code>AbstractHamiltonian</code>).</p><p>We split the problem of computing <code>Gʳᵢⱼ(ω)</code> of a given <code>h::AbstractHamiltonian</code> into four steps:</p><ol><li>Attach self-energies to <code>h</code> using the command <code>oh = attach(h, args...)</code>. This produces a new object <code>oh::OpenHamiltonian</code> with a number of <code>Contacts</code>, numbered <code>1</code> to <code>N</code></li><li>Use <code>g = greenfunction(oh, solver)</code> to build a <code>g::GreenFunction</code> representing <code>Gʳ</code> (at arbitrary <code>ω</code> and <code>i,j</code>), where <code>oh::OpenHamiltonian</code> and <code>solver::GreenSolver</code> (see <code>GreenSolvers</code> below for available solvers)</li><li>Evaluate <code>gω = g(ω; params...)</code> at fixed energy <code>ω</code> and model parameters, which produces a <code>gω::GreenSolution</code></li><li>Slice <code>gω[sᵢ, sⱼ]</code> or <code>gω[sᵢ] == gω[sᵢ, sᵢ]</code> to obtain <code>Gʳᵢⱼ(ω)</code> as a flat matrix, where <code>sᵢ, sⱼ</code> are either site selectors over sites spanning orbitals <code>i,j</code>, or integers denoting contacts, <code>1</code> to <code>N</code>.</li></ol><div class="admonition is-success"><header class="admonition-header">GreenSlice vs. GreenSolution</header><div class="admonition-body"><p>The two last steps can be interchanged, by first obtaining a <code>gs::GreenSlice</code> with <code>gs = g[sᵢ, sⱼ]</code> and then obtaining the <code>Gʳᵢⱼ(ω)</code> matrix with <code>gs(ω; params...)</code>.</p></div></div><h2 id="A-simple-example"><a class="docs-heading-anchor" href="#A-simple-example">A simple example</a><a id="A-simple-example-1"></a><a class="docs-heading-anchor-permalink" href="#A-simple-example" title="Permalink"></a></h2><p>Here is a simple example of the Green function of a 1D lead with two sites per unit cell, a boundary at <code>cell = 0</code>, and with no attached self-energies for simplicity</p><pre><code class="language-julia hljs">julia&gt; hlead = LP.square() |&gt; supercell((1,0), region = r -&gt; 0 &lt;= r[2] &lt; 2) |&gt; hopping(1);

julia&gt; glead = greenfunction(hlead, GreenSolvers.Schur(boundary = 0))
GreenFunction{Float64,2,1}: Green function of a Hamiltonian{Float64,2,1}
  Solver          : AppliedSchurGreenSolver
  Contacts        : 0
  Contact solvers : ()
  Contact sizes   : ()
  Hamiltonian{Float64,2,1}: Hamiltonian on a 1D Lattice in 2D space
    Bloch harmonics  : 3
    Harmonic size    : 2 × 2
    Orbitals         : [1]
    Element type     : scalar (ComplexF64)
    Onsites          : 0
    Hoppings         : 6
    Coordination     : 3.0

julia&gt; gω = glead(0.2)  # we first fix energy to ω = 0.2
GreenSolution{Float64,2,1}: Green function at arbitrary positions, but at a fixed energy

julia&gt; gω[cells = 1:2]  # we now ask for the Green function between orbitals in the first two unit cells to the righht of the boundary
4×4 Matrix{ComplexF64}:
   0.1-0.858258im    -0.5-0.0582576im  -0.48-0.113394im   -0.2+0.846606im
  -0.5-0.0582576im    0.1-0.858258im    -0.2+0.846606im  -0.48-0.113394im
 -0.48-0.113394im    -0.2+0.846606im   0.104-0.869285im   0.44+0.282715im
  -0.2+0.846606im   -0.48-0.113394im    0.44+0.282715im  0.104-0.869285im</code></pre><p>Note that the result is a 4 x 4 matrix, because there are 2 orbitals (one per site) in each of the two unit cells. Note also that the Schur GreenSolver used here allows us to compute the Green function between distant cells with little overhead</p><pre><code class="language-julia hljs">julia&gt; @time gω[cells = 1:2];
  0.000067 seconds (70 allocations: 6.844 KiB)

julia&gt; @time gω[cells = (SA[10], SA[100000])];
  0.000098 seconds (229 allocations: 26.891 KiB)</code></pre><h2 id="GreenSolvers"><a class="docs-heading-anchor" href="#GreenSolvers">GreenSolvers</a><a id="GreenSolvers-1"></a><a class="docs-heading-anchor-permalink" href="#GreenSolvers" title="Permalink"></a></h2><p>The currently implemented <code>GreenSolver</code>s (abbreviated as <code>GS</code>) are the following</p><ul><li><p><code>GS.SparseLU()</code></p><p>For bounded (<code>L=0</code>) AbstractHamiltonians. Default for <code>L=0</code>.</p><p>Uses a sparse <code>LU</code> factorization to compute the <code>⟨i|(ω - H - Σ(ω))⁻¹|j⟩</code> inverse.</p></li></ul><ul><li><p><code>GS.KPM(order = 100, bandrange = missing, kernel = I)</code></p><p>For bounded (<code>L=0</code>) Hamiltonians, and restricted to sites belonging to contacts (see the section on Contacts).</p><p>It precomputes the Chebyshev momenta</p></li></ul><ul><li><p><code>GS.Schur(boundary = Inf)</code></p><p>For 1D (<code>L=1</code>) AbstractHamiltonians with only nearest-cell coupling. Default for <code>L=1</code>.</p><p>Uses a deflating Generalized Schur (QZ) factorization of the generalized eigenvalue problem to compute the unit-cell self energies. The Dyson equation then yields the Green function between arbitrary unit cells, which is further dressed using a T-matrix approach if the lead has any attached self-energy.</p></li></ul><div class="admonition is-info"><header class="admonition-header">GS.Bands</header><div class="admonition-body"><p>In the near future we will also have <code>GS.Bands</code> as a general solver in lattice dimensions <code>L ∈ [1,3]</code>.</p></div></div><h2 id="Attaching-Contacts"><a class="docs-heading-anchor" href="#Attaching-Contacts">Attaching Contacts</a><a id="Attaching-Contacts-1"></a><a class="docs-heading-anchor-permalink" href="#Attaching-Contacts" title="Permalink"></a></h2><p>A self energy <code>Σ(ω)</code> acting of a finite set of sites of <code>h</code> (i.e. on a <code>LatticeSlice</code> of <code>lat = lattice(h)</code>) can be incorporated using the <code>attach</code> command. This defines a new Contact in <code>h</code>. The general syntax is <code>oh = attach(h, args...; sites...)</code>, where the <code>sites</code> directives define the Contact <code>LatticeSlice</code> (<code>lat[siteselector(; sites...)]</code>), and <code>args</code> can take a number of forms.</p><p>The supported <code>attach</code> forms are the following</p><ul><li><p><strong>Generic self-energy</strong></p><p><code>attach(h, gs::GreenSlice, coupling::AbstractModel; sites...)</code></p><p>This is the generic form of <code>attach</code>, which couples some sites <code>i</code> of a <code>g::Greenfunction</code> (defined by the slice <code>gs = g[i]</code>), to <code>sites</code> of <code>h</code> using a <code>coupling</code> model. This results in a self-energy <code>Σ(ω) = V´⋅gs(ω)⋅V</code> on <code>h</code> <code>sites</code>, where <code>V</code> and <code>V´</code> are couplings matrices given by <code>coupling</code>.</p></li></ul><ul><li><p><strong>Dummy self-energy</strong></p><p><code>attach(h, nothing; sites...)</code></p><p>This form merely defines a new contact on the specified <code>sites</code>, but  adds no actual self-energy to it. It is meant as a way to refer to some sites of interest using the <code>g[i::Integer]</code> slicing syntax for <code>GreenFunction</code>s, where <code>i</code> is the contact index.</p></li></ul><ul><li><p><strong>Model self-energy</strong></p><p><code>attach(h, model::AbstractModel; sites...)</code></p><p>This form defines a self-energy <code>Σᵢⱼ(ω)</code> in terms of <code>model</code>, which must be composed purely of parametric terms (<code>@onsite</code> and <code>@hopping</code>) that have <code>ω</code> as first argument, as in e.g. <code>@onsite((ω, r) -&gt; Σᵢᵢ(ω, r))</code> or <code>@hopping((ω, r, dr) -&gt; Σᵢⱼ(ω, r, dr))</code>. This is a modellistic approach, wherein the self-energy is not computed from the properties of another <code>AbstractHamiltonian</code>, but rather has an arbitrary form defined by the user.</p></li></ul><ul><li><p><strong>Matched lead self-energy</strong></p><p><code>attach(h, glead::GreenFunction; reverse = false, transform = identity, sites...)</code></p><p>Here <code>glead</code> is a GreenFunction of a 1D lead, possibly with a boundary.</p><p>With this syntax <code>sites</code> must select a number of sites in <code>h</code> whose position match (after applying <code>transform</code> to them and modulo an arbitrary displacement) the sites in the unit cell of <code>glead</code>. Then, the coupling between these and the first unit cell of <code>glead</code> on the positive side of the boundary will be the same as between <code>glead</code> unitcells, i.e. <code>V = hlead[(1,)]</code>, where <code>hlead = hamiltonian(glead)</code>.</p><p>If <code>reverse == true</code>, the lead is reversed before being attached, so that h is coupled through <code>V = hlead[(-1,)]</code> to the first unitcell on the negative side of the boundary. If there is no boundary, the <code>cell = 0</code> unitcell of the <code>glead</code> is used.</p></li></ul><ul><li><p><strong>Generic lead self-energy</strong></p><p><code>attach(h, glead::GreenFunction, model::AbstractModel; reverse = false, transform = identity, sites...)</code></p><p>The same as above, but without any restriction on <code>sites</code>. The coupling between these and the first unit cell of <code>glead</code> (transformed by <code>transform</code>) is constructed using <code>model::TightbindingModel</code>. The &quot;first unit cell&quot; is defined as above.</p></li></ul><h2 id="A-more-advanced-example"><a class="docs-heading-anchor" href="#A-more-advanced-example">A more advanced example</a><a id="A-more-advanced-example-1"></a><a class="docs-heading-anchor-permalink" href="#A-more-advanced-example" title="Permalink"></a></h2><p>Let us define the classical example of a multiterminal mesoscopic junction. We choose a square lattice, and a circular central region of radius <code>10</code>, with four leads of width <code>5</code> coupled to it at right angles.</p><p>We first define a single lead <code>Greenfunction</code> and the central Hamiltonian</p><pre><code class="language-julia hljs">julia&gt; glead = LP.square() |&gt; hopping(1) |&gt; supercell((1, 0), region = r -&gt; abs(r[2]) &lt;= 5/2) |&gt; greenfunction(GS.Schur(boundary = 0));

julia&gt; hcentral = LP.square() |&gt; hopping(1) |&gt; supercell(region = RP.circle(10) | RP.rectangle((22, 5)) | RP.rectangle((5, 22)))</code></pre><p>The two rectangles overlayed on the circle above create the stubs where the leads will be attached:</p><img src="../../assets/central.png" alt="Central region with stubs" width="250" class="center"/><p>We now attach <code>glead</code> four times using the <code>Matched lead</code> syntax</p><pre><code class="language-julia hljs">julia&gt; Rot = r -&gt; SA[0 -1; 1 0] * r;  # 90º rotation function

julia&gt; gcentral = hcentral |&gt;
    attach(glead, region = r -&gt; r[1] ==  11) |&gt;
    attach(glead, region = r -&gt; r[1] == -11, reverse = true) |&gt;
    attach(glead, region = r -&gt; r[2] ==  11, transform = Rot) |&gt;
    attach(glead, region = r -&gt; r[2] == -11, reverse = true, transform = Rot) |&gt;
    greenfunction
OpenHamiltonian{Float64,2,0}: Hamiltonian with a set of open contacts
  Number of contacts : 4
  Contact solvers    : (:SelfEnergySchurSolver, :SelfEnergySchurSolver, :SelfEnergySchurSolver, :SelfEnergySchurSolver)
  Hamiltonian{Float64,2,0}: Hamiltonian on a 0D Lattice in 2D space
    Bloch harmonics  : 1
    Harmonic size    : 353 × 353
    Orbitals         : [1]
    Element type     : scalar (ComplexF64)
    Onsites          : 0
    Hoppings         : 1320
    Coordination     : 3.73938

julia&gt; qplot(g, children = (; selector = siteselector(; cells = 1:5), sitecolor = :blue))</code></pre><img src="../../assets/multiterminal.png" alt="Multiterminal system" width="300" class="center"/><p>Note that since we did not specify the <code>solver</code> in <code>greenfunction</code>, the <code>L=0</code> default <code>GS.SparseLU()</code> was taken.</p><div class="admonition is-success"><header class="admonition-header">The GreenFunction &lt;-&gt; AbstractHamiltonian relation</header><div class="admonition-body"><p>Its important un appreciate that a <code>g::GreenFunction</code> represents the retarded Green function between sites in a given <code>AbstractHamiltonian</code>, but not on sites of the coupled <code>AbstractHamiltonians</code> of its attached self-energies. Therefore, <code>gcentral</code> above cannot yield observables in the leads (blue sites above), only on the red sites. To obtain observables in a given lead, its <code>GreenFunction</code> must be constructed, with an attached self-energy coming from the central region plus the other three leads.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../hamiltonians/">« Hamiltonians</a><a class="docs-footer-nextpage" href="../observables/">Observables »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 2 July 2023 16:21">Sunday 2 July 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
