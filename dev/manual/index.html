<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · Quantica.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://pablosanjose.github.io/Quantica.jl/manual/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Quantica.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Quantica.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Quantica.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Glossary"><span>Glossary</span></a></li><li><a class="tocitem" href="#Lattices"><span>Lattices</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#Hamiltonians"><span>Hamiltonians</span></a></li><li><a class="tocitem" href="#Bandstructures"><span>Bandstructures</span></a></li><li><a class="tocitem" href="#GreenFunctions"><span>GreenFunctions</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pablosanjose/Quantica.jl/blob/master/docs/src/manual.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><p>Welcome to the Quantica.jl manual!</p><p>Here you will learn how to use Quantica.jl to build and compute properties of tight-binding models. This includes</p><ul><li>Defining general lattices in arbitrary dimensions</li><li>Defining generic tight-binding models with arbitrary parameter dependences</li><li>Building Hamiltonians of mono or multiorbital systems by combining lattices and models</li><li>Computing bandstructures of Hamiltonians using a range of solvers</li><li>Creating &quot;open Hamiltonians&quot; by attaching self-energies of different types to Hamiltonians, representing e.g. leads</li><li>Computing Green functions of Hamiltonians or open Hamiltonians using a range of solvers</li><li>Computing observables from Green functions, such as spectral densities, current densities, local and nonlocal conductances, Josephson currents, critical currents, transmission probabilities, etc.</li></ul><div class="admonition is-success"><header class="admonition-header">Check the docstrings</header><div class="admonition-body"><p>Full usage instructions on all Quantica functions can be found <a href="../api/#api">here</a> or within the Julia REPL by querying their docstrings. For example, to obtain details on the <code>hamiltonian</code> function or on the available <code>LatticePresets</code>, just type <code>?hamiltonian</code> or <code>?LatticePresets</code>.</p></div></div><h2 id="Glossary"><a class="docs-heading-anchor" href="#Glossary">Glossary</a><a id="Glossary-1"></a><a class="docs-heading-anchor-permalink" href="#Glossary" title="Permalink"></a></h2><ul><li><code>Sublat</code>: a sublattice, representing a number of identical sites within the unit cell of a bounded or unbounded lattice. Each site has a position in an <code>E</code>-dimensional space (<code>E</code> is called the embedding dimension). All sites in a given <code>Sublat</code> will be able to hold the same number of orbitals, and they can be thought of as identical atoms. Each <code>Sublat</code> in a <code>Lattice</code> can be given a unique name, by default <code>:A</code>, <code>:B</code>, etc.</li><li><code>Lattice</code>: a collection of <code>Sublat</code>s plus a collection of <code>L</code> Bravais vectors that define the periodicity of the lattice. A bounded lattice has <code>L=0</code>, and no Bravais vectors. A <code>Lattice</code> with <code>L &gt; 0</code> can be understood as a periodic (unbounded) set of unit cells, each containing a set of sites, each of which belongs to a different sublattice.</li><li><code>SiteSelector</code>: a rule that defines a subset of sites in a <code>Lattice</code></li><li><code>HopSelector</code>: a rule that defines a subset of site pairs in a <code>Lattice</code></li><li><code>LatticeSlice</code>: a finite subset of sites in a <code>Lattice</code>, defined by their cell index (an <code>L</code>-dimensional integer vector) and their site index (an integer) within the unit cell. Can be obtained by combining a <code>Lattice</code> and a (bounded) <code>SiteSelector</code>.</li><li><code>AbstractModel</code>: either a <code>TightBindingModel</code> or a <code>ParametricModel</code><ul><li><code>TightBindingModel</code>: a set of <code>HoppingTerm</code>s and <code>OnsiteTerm</code>s</li><li><code>OnsiteTerm</code>: a rule that, applied to a single site, produces a scalar or a (square) matrix that represents the intra-site Hamiltonian elements (single or multi-orbital)</li><li><code>HoppingTerm</code>: a rule that, applied to a pair of sites, produces a scalar or a matrix that represents the inter-site Hamiltonian elements (single or multi-orbital)</li><li><code>ParametricOnsiteTerm</code> and <code>ParametricHoppingTerm</code>: like the above, but dependent on some parameters that can be adjusted.</li></ul></li><li><code>AbstractHamiltonian</code>: either a <code>Hamiltonian</code> or a <code>ParametricHamiltonian</code><ul><li><code>Hamiltonian</code>: a <code>Lattice</code> combined with a <code>TightBindingModel</code>, with a specification of the number of orbitals in each <code>Sublat</code> in the <code>Lattice</code>. It represents a tight-binding Hamiltonian sharing the same periodicity as the <code>Lattice</code> (it is translationally invariant under Bravais vector shifts).</li><li><code>ParametricHamiltonian</code>: like the above, but using a <code>ParametricModel</code>, which makes it dependent on a set of parameters.</li></ul></li><li><code>SelfEnergy</code>: an operator defined to act on a <code>LatticeSlice</code> of an <code>AbstractHamiltonian</code>.</li><li><code>OpenHamiltonian</code>: an <code>AbstractHamiltonian</code> combined with a set of <code>SelfEnergies</code></li><li><code>GreenFunction</code>: an <code>OpenHamiltonian</code> combined with a <code>GreenSolver</code>, which is an algorithm that can compute the Green function at any energy between any subset of sites of the underlying lattice.<ul><li><code>GreenSlice</code>: a <code>GreenFunction</code> evaluated on a specific set of sites, but at an unspecified energy</li><li><code>GreenSolution</code>: a <code>GreenFunction</code> evaluated at a specific energy, but on an unspecified set of sites</li></ul></li></ul><h2 id="Lattices"><a class="docs-heading-anchor" href="#Lattices">Lattices</a><a id="Lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Lattices" title="Permalink"></a></h2><h3 id="Constructing-a-Lattice-from-scratch"><a class="docs-heading-anchor" href="#Constructing-a-Lattice-from-scratch">Constructing a Lattice from scratch</a><a id="Constructing-a-Lattice-from-scratch-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-a-Lattice-from-scratch" title="Permalink"></a></h3><p>Consider a lattice like graphene&#39;s. It has two sublattices, A and B, forming a honeycomb pattern in space. The position of site A inside the unitcell is <code>[0, -a0/√3]</code>, with site B at <code>[0, a0/√3]</code>. The <code>i=1,2</code> Bravais vectors are <code>Aᵢ = [± cos(π/3), sin(π/3)]</code>. If we set the lattice constant to <code>a0 = 1</code>, one way to build this lattice in Quantica would be</p><pre><code class="language-julia-repl hljs">julia&gt; A1, A2 = (cos(π/3), sin(π/3)), (-cos(π/3), sin(π/3));

julia&gt; sA = sublat((0, -1/√3), name = :A);

julia&gt; sB = sublat((0,  1/√3), name = :B);

julia&gt; lattice(sA, sB, bravais = (A1, A2))
Lattice{Float64,2,2} : 2D lattice in 2D space
  Bravais vectors : [[0.5, 0.866025], [-0.5, 0.866025]]
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (1, 1) --&gt; 2 total per unit cell</code></pre><div class="admonition is-success"><header class="admonition-header">Tuple, SVector and SMatrix</header><div class="admonition-body"><p>Note that we have used <code>Tuple</code>s, such as <code>(0, 1/√3)</code> instead of <code>Vector</code>s, like <code>[0, 1/√3]</code>. In Julia small-length <code>Tuple</code>s are much more efficient as containers than <code>Vector</code>s, since their length is known and fixed at compile time. Static vectors (<code>SVector</code>) and matrices (<code>SMatrix</code>) are also available to Quantica, which are just as efficient as <code>Tuple</code>s. They be entered as e.g. <code>SA[0, 1/√3]</code> and <code>SA[1 0; 0 1]</code>, respectively. For efficiency, always use <code>Tuple</code>, <code>SVector</code> and <code>SMatrix</code> in Quantica where possible.</p></div></div><p>If we don&#39;t plan to address the two sublattices individually, we could also fuse them into one, like</p><pre><code class="language-julia-repl hljs">julia&gt; lat = lattice(sublat((0, 1/√3), (0, -1/√3)), bravais = (A1, A2))
Lattice{Float64,2,2} : 2D lattice in 2D space
  Bravais vectors : [[0.5, 0.866025], [-0.5, 0.866025]]
  Sublattices     : 1
    Names         : (:A,)
    Sites         : (2,) --&gt; 2 total per unit cell</code></pre><p>This lattice has type <code>Lattice{T,E,L}</code>, with <code>T = Float64</code> the numeric type of position coordinates, <code>E = 2</code> the dimension of embedding space, and <code>L = 2</code> the number of Bravais vectors (i.e. the lattice dimension). Both <code>T</code> and <code>E</code>, and even the <code>Sublat</code> names can be overridden when creating a lattice. One can also provide the Bravais vectors as a matrix, with each <code>Aᵢ</code> as a column</p><pre><code class="language-julia-repl hljs">julia&gt; Amat = SA[-cos(π/3) cos(π/3); sin(π/3) sin(π/3)];

julia&gt; lat´ = lattice(sA, sB, bravais = Amat, type = Float32, dim = 3, names = (:C, :D))
Lattice{Float32,3,2} : 2D lattice in 3D space
  Bravais vectors : Vector{Float32}[[-0.5, 0.866025, 0.0], [0.5, 0.866025, 0.0]]
  Sublattices     : 2
    Names         : (:C, :D)
    Sites         : (1, 1) --&gt; 2 total per unit cell</code></pre><div class="admonition is-success"><header class="admonition-header">Advanced: static `dim` with `Val`</header><div class="admonition-body"><p>For the <code>dim</code> keyword above we can alternatively use <code>dim = Val(3)</code>, which is slightly more efficient, because the value is encoded as a type. This is a Julia thing (the concept of type stability), and can be ignored upon a first contact with Quantica.</p></div></div><p>One can also <em>convert</em> an existing lattice like the above to have a different type, embedding dimension, bravais vectors, <code>Sublat</code> names with</p><pre><code class="language-julia-repl hljs">julia&gt; lat´´ = lattice(lat´, bravais = √3 * Amat, type = Float16, dim = 2, names = (:Boron, :Nitrogen))
Lattice{Float16,2,2} : 2D lattice in 2D space
  Bravais vectors : Vector{Float16}[[-0.866, 1.5], [0.866, 1.5]]
  Sublattices     : 2
    Names         : (:Boron, :Nitrogen)
    Sites         : (1, 1) --&gt; 2 total per unit cell</code></pre><p>A list of site positions in a lattice <code>lat</code> can be obtained with <code>sites(lat)</code>, or <code>sites(lat, sublat)</code> to restrict to a specific sublattice</p><pre><code class="language-julia-repl hljs">julia&gt; sites(lat´´)
2-element Vector{SVector{2, Float16}}:
 [0.0, -0.5]
 [0.0, 0.5]

julia&gt; sites(lat´´, :Nitrogen)
1-element view(::Vector{SVector{2, Float16}}, 2:2) with eltype SVector{2, Float16}:
 [0.0, 0.5]</code></pre><p>Similarly, the Bravais matrix of a <code>lat</code> can be obtained with <code>bravais_matrix(lat)</code>.</p><h3 id="Lattice-presets"><a class="docs-heading-anchor" href="#Lattice-presets">Lattice presets</a><a id="Lattice-presets-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-presets" title="Permalink"></a></h3><p>We can also use a collection of pre-built lattices in different dimensions, which are defined in the submodule <code>LatticePresets</code>, also called <code>LP</code>. These presets currently include</p><ul><li><code>LP.linear</code>: linear 1D lattice</li><li><code>LP.square</code>: square 2D lattice</li><li><code>LP.honeycomb</code>: square 2D lattice</li><li><code>LP.cubic</code>: cubic 3D lattice</li><li><code>LP.bcc</code>: body-centered cubic 3D lattice</li><li><code>LP.fcc</code>: face-centered cubic 3D lattice</li></ul><p>One can modify any of these presets by passing a <code>bravais</code>, <code>type</code>, <code>dim</code>, <code>names</code> and also a new keyword <code>a0</code> for the lattice constant. The last lattice above can thus be also obtained with</p><pre><code class="language-julia-repl hljs">julia&gt; lat´´ = LP.honeycomb(a0 = √3, type = Float16, names = (:Boron, :Nitrogen))
Lattice{Float16,2,2} : 2D lattice in 2D space
  Bravais vectors : Vector{Float16}[[0.866, 1.5], [-0.866, 1.5]]
  Sublattices     : 2
    Names         : (:Boron, :Nitrogen)
    Sites         : (1, 1) --&gt; 2 total per unit cell</code></pre><h3 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h3><p>To produce an interactive visualization of <code>Lattice</code>s or other Quantica object you need to load GLMakie, CairoMakie or some other plotting backend from the Makie repository (i.e. do <code>using GLMakie</code>, see also Installation). Then, a number of new plotting functions will become available. The main one is <code>qplot</code>. A Lattice is represented, by default, as the sites in a unitcell plus the Bravais vectors.</p><pre><code class="language-julia hljs">julia&gt; using GLMakie

julia&gt; lat = LP.honeycomb()

julia&gt; qplot(lat, hide = ())</code></pre><img src="../assets/honeycomb_lat.png" alt="Honeycomb lattice" width="250" class="center"/><p><code>qplot</code> accepts a large number of keywords to customize your plot. In the case of lattice, most of these are passed over to the function <code>plotlattice</code>, specific to lattices and Hamiltonians. In the case above, <code>hide = ()</code> means &quot;don&#39;t hide any element of the plot&quot;. See the <code>qplot</code> and <code>plotlattice</code> docstrings for details.</p><div class="admonition is-success"><header class="admonition-header">GLMakie vs CairoMakie</header><div class="admonition-body"><p>GLMakie is optimized for interactive GPU-accelerated, rasterized plots. If you need to export to PDF for publications or in a Jupyter notebook, use CairoMakie instead, which in general renders non-interactive, but vector-based plots.</p></div></div><h3 id="SiteSelectors"><a class="docs-heading-anchor" href="#SiteSelectors">SiteSelectors</a><a id="SiteSelectors-1"></a><a class="docs-heading-anchor-permalink" href="#SiteSelectors" title="Permalink"></a></h3><p>A central concept in Quantica is that of a &quot;selector&quot;. There are two types of selectors, <code>SiteSelector</code>s and <code>HopSelectors</code>. <code>SiteSelector</code>s are a set of directives or rules that define a subset of its sites. The rules are defined through three keywords</p><ul><li><code>region</code>: a boolean function of allowed site positions <code>r</code>.</li><li><code>sublats</code>: allowed sublattices of selected sites</li><li><code>cells</code>: allowed cell indices of selected sites</li></ul><p>Similarly, <code>HopSelector</code>s can be used to select a number of site pairs, and will be used later to define hoppings in tight-binding models (see further below).</p><p>As an example, let us define a <code>SiteSelector</code> that picks all sites belonging to the <code>:B</code> sublattice of a given lattice within a circle of radius <code>10</code></p><pre><code class="language-julia-repl hljs">julia&gt; s = siteselector(region = r -&gt; norm(r) &lt;= 10, sublats = :B)
SiteSelector: a rule that defines a finite collection of sites in a lattice
  Region            : Function
  Sublattices       : B
  Cells             : any</code></pre><p>Note that this selector is defined independently of the lattice. To apply it to a lattice <code>lat</code> we do <code>lat[s]</code>, which results in a <code>LatticeSlice</code> (i.e. a finite portion, or slice, of <code>lat</code>)</p><pre><code class="language-julia-repl hljs">julia&gt; lat = LP.honeycomb(); lat[s]
LatticeSlice{Float64,2,2} : collection of subcells for a 2D lattice in 2D space
  Cells       : 363
  Cell range  : ([-11, -11], [11, 11])
  Total sites : 363</code></pre><p>The <code>Cell range</code> above are the corners of a bounding box <em>in cell-index space</em> that contains all unit cell indices with at least one selected site.</p><p>Let&#39;s plot it</p><pre><code class="language-julia hljs">julia&gt; qplot(lat[s], hide = ())</code></pre><img src="../assets/latslice.png" alt="A LatticeSlice" width="400" class="center"/><div class="admonition is-success"><header class="admonition-header">qplot selector</header><div class="admonition-body"><p>The above <code>qplot(lat[s])</code> can also be written as <code>qplot(lat, selector = s)</code>, which will be useful when plotting <code>AbstractHamiltonians</code>.</p></div></div><div class="admonition is-success"><header class="admonition-header">Sites of a LatticeSlice</header><div class="admonition-body"><p>Collect the site positions of a <code>LatticeSlice</code> into a vector with <code>collect(sites(ls))</code>. If you do <code>sites(ls)</code> instead, you will get a lazy generator that can be used to iterate efficiently among site positions without allocating them in memory.</p></div></div><p>Apart from <code>region</code> and <code>sublats</code> we can also restrict the unitcells by their cell index. For example, to select all sites in unit cells within the above bounding box we can do</p><pre><code class="language-julia-repl hljs">julia&gt; s´ = siteselector(cells = CartesianIndices((-11:11, -11:11)))
SiteSelector: a rule that defines a finite collection of sites in a lattice
  Region            : any
  Sublattices       : any
  Cells             : CartesianIndices((-11:11, -11:11))

julia&gt; lat[s´]
LatticeSlice{Float64,2,2} : collection of subcells for a 2D lattice in 2D space
  Cells       : 529
  Cell range  : ([-11, -11], [11, 11])
  Total sites : 1058</code></pre><p>We can often omit constructing the <code>SiteSelector</code> altogether by using the keywords directly</p><pre><code class="language-julia-repl hljs">julia&gt; ls = lat[cells = n -&gt; 0 &lt;= n[1] &lt;= 2 &amp;&amp; abs(n[2]) &lt; 3, sublats = :A]
LatticeSlice{Float64,2,2} : collection of subcells for a 2D lattice in 2D space
  Cells       : 15
  Cell range  : ([0, -2], [2, 2])
  Total sites : 15</code></pre><p>Selectors are very expressive and powerful. Do check <code>siteselector</code> and <code>hopselector</code> docstrings for more details.</p><h3 id="Transforming-lattices"><a class="docs-heading-anchor" href="#Transforming-lattices">Transforming lattices</a><a id="Transforming-lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Transforming-lattices" title="Permalink"></a></h3><p>We can transform lattices using <code>transform</code>, <code>translate</code> and <code>supercell</code>.</p><p>To transform a lattice, so that site positions <code>r</code> become <code>f(r)</code> use <code>transform</code></p><pre><code class="language-julia-repl hljs">julia&gt; f(r) = SA[0 1; 1 0] * r
f (generic function with 1 method)

julia&gt; rotated_honeycomb = transform(LP.honeycomb(a0 = √3), f)
Lattice{Float64,2,2} : 2D lattice in 2D space
  Bravais vectors : [[1.5, 0.866025], [1.5, -0.866025]]
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (1, 1) --&gt; 2 total per unit cell

julia&gt; sites(rotated_honeycomb)
2-element Vector{SVector{2, Float64}}:
 [-0.5, 0.0]
 [0.5, 0.0]</code></pre><p>To translate a lattice by a displacement vector <code>δr</code> use <code>translate</code></p><pre><code class="language-julia-repl hljs">julia&gt; δr = SA[0, 1];

julia&gt; sites(translate(rotated_honeycomb, δr))
2-element Vector{SVector{2, Float64}}:
 [-0.5, 1.0]
 [0.5, 1.0]</code></pre><p>As a periodic structure, the choice of the unitcell in an unbounded lattice is to an extent arbitrary. Given a lattice <code>lat</code> we can obtain another with a unit cell 3 times larger with <code>supercell(lat, 3)</code></p><pre><code class="language-julia-repl hljs">julia&gt; lat = supercell(LP.honeycomb(), 3)
Lattice{Float64,2,2} : 2D lattice in 2D space
  Bravais vectors : [[1.5, 2.598076], [-1.5, 2.598076]]
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (9, 9) --&gt; 18 total per unit cell</code></pre><p>More generally, given a lattice <code>lat</code> with Bravais matrix <code>Amat = bravais_matrix(lat)</code>, we can obtain a larger one with Bravais matrix <code>Amat´ = Amat * S</code>, where <code>S</code> is a square matrix of integers. In the example above, <code>S = SA[3 0; 0 3]</code>. The columns of <code>S</code> represent the coordinates of the new Bravais vectors in the basis of the old Bravais vectors. A more general example with e.g. <code>S = SA[3 1; -1 2]</code> can be written either in terms of <code>S</code> or of its columns</p><pre><code class="language-julia-repl hljs">julia&gt; supercell(lat, SA[3 1; -1 2]) == supercell(lat, (3, -1), (1, 2))
true</code></pre><p>We can also use <code>supercell</code> to reduce the number of Bravais vectors, and hence the lattice dimensionality. To construct a new lattice with a single Bravais vector <code>A₁´ = 3A₁ - A₂</code>, just omit the second one</p><pre><code class="language-julia-repl hljs">julia&gt; supercell(lat, (3, -1))
Lattice{Float64,2,1} : 1D lattice in 2D space
  Bravais vectors : [[6.0, 5.196152]]
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (27, 27) --&gt; 54 total per unit cell</code></pre><p>Its important to note that the lattice will be bounded along directions different from the specified Bravais vectors. With the syntax above, the new unitcell will be minimal. We may however define how many sites to include in the new unitcell by adding a <code>SiteSelector</code> directive to be applied in the non-periodic directions. For example, to create a 10 * a0 wide, honeycomb nanoribbon we can do</p><pre><code class="language-julia-repl hljs">julia&gt; lat = supercell(LP.honeycomb(), (1,-1), region = r -&gt; -5 &lt;= r[2] &lt;= 5)
Lattice{Float64,2,1} : 1D lattice in 2D space
  Bravais vectors : [[1.0, 0.0]]
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (12, 12) --&gt; 24 total per unit cell

julia&gt; qplot(lat[cells = -7:7])</code></pre><img src="../assets/nanoribbon_lat.png" alt="Honeycomb nanoribbon" height="150" class="center"/><div class="admonition is-success"><header class="admonition-header">No need to build selectors explicitly</header><div class="admonition-body"><p>Note that we we didn&#39;t build a <code>siteselector(region = ...)</code> object to pass it to <code>supercell</code>. Instead, as shown above, we passed the corresponding keywords directly to <code>supercell</code>, which then takes care to build the selector internally.</p></div></div><h3 id="Currying:-chaining-transformations-with-the-operator"><a class="docs-heading-anchor" href="#Currying:-chaining-transformations-with-the-operator">Currying: chaining transformations with the <code>|&gt;</code> operator</a><a id="Currying:-chaining-transformations-with-the-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Currying:-chaining-transformations-with-the-operator" title="Permalink"></a></h3><p>Many functions in Quantica have a &quot;curried&quot; version that allows them to be chained together using the pipe operator <code>|&gt;</code>.</p><div class="admonition is-info"><header class="admonition-header">Definition of currying</header><div class="admonition-body"><p>The curried version of a function <code>f(x1, x2...)</code> is <code>f´ = x1 -&gt; f(x2...)</code>, so that the curried form of <code>f(x1, x2...)</code> is <code>x2 |&gt; f´(x2...)</code>, or <code>f´(x2...)(x1)</code>. This gives the first argument <code>x1</code> a privileged role. Users of object-oriented languages such as Python may find this use of the <code>|&gt;</code> operator somewhat similar to the way the dot operator works there (i.e. <code>x1.f(x2...)</code>).</p></div></div><p>The last example above can then be written as</p><pre><code class="language-julia-repl hljs">julia&gt; LP.honeycomb(a0 = √3) |&gt; transform(f) |&gt; translate(δr) |&gt; sites
2-element Vector{SVector{2, Float64}}:
 [-0.5, 1.0]
 [0.5, 1.0]</code></pre><p>This type of curried syntax is natural in Quantica, and will be used extensively in this manual.</p><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><p>We now will see how to build a generic single-particle tight-binding model, with Hamiltonian</p><p><span>$H = \sum_{i\alpha j\beta} c_{i\alpha}^\dagger V_{\alpha\beta}(r_i, r_j)c_{j\alpha}$</span></p><p>Here, <code>α,β</code> are orbital indices in each site, <code>i,j</code> are site indices, and <code>rᵢ, rⱼ</code> are site positions. In Quantica we would write the above model as</p><pre><code class="language-julia-repl hljs">julia&gt; model = onsite(r -&gt; V(r, r)) + hopping((r, dr) -&gt; V(r-dr/2, r+dr/2))
TightbindingModel: model with 2 terms
  OnsiteTerm{Function}:
    Region            : any
    Sublattices       : any
    Cells             : any
    Coefficient       : 1
  HoppingTerm{Function}:
    Region            : any
    Sublattice pairs  : any
    Cell distances    : any
    Hopping range     : Neighbors(1)
    Reverse hops      : false
    Coefficient       : 1</code></pre><p>where <code>V(rᵢ, rⱼ)</code> is a function that returns a matrix <span>$V_{\alpha\beta}(r_i, r_j)$</span> (preferably an <code>SMatrix</code>) of the required orbital dimensionality.</p><p>Note that when writing models we distinguish between onsite (<code>rᵢ=rⱼ</code>) and hopping (<code>rᵢ≠rⱼ</code>) terms. For the former, <code>r</code> is the site position. For the latter we use a bond-center and bond-distance <code>(r, dr)</code> parametrization of <code>V</code>, so that <code>r₁, r₂ = r ∓ dr/2</code></p><p>If the onsite  and hopping amplitudes do not depend on position, we can simply input them as constants</p><pre><code class="language-julia-repl hljs">julia&gt; model = onsite(1) - 2*hopping(1)
TightbindingModel: model with 2 terms
  OnsiteTerm{Int64}:
    Region            : any
    Sublattices       : any
    Cells             : any
    Coefficient       : 1
  HoppingTerm{Int64}:
    Region            : any
    Sublattice pairs  : any
    Cell distances    : any
    Hopping range     : Neighbors(1)
    Reverse hops      : false
    Coefficient       : -2</code></pre><div class="admonition is-success"><header class="admonition-header">Model term algebra</header><div class="admonition-body"><p>Note that we can combine model terms as in the above example by summing and subtracting them, and using constant coefficients.</p></div></div><h3 id="HopSelectors"><a class="docs-heading-anchor" href="#HopSelectors">HopSelectors</a><a id="HopSelectors-1"></a><a class="docs-heading-anchor-permalink" href="#HopSelectors" title="Permalink"></a></h3><p>By default <code>onsite</code> terms apply to any site in a Lattice, and <code>hopping</code> terms apply to any pair of sites within nearest-neighbor distance (see the <code>Hopping range: Neighbors(1)</code> above).</p><p>We can change this default by specifying a <code>SiteSelector</code> or <code>HopSelector</code> for each term. <code>SiteSelector</code>s where already introduced to create and slice Lattices. <code>HopSelectors</code> are very similar, but support slightly different keywords:</p><ul><li><code>region</code>: to restrict according to bond center <code>r</code> and bond vector <code>dr</code></li><li><code>sublats</code>: to restrict source and target sublattices</li><li><code>dcells</code>: to restrict the distance in cell index</li><li><code>range</code>: to restrict the distance in real space</li></ul><p>As an example, a <code>HopSelector</code> that selects any two sites at a distance between <code>1.0</code> and the second-nearest neighbor distance, with the first belonging to sublattice <code>:B</code> and the second to sublattice <code>:A</code>, and their mean position inside a unit circle</p><pre><code class="language-julia-repl hljs">julia&gt; hs = hopselector(range = (1.0, neighbors(2)), sublats = :B =&gt; :A, region = (r, dr) -&gt; norm(r) &lt; 1)
HopSelector: a rule that defines a finite collection of hops between sites in a lattice
  Region            : Function
  Sublattice pairs  : :B =&gt; :A
  Cell distances    : any
  Hopping range     : (1.0, Neighbors(2))
  Reverse hops      : false

julia&gt; model = plusadjoint(hopping(1, hs)) - 2*onsite(1, sublats = :B)
TightbindingModel: model with 3 terms
  HoppingTerm{Int64}:
    Region            : Function
    Sublattice pairs  : :B =&gt; :A
    Cell distances    : any
    Hopping range     : (1.0, Neighbors(2))
    Reverse hops      : false
    Coefficient       : 1
  HoppingTerm{Int64}:
    Region            : Function
    Sublattice pairs  : :B =&gt; :A
    Cell distances    : any
    Hopping range     : (1.0, Neighbors(2))
    Reverse hops      : true
    Coefficient       : 1
  OnsiteTerm{Int64}:
    Region            : any
    Sublattices       : B
    Cells             : any
    Coefficient       : 1</code></pre><p><code>HopSelector</code>s and <code>SiteSelector</code>s can be used to restrict <code>onsite</code> and <code>hopping</code> terms as in the example above.</p><div class="admonition is-success"><header class="admonition-header">plusadjoint function</header><div class="admonition-body"><p>The convenience function <code>plusadjoint(term) = term + term&#39;</code> adds the Hermitian conjugate of its argument (<code>term&#39;</code>), equivalent to the <code>+ h.c.</code> notation often used in the literature.</p></div></div><div class="admonition is-info"><header class="admonition-header">Index-agnostic modeling</header><div class="admonition-body"><p>The Quantica approach to defining tight-binding models does not rely on site indices (<code>i,j</code> above), since these are arbitrary, and may even be beyond the control of the user (for example after using <code>supercell</code>). Instead, we rely on physical properties of sites, such as position, distance or sublattice. In the future we might add an interface to also allow index-based modeling if there is demand for it, but we have yet to encounter an example where it is preferable.</p></div></div><h3 id="Parametric-Models"><a class="docs-heading-anchor" href="#Parametric-Models">Parametric Models</a><a id="Parametric-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-Models" title="Permalink"></a></h3><p>The models introduced above are non-parametric, in the sense that they encode fixed, numerical Hamiltonian matrix elements. In actual problems, it is commonplace to have models that depend on a number of free parameters that will need to be adjusted during a calculation. For example, one may need to compute the phase diagram of a system as a function of a spin-orbit coupling or applied magnetic field. For these cases, we have <code>ParametricModel</code>s.</p><p>Parametric models are defined with</p><ul><li><code>@onsite((; params...) -&gt; ...; sites...)</code></li><li><code>@onsite((r; params...) -&gt; ...; sites...)</code></li><li><code>@hopping((; params...) -&gt; ...; hops...)</code></li><li><code>@hopping((r, dr; params...) -&gt; ...; hops...)</code></li></ul><p>where <code>params</code> enter as keyword arguments with (optional) default values. An example of a hopping model with a Peierls phase in the symmetric gauge</p><pre><code class="language-julia-repl hljs">julia&gt; model_perierls = @hopping((r, dr; B = 0, t = 1) -&gt; t * cis(-im * Bz/2 * SA[-r[2], r[1], 0]&#39; * dr))
ParametricModel: model with 1 term
  ParametricHoppingTerm{ParametricFunction{2}}
    Region            : any
    Sublattice pairs  : any
    Cell distances    : any
    Hopping range     : Neighbors(1)
    Reverse hops      : false
    Coefficient       : 1
    Parameters        : [:B, :t]</code></pre><p>Note that <code>B</code> and <code>t</code> are free parameters in the model.</p><p>One can linearly combine parametric and non-parametric models freely, omit argument default values, and use any of the functional argument forms described for <code>onsite</code> and <code>hopping</code> (but not the constant argument form)</p><pre><code class="language-julia-repl hljs">julia&gt; model´ = 2 * (onsite(1) - 2 * @hopping((; t) -&gt; t))
ParametricModel: model with 2 terms
  ParametricHoppingTerm{ParametricFunction{0}}
    Region            : any
    Sublattice pairs  : any
    Cell distances    : any
    Hopping range     : Neighbors(1)
    Reverse hops      : false
    Coefficient       : -4
    Parameters        : [:t]
  OnsiteTerm{Int64}:
    Region            : any
    Sublattices       : any
    Cells             : any
    Coefficient       : 2</code></pre><h3 id="Modifiers"><a class="docs-heading-anchor" href="#Modifiers">Modifiers</a><a id="Modifiers-1"></a><a class="docs-heading-anchor-permalink" href="#Modifiers" title="Permalink"></a></h3><p>There is a third model-related functionality known as a <code>OnsiteModifier</code> and <code>HoppingModifier</code>. Given a model that defines a set of onsite and hopping amplitudes on a subset of sites and hops, one can define a parametric-dependent modification of a subset of said amplitudes. Modifiers are built with</p><ul><li><code>@onsite!((o; params...) -&gt; new_onsite; sites...)</code></li><li><code>@onsite!((o, r; params...) -&gt; new_onsite; sites...)</code></li><li><code>@hopping((t; params...) -&gt; new_hopping; hops...)</code></li><li><code>@hopping((t, r, dr; params...) -&gt; new_hopping; hops...)</code></li></ul><p>For example, the following modifier inserts a peierls phase on any non-zero hopping in a model</p><pre><code class="language-julia-repl hljs">julia&gt; model_perierls! = @hopping!((t, r, dr; B = 0) -&gt; t * cis(-Bz/2 * SA[-r[2], r[1], 0]&#39; * dr))
HoppingModifier{ParametricFunction{3}}:
  Region            : any
  Sublattice pairs  : any
  Cell distances    : any
  Hopping range     : Inf
  Reverse hops      : false
  Parameters        : [:B]</code></pre><p>The difference with <code>model_perierls</code> is that <code>model_perierls!</code> will never add any new hoppings. It will only modify a subset or all previously existing hoppings in a model. Modifiers are not models themselves, and cannot be combined with other models. They are instead meant to be applied sequentially after applying a model.</p><p>We now show how models and modifiers can be used in practice to construct Hamiltonians.</p><div class="admonition is-info"><header class="admonition-header">Mind the `;`</header><div class="admonition-body"><p>While syntax like <code>onsite(2, sublats = :B)</code> and <code>onsite(2; sublats = :B)</code> are equivalent in Julia, due to the way keyword arguments are parsed, the same is not true for macro calls like <code>@onsite</code>, <code>@onsite!</code>, <code>@hopping</code> and <code>@hopping!</code>. These macros just emulate the function call syntax. But to work you must currently always use the <code>;</code> separator for keywords. Hence, something like <code>@onsite((; p) -&gt; p; sublats = :B)</code> works, but <code>@onsite((; p) -&gt; p, sublats = :B)</code> does not.</p></div></div><h2 id="Hamiltonians"><a class="docs-heading-anchor" href="#Hamiltonians">Hamiltonians</a><a id="Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonians" title="Permalink"></a></h2><p>We build a Hamiltonian by combining a lattice and a model, specifying the number of orbitals on each lattice if there is more than one. A spinful graphene model with nearest neighbor hopping <code>t0 = 2.7</code></p><pre><code class="language-julia-repl hljs">julia&gt; lat = LP.honeycomb(); model = hopping(2.7*I);

julia&gt; h = hamiltonian(lat, model; orbitals = 2)
Hamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5
  Harmonic size    : 2 × 2
  Orbitals         : [2, 2]
  Element type     : 2 × 2 blocks (ComplexF64)
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 3.0</code></pre><p>A crucial thing to remember when defining multi-orbital Hamiltonians as the above is that <code>onsite</code> and <code>hopping</code> amplitudes need to be matrices of the correct size. The symbol <code>I</code> in Julia represents the identity matrix of any size, which is convenient to define a spin-preserving hopping in the case above. An alternative would be to use <code>model = hopping(2.7*SA[1 0; 0 1])</code>.</p><div class="admonition is-success"><header class="admonition-header">Models with different number of orbitals per sublattice</header><div class="admonition-body"><p>Non-homogeneous multiorbital models are more advanced but are fully supported in Quantica. Just use <code>orbitals = (n₁, n₂,...)</code> to have <code>nᵢ</code> orbitals in sublattice <code>i</code>, and make sure your model is consistent with that. As in the case of the <code>dim</code> keyword in <code>lattice</code>, you can also use <code>Val(nᵢ)</code> for marginally faster construction.</p></div></div><p>Similarly to <code>LatticePreset</code>s, we also have <code>HamiltonianPresets</code>, also aliased as <code>HP</code>. Currently, we have only <code>HP.graphene(...)</code> and <code>HP.twisted_bilayer_graphene(...)</code>, but we expect to extend this library in the future (see the docstring of <code>HP</code>).</p><h3 id="A-more-elaborate-example:-the-Kane-Mele-model"><a class="docs-heading-anchor" href="#A-more-elaborate-example:-the-Kane-Mele-model">A more elaborate example: the Kane-Mele model</a><a id="A-more-elaborate-example:-the-Kane-Mele-model-1"></a><a class="docs-heading-anchor-permalink" href="#A-more-elaborate-example:-the-Kane-Mele-model" title="Permalink"></a></h3><p>The Kane-Mele model for graphene describes intrinsic spin-orbit coupling (SOC), in the form of an imaginary second-nearest-neighbor hopping between same-sublattice sites, with a sign that alternates depending on hop direction <code>dr</code>. A possible implementation in Quantica would be</p><pre><code class="language-julia hljs">SOC(dr) = 0.05 * ifelse(iseven(round(Int, atan(dr[2], dr[1])/(pi/3))), im, -im)

model =
  hopping(1, range = neighbors(1)) +
  hopping((r, dr) -&gt;  SOC(dr); sublats = :A =&gt; :A, range = neighbors(2)) +
  hopping((r, dr) -&gt; -SOC(dr); sublats = :B =&gt; :B, range = neighbors(2))

h = LatticePresets.honeycomb() |&gt; model

qplot(h, inspector = true)</code></pre><img src="../assets/latticeKM.png" alt="Kane-Mele lattice" width="350" class="center"/><p>The <code>inspector = true</code> keyword enables interactive tooltips in the visualization of <code>h</code> that allows to navigate each <code>onsite</code> and <code>hopping</code> amplitude graphically. Note that sites connected to the unit cell of <code>h</code> by some hopping are included, but are rendered with partial transparency by default.</p><h3 id="ParametricHamiltonians"><a class="docs-heading-anchor" href="#ParametricHamiltonians">ParametricHamiltonians</a><a id="ParametricHamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#ParametricHamiltonians" title="Permalink"></a></h3><p>If we use a <code>ParametricModel</code> instead of a simple <code>TightBindingModel</code> we will obtain a <code>ParametricHamiltonian</code> instead of a simple <code>Hamiltonian</code>, both of which are subtypes of the <code>AbstractHamiltonian</code> type</p><pre><code class="language-julia-repl hljs">julia&gt; model_param = @hopping((; t = 2.7) -&gt; t*I);

julia&gt; h_param = hamiltonian(lat, model_param; orbitals = 2)
ParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5
  Harmonic size    : 2 × 2
  Orbitals         : [2, 2]
  Element type     : 2 × 2 blocks (ComplexF64)
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 3.0
  Parameters       : [:t]</code></pre><p>We can also apply <code>Modifier</code>s by passing them as extra arguments to <code>hamiltonian</code>, which results again in a <code>ParametricHamiltonian</code> with the parametric modifiers applied</p><pre><code class="language-julia-repl hljs">julia&gt; peierls! = @hopping!((t, r, dr; Bz = 0) -&gt; t * cis(-Bz/2 * SA[-r[2], r[1]]&#39; * dr));

julia&gt; h_param_mod = hamiltonian(lat, model_param, peierls!; orbitals = 2)
ParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5
  Harmonic size    : 2 × 2
  Orbitals         : [2, 2]
  Element type     : 2 × 2 blocks (ComplexF64)
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 3.0
  Parameters       : [:Bz, :t]</code></pre><p>Note that <code>SA[-r[2], r[1]]</code> above is a 2D <code>SVector</code>, because since the embedding dimension is <code>E = 2</code>, both <code>r</code> and <code>dr</code> are also 2D <code>SVector</code>s.</p><p>We can also apply modifiers to an already constructed <code>AbstractHamiltonian</code>. The following is equivalent to the above</p><pre><code class="language-julia-repl hljs">julia&gt; h_param_mod = hamiltonian(h_param, peierls!);</code></pre><div class="admonition is-warning"><header class="admonition-header">Modifiers do not commute</header><div class="admonition-body"><p>We can add as many modifiers as we need by passing them as extra arguments to <code>hamiltonian</code>, and they will be applied sequentially, one by one. Beware, however, that modifiers do not necessarily commute, in the sense that the result will in general depend on their order.</p></div></div><p>We can obtain a plain <code>Hamiltonian</code> from a <code>ParametricHamiltonian</code> by applying specific values to its parameters. To do so, simply use the call syntax with parameters as keyword arguments</p><pre><code class="language-julia-repl hljs">julia&gt; h_param_mod(Bz = 0.1, t = 1)
Hamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5
  Harmonic size    : 2 × 2
  Orbitals         : [2, 2]
  Element type     : 2 × 2 blocks (ComplexF64)
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 3.0</code></pre><div class="admonition is-success"><header class="admonition-header">Syntax `lat |&gt; model` and `h |&gt; modifier</header><div class="admonition-body"><p>The common cases <code>lat |&gt; hamiltonian(model)</code> (or <code>hamiltonian(lat, model)</code>) and <code>h |&gt; hamiltonian(modifier)</code> (or <code>hamiltonian(h, modifier)</code>) can be also written as <code>lat |&gt; model</code> and <code>h |&gt; modifier</code>, respectively. Hence <code>hamiltonian(lat, model, modifier)</code> may be written as <code>lat |&gt; model |&gt; modifier</code>. This form however does not allow to specify the number of orbitals per sublattice (it will be one, the default).</p></div></div><h3 id="Obtaining-actual-matrices"><a class="docs-heading-anchor" href="#Obtaining-actual-matrices">Obtaining actual matrices</a><a id="Obtaining-actual-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Obtaining-actual-matrices" title="Permalink"></a></h3><p>For an L-dimensional <code>h::AbstractHamiltonian</code> (i.e. defined on a Lattice with <code>L</code> Bravais vectors), the Hamiltonian matrix between any unit cell with cell index <code>n</code> and another unit cell at <code>n+dn</code> (here known as a Hamiltonian &quot;harmonic&quot;) is given by <code>h[dn]</code></p><pre><code class="language-julia-repl hljs">julia&gt; h[(1,0)]
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:
     ⋅          ⋅      2.7+0.0im  0.0+0.0im
     ⋅          ⋅      0.0+0.0im  2.7+0.0im
     ⋅          ⋅          ⋅          ⋅
     ⋅          ⋅          ⋅          ⋅

julia&gt; h[(0,0)]
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:
     ⋅          ⋅      2.7+0.0im  0.0+0.0im
     ⋅          ⋅      0.0+0.0im  2.7+0.0im
 2.7+0.0im  0.0+0.0im      ⋅          ⋅
 0.0+0.0im  2.7+0.0im      ⋅          ⋅</code></pre><div class="admonition is-success"><header class="admonition-header">Cell distance indices</header><div class="admonition-body"><p>We can use <code>Tuple</code>s or <code>SVector</code>s for cell distance indices <code>dn</code>. An empty <code>Tuple</code> <code>dn = ()</code> will always return the main intra-unitcell harmonic: <code>h[()] = h[(0,0...)] = h[SA[0,0...]]</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Bounded Hamiltonians</header><div class="admonition-body"><p>If the Hamiltonian has a bounded lattice (i.e. it has <code>L=0</code> Bravais vectors), we will simply use an empty tuple to obtain its matrix <code>h[()]</code>. This is not in conflict with the above syntax.</p></div></div><p>Note that if <code>h</code> is a <code>ParametricHamiltonian</code>, such as <code>h_param</code> above, we will get zeros in place of the unspecified parametric terms, unless we actually first specify the values of the parameters</p><pre><code class="language-julia-repl hljs">julia&gt; h_param[(0,0)] # Parameter t is not specified -&gt; it is not applied
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:
     ⋅          ⋅      0.0+0.0im  0.0+0.0im
     ⋅          ⋅      0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im      ⋅          ⋅
 0.0+0.0im  0.0+0.0im      ⋅          ⋅

julia&gt; h_param(t=2)[(0,0)]
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:
     ⋅          ⋅      2.0+0.0im  0.0+0.0im
     ⋅          ⋅      0.0+0.0im  2.0+0.0im
 2.0+0.0im  0.0+0.0im      ⋅          ⋅
 0.0+0.0im  2.0+0.0im      ⋅          ⋅</code></pre><div class="admonition is-info"><header class="admonition-header">ParametricHamiltonian harmonics</header><div class="admonition-body"><p>The above behavior for unspecified parameters is not set in stone and may change in future versions. Another option would be to apply their default values (which may, however, not exist).</p></div></div><p>We are usually not interested in the harmonics <code>h[dn]</code> themselves, but rather in the Bloch matrix of a Hamiltonian     <span>$H(\phi) = \sum_{dn} H_{dn} \exp(-i \phi * dn)$</span> where <span>$H_{dn}$</span> are the Hamiltonian harmonics, <span>$\phi = (\phi_1, \phi_2...) = (k\cdot A_1, k\cdot A_2...)$</span> are the Bloch phases, <span>$k$</span> is the Bloch wavevector and <span>$A_i$</span> are the Bravais vectors.</p><p>We obtain the Bloch matrix using the syntax <code>h(ϕ; params...)</code></p><pre><code class="language-julia-repl hljs">julia&gt; h((0,0))
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:
     ⋅          ⋅      8.1+0.0im  0.0+0.0im
     ⋅          ⋅      0.0+0.0im  8.1+0.0im
 8.1+0.0im  0.0+0.0im      ⋅          ⋅
 0.0+0.0im  8.1+0.0im      ⋅          ⋅

julia&gt; h_param_mod((0.2, 0.3); B = 0.1)
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:
         ⋅                  ⋅          7.92559-1.33431im      0.0+0.0im
         ⋅                  ⋅              0.0+0.0im      7.92559-1.33431im
 7.92559+1.33431im      0.0+0.0im              ⋅                  ⋅
     0.0+0.0im      7.92559+1.33431im          ⋅                  ⋅</code></pre><p>Note that unspecified parameters take their default values when using the call syntax (as per the standard Julia convention). Any unspecified parameter that does not have a default value will produce an <code>UndefKeywordError</code> error.</p><h3 id="Transforming-Hamiltonians"><a class="docs-heading-anchor" href="#Transforming-Hamiltonians">Transforming Hamiltonians</a><a id="Transforming-Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Transforming-Hamiltonians" title="Permalink"></a></h3><p>Like with lattices, we can transform an <code>h::AbstractHamiltonians</code> using <code>transform</code>, <code>translate</code> and <code>supercell</code>. Both <code>transform</code> and <code>translate</code> operate only on the underlying <code>lattice(h)</code> of <code>h</code>, leaving the hoppings and onsite elements unchanged, while <code>supercell</code> acts on <code>lattice(h)</code> and copies the hoppings and onsites of <code>h</code> onto the new sites, preserving the periodicity of the original <code>h</code>.</p><p>Additionally, we can also use <code>wrap</code>, which makes <code>h</code> periodic along a number of its Bravais vectors, while leaving the rest unbounded.</p><pre><code class="language-julia-repl hljs">julia&gt; wrap(HP.graphene(), (0.0,:))
Hamiltonian{Float64,2,1}: Hamiltonian on a 1D Lattice in 2D space
  Bloch harmonics  : 3
  Harmonic size    : 2 × 2
  Orbitals         : [1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 4
  Coordination     : 2.0</code></pre><p>The <code>phases</code> argument of <code>wrap(h, phases)</code> is a <code>Tuple</code> of real numbers and/or colons (<code>:</code>), of length equal to the lattice dimension of <code>h</code>. Each real number <code>ϕᵢ</code> corresponds to a Bravais vector along which the transformed lattice will become periodic, picking up a phase <code>exp(iϕᵢ)</code> in the wrapping hoppings, while each colon leaves the lattice unbounded along the corresponding Bravais vector. In a way <code>wrap</code> is dual to <code>supercell</code>, in the sense that the it applies a different boundary condition to the lattice along the eliminated Bravais vectors, periodic instead of open, as in the case of <code>supercell</code>. The phases <code>ϕᵢ</code> are also connected to Bloch phases, in the sense that e.g. <code>wrap(h, (ϕ₁, :))(ϕ₂) == h(ϕ₁, ϕ₂)</code></p><div class="admonition is-warning"><header class="admonition-header">Caveat of the Bloch-wrap duality</header><div class="admonition-body"><p>The relation <code>wrap(h, phases)(()) = h(phases)</code> is only satisfied in the (most common) case wherein none of the wrapping hoppings added by <code>wrap</code> are  already present in <code>h</code>. This is only a concern with <code>h</code> containing hoppings at ranges equal or larger than half the size of the unit cell.</p></div></div><p>It&#39;s important to understand that, when transforming an <code>h::AbstractHamiltonian</code>, the model used to build <code>h</code> is not re-evaluated. Hoppings and onsite energies are merely copied so as to preserve the periodicity of the original <code>h</code>. As a consequence, these two constructions give different Hamiltonians</p><pre><code class="language-julia hljs">julia&gt; h1 = LP.linear() |&gt; supercell(4) |&gt; hamiltonian(onsite(r -&gt; r[1]));

julia&gt; h2 = LP.linear() |&gt; hamiltonian(onsite(r -&gt; r[1])) |&gt; supercell(4);</code></pre><p>In the case of <code>h1</code> the <code>onsite</code> model is applied to the 4-site unitcell. Since each site has a different position, each gets a different onsite energy.</p><pre><code class="language-julia hljs">julia&gt; h1[()]
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:
 0.0+0.0im      ⋅          ⋅          ⋅
     ⋅      1.0+0.0im      ⋅          ⋅
     ⋅          ⋅      2.0+0.0im      ⋅
     ⋅          ⋅          ⋅      3.0+0.0im</code></pre><p>In contrast <code>h2</code> first gets the <code>onsite</code> model applied with a 1-site unitcell at position <code>r = SA[0]</code>, so all sites in the lattice get onsite energy zero. Only then it is expanded with <code>supercell</code>, which generates a 4-site unitcell with zero onsite energy on all its sites</p><pre><code class="language-julia hljs">julia&gt; h2[()]
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:
 0.0+0.0im      ⋅          ⋅          ⋅
     ⋅      0.0+0.0im      ⋅          ⋅
     ⋅          ⋅      0.0+0.0im      ⋅
     ⋅          ⋅          ⋅      0.0+0.0im</code></pre><p>As a consequence, <code>h</code> and <code>supercell(h)</code> represent exactly the same system, with the same observables, but with a different choice of unitcell.</p><p>These two different behaviors make sense in different situations, so it is important to be aware of the order dependence of transformations. Similar considerations apply to <code>transform</code>, <code>translate</code> and <code>wrap</code> when models are position dependent.</p><h2 id="Bandstructures"><a class="docs-heading-anchor" href="#Bandstructures">Bandstructures</a><a id="Bandstructures-1"></a><a class="docs-heading-anchor-permalink" href="#Bandstructures" title="Permalink"></a></h2><p>The bandstructure of an <code>AbstractHamiltonian</code> is computed using <code>bands</code></p><pre><code class="language-julia-repl hljs">julia&gt; h = LP.honeycomb() |&gt; hopping(1); ϕ₁points = ϕ₂points = range(0, 2π, length = 19);

julia&gt; b = bands(h, ϕ₁points, ϕ₂points)
Bandstructure{Float64,3,2}: 3D Bandstructure over a 2-dimensional parameter space of type Float64
  Subbands  : 1
  Vertices  : 720
  Edges     : 2016
  Simplices : 1296</code></pre><p>The first argument is the Hamiltonian. Here it is defined on an <code>L=2</code> dimensional lattice. The subsequent arguments are collections of Bloch phases on each of the <code>L</code> axes of the Brillouin zone, which define a grid. Here the grid is the direct product <code>ϕ₁points</code> ⊗ <code>ϕ₂points</code>, a uniform 19×19 grid. We can visualize this, as usual, with <code>qplot</code></p><pre><code class="language-julia hljs">julia&gt; using GLMakie; qplot(b, inspector = true)</code></pre><img src="../assets/graphene_bands.png" alt="Graphene bands" width="400" class="center"/><p>The dots on the bands are the points in the grid (they can be omitted with <code>hide = :nodes</code>).</p><h3 id="Band-defects"><a class="docs-heading-anchor" href="#Band-defects">Band defects</a><a id="Band-defects-1"></a><a class="docs-heading-anchor-permalink" href="#Band-defects" title="Permalink"></a></h3><p>Note that the uniform grid contains the Dirac points. This is the reason for the number <code>19</code> of Bloch phases. Note also that it is identified as a point in the bands with <code>degeneracy = 2</code> (the rest have <code>degeneracy = 1</code>). The points on the bands are connected based on eigenstate continuity. This interpolation algorithm can deal with subspace degeneracies, as here. However, Dirac points (and Diabolical Points in general) are required to belong to the mesh to work. If the number of points is reduced to 18 per axis, the Dirac points become unavoidable band dislocations, that appear as missing simplices in the bands:</p><img src="../assets/graphene_bands_bad.png" alt="Graphene bands with Dirac point dislocation" width="400" class="center"/><div class="admonition is-success"><header class="admonition-header">Advanced: band defects and patching</header><div class="admonition-body"><p>If a Dirac point or other type of band dislocation point happens to not belong to the sampling grid, it can be added with the <code>bands</code> keyword <code>defects</code>. Then, it can be reconnected with the rest of the band by increasing the <code>patches::Integer</code> keyword (see <code>bands</code> docstring for details). This &quot;band repair&quot; functionality is experimental, and should only be necessary in some cases with Diabolical Points.</p></div></div><h3 id="Coordinate-mapping-and-band-linecuts"><a class="docs-heading-anchor" href="#Coordinate-mapping-and-band-linecuts">Coordinate mapping and band linecuts</a><a id="Coordinate-mapping-and-band-linecuts-1"></a><a class="docs-heading-anchor-permalink" href="#Coordinate-mapping-and-band-linecuts" title="Permalink"></a></h3><p>The <code>ϕᵢpoints</code> above define a rectangular mesh over which we want to compute the bandstructure. By default, this mesh is taken as a discretization of Bloch phases, so <code>h(ϕᵢ)</code> is diagonalized. We might want, however, a different relation between the mesh and the parameters passed to <code>h</code>, for example if we wish to use wavevectors <code>kᵢ</code> instead of Bloch phases <code>ϕᵢ</code> for the mesh. This is achieved with the <code>mapping</code> keyword, which accepts a function <code>mapping = (mesh_points...) -&gt; bloch_phases</code>,</p><pre><code class="language-julia-repl hljs">julia&gt; h = LP.honeycomb() |&gt; hopping(2); k₁points = range(-2π, 2π, length = 51); k₂points = range(-2π, 2π, length = 51);

julia&gt; Kpoints = [SA[cos(θ) -sin(θ); sin(θ) cos(θ)] * SA[4π/3,0] for θ in range(0, 5*2π/6, length = 6)];

julia&gt; ϕ(k...) =  SA[k...]&#39; * bravais_matrix(h)
ϕ (generic function with 1 method)

julia&gt; b = bands(h,  k₁points, k₂points; mapping = ϕ, defects = Kpoints, patches = 20);

julia&gt; using GLMakie; qplot(b, hide = :nodes, color = :orange)</code></pre><img src="../assets/graphene_bands_k.png" alt="Graphene bands in k-space" width="400" class="center"/><p>To compute a bandstructure along a polygonal line in the Brillouin zone, with vertices <code>ϕᵢ</code> we could once more use the <code>mapping</code> functionality, mapping a set of points <code>xᵢ::Real</code> in the mesh to Bloch phases <code>ϕᵢ::SVector{L}</code>, and interpolating linearly between them. To avoind having to construct this mapping ourselves, <code>mapping</code> accepts a second type of input for this specific usecase, <code>mapping = xᵢ =&gt; ϕᵢ</code>. It even understands common names for high-symmetry points in the Brillouin zone in place of <code>ϕᵢ</code>, such as :Γ, :K, :K´, :M, :X, :Y, and :Z. The following gives a Γ-K-M-Γ linecut for the bands above, where the (Γ, K, M, Γ) points lie at <code>x = (0, 2, 3, 4)</code>, respectively, with 10 subdivisions in each segment,</p><pre><code class="language-julia-repl hljs">julia&gt; b = bands(h, subdiv((0, 2, 3, 4), 10); mapping = (0, 2, 3, 4) =&gt; (:Γ, :K, :M, :Γ));</code></pre><img src="../assets/graphene_bands_linecut.png" alt="Graphene bands along a Γ-K-M-Γ cut" width="400" class="center"/><div class="admonition is-success"><header class="admonition-header">subdiv</header><div class="admonition-body"><p>The <code>subdiv</code> function is a convenience function provided by Quantica that generalizes <code>range</code> (see the corresponding docstring for comprehensive details). It is useful to create collections of numbers as subdivisions of intervals, as in the example above. In its simplest form <code>subdiv(min, max, npoints)</code> is is equivalent to <code>range(min, max, length = npoints)</code> or <code>collect(LinRange(min, max, npoints))</code></p></div></div><p>The <code>mapping</code> keyword understand a third syntax that can be used to map a mesh to the space of Bloch phases and parameters of a <code>ParametricHamiltonian</code>. To this end we use <code>mapping = (mesh_points...) -&gt; ftuple(bloch_phases...; params...)</code>. The <code>ftuple</code> function creates a <code>FrankenTuple</code>, which is a hybrid between a <code>Tuple</code> and a <code>NamedTuple</code>. For example, in the following 1D SSH chain we can compute the bandstructure as a function of Bloch phase <code>ϕ</code> <em>and</em> hopping <code>t´</code></p><pre><code class="language-julia-repl hljs">julia&gt; h = LP.linear() |&gt; supercell(2) |&gt; @hopping((r, dr; t = 1, t´ = 1) -&gt; iseven(r[1]-1/2) ? t : t´);

julia&gt; b = bands(h, subdiv(0, 2π, 11), subdiv(0, 10, 11), mapping = (ϕ, y) -&gt; ftuple(ϕ; t´ = y/5), patches = 20)
Bandstructure{Float64,3,2}: 3D Bandstructure over a 2-dimensional parameter space of type Float64
  Subbands  : 1
  Vertices  : 249
  Edges     : 664
  Simplices : 416

julia&gt; qplot(b, nodedarken = 0.5, axis = (; aspect = (1,1,1), xlabel = &quot;ϕ&quot;, ylabel = &quot;t´/t&quot;, zlabel = &quot;ϵ&quot;), fancyaxis = false)</code></pre><img src="../assets/ssh_bands.png" alt="SSH bandstructure as a function of `ϕ` and `t´/t" width="400" class="center"/><p>Note that since we didn&#39;t specify a value for <code>t</code>, it assumed its default <code>t=1</code>. In this case we needed to patch the defect at <code>(ϕ, t´) = (π, 1)</code> (topological transition) using the <code>patches</code> keyword to avoid a band dislocation.</p><h3 id="Band-indexing-and-slicing"><a class="docs-heading-anchor" href="#Band-indexing-and-slicing">Band indexing and slicing</a><a id="Band-indexing-and-slicing-1"></a><a class="docs-heading-anchor-permalink" href="#Band-indexing-and-slicing" title="Permalink"></a></h3><p>The individual subbands in a given <code>b::Bandstructure</code> can be obtained with <code>b[inds]</code> with <code>inds::Integer</code> or <code>inds::Vector</code>, just as if <code>b</code> where a normal <code>AbstractVector</code>. The extracted subbands can also be plotted directly. The following example has 12 subbands, of which we extract and plot the first and last</p><pre><code class="language-julia-repl hljs">julia&gt; h = LP.triangular() |&gt; supercell(4) |&gt; hopping(1) + onsite(r -&gt; 4*rand());

julia&gt; b = bands(h, subdiv(0, 2π, 31), subdiv(0, 2π, 31))
Bandstructure{Float64,3,2}: 3D Bandstructure over a 2-dimensional parameter space of type Float64
  Subbands  : 12
  Vertices  : 15376
  Edges     : 44152
  Simplices : 28696

julia&gt; qplot(b, hide = :nodes)

julia&gt; qplot(b[[1, end]], hide = :nodes)</code></pre><img src="../assets/bands_indexed.png" alt="Extracting and plotting a subset of the subbands in a bandstructure" width="400" class="center"/><p>For a band in a 2D Brillouin zone, we can also obtain the intersection of a bandstructure with a plane of constant energy <code>ϵ=2</code> using the syntax <code>b[(:,:,2)]</code>. A section at fixed Bloch phase <code>ϕ₁=0</code> (or mesh coordinate <code>x₁=0</code> if <code>mapping</code> was used), can be obtained with <code>b[(0,:,:)]</code>. This type of band slicing can be generalized to higher dimensional bandstructures, or to more than one constrain (e.g. energy and/or a subset of Bloch phases). As an example, this would be the Fermi surface of a nearest-neighbor cubic-lattice Hamiltonian at Fermi energy <code>µ = 0.2t</code></p><pre><code class="language-julia-repl hljs">julia&gt; pts = subdiv(0, 2π, 41); b = LP.cubic() |&gt; hopping(1) |&gt; bands(pts, pts, pts)
Bandstructure{Float64,4,3}: 4D Bandstructure over a 3-dimensional parameter space of type Float64
  Subbands  : 1
  Vertices  : 68921
  Edges     : 462520
  Simplices : 384000

julia&gt; qplot(b[(:, :, :, 0.2)], hide = :nodes)</code></pre><img src="../assets/cubic_Fermi_surface.png" alt="Fermi surface of a cubic crystal at `µ = 0.2t`" width="400" class="center"/><div class="admonition is-warning"><header class="admonition-header">On simplex orientation of bandstructure slices</header><div class="admonition-body"><p>The above example showcases a limitation of the current band slicing algorithm, which doesn&#39;t align all faces of the resulting manifold to point to have a coninuous orientation. The dark and bright regions of the surface reveals that approximately half of the faces are facing inward and the rest outward. Hopefully, this will be fixed in future versions.</p></div></div><h2 id="GreenFunctions"><a class="docs-heading-anchor" href="#GreenFunctions">GreenFunctions</a><a id="GreenFunctions-1"></a><a class="docs-heading-anchor-permalink" href="#GreenFunctions" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 21 June 2023 16:31">Wednesday 21 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
